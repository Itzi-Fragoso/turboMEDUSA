?rep
		cladeNames <-c("Base", "Clade1", "Clade2");
			cladeNames <- rep(cladeNames, each=2);
cladeNames
			parameterSummary <- cbind(Clade=cladeNames, summPar);
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);
cladeNames
			parameterSummary <- cbind(Clade=cladeNames, summPar);
parameterSummary
baseAIC
sis.res
ls()
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		baseAIC <- NULL;#
		sisterAIC <- NULL;#
		AICscores <- NULL;#
		#
		for (i in 1:length(results))#
		{#
			base <- results[[i]][[1]];#
			sis <- results[[i]][[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			baseAIC <- c(baseAIC, as.numeric(base[criterion]));#
			sisterAIC <- c(sisterAIC, as.numeric(sis[criterion]));#
			AICscores <- c(AICscores, c(as.numeric(base[criterion]), as.numeric(sis[criterion])));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);
AICscores
x <- seq(from=1, to=100, by=1)
x
for (i in 1:length(x))#
{#
	cat(x, "\n");#
}
for (i in 1:length(x))#
{#
	cat(x[i], "\n");#
}
for (i in 1:length(x), by=2)#
{#
	cat(x[i], "\n");#
}
for (i in seq(from=1, to=100, by=1))#
{#
	cat(x[i], "\n");#
}
for (i in seq(from=1, to=100, by=2))#
{#
	cat(x[i], "\n");#
}
		AICscores <- list();
		for (i in 1:length(results))#
		{#
			base <- results[[i]][[1]];#
			sis <- results[[i]][[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			baseAIC <- c(baseAIC, as.numeric(base[criterion]));#
			sisterAIC <- c(sisterAIC, as.numeric(sis[criterion]));#
			AICscores <- c(AICscores, c(as.numeric(base[criterion]), as.numeric(sis[criterion])));#
		}
AICscores
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			base <- results[[i]][[1]];#
			sis <- results[[i]][[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			baseAIC <- c(baseAIC, as.numeric(base[criterion]));#
			sisterAIC <- c(sisterAIC, as.numeric(sis[criterion]));#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}
AICscores
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		base <- results[[1]];#
		sis <- results[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=results$fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=results$fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			base <- results[[i]][[1]];#
			sis <- results[[i]][[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
	} else { # multiple trees#
		#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
summarizeModelFit <- function(fit1, fit2)#
{#
	#
	#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
	weights <- lapply(AICscores, calculateModelWeights);
weights
unlist(weights)
unlist(weights)$delta1
unlist(weights)[delta1]
unlist(weights) -> foo
attributes(foo)
foo$delta1
class(foo)
unlist(weights)["delta1"]
unlist(weights)["delta2"]
unlist(weights)["delta2"][1]
unlist(weights)["delta2"][2]
weights
weights$delta
delta %in% weights
AICscores
unlist(AICscores)
unlist(weights)
	lapply(weights, "[[", delta)
delta
	lapply(weights, "[[", "delta")
lapply(weights, "[[", "delta"[1])
	lapply(weights, "[[", "delta"[[1]])
weights
apply(weights, "[[", "delta")
lapply(weights, "[[", "delta")
unlist(lapply(weights, "[[", "delta"))
AICscores
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			base <- results[[i]][[1]];#
			sis <- results[[i]][[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
#			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
			AICscores <- c(AICscores, c(as.numeric(base[criterion]), as.numeric(sis[criterion])));#
		}
AICscores
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			base <- results[[i]][[1]];#
			sis <- results[[i]][[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}
AICscores
weights
sis.res
lapply(weights, "[[", "delta")
lapply(weights, "[[", "delta")[1]
lapply(weights, "[[", "delta")[[1]]
lapply(weights, "[[", "delta")
lapply(weights, "[[", "delta"[[1]][1])
lapply(weights, "[[", "delta"[[1]][[1]])
i=1
AICscores[i]
		x <- calculateModelWeights(AICscores[i]);
		x <- calculateModelWeights(AICscores[[i]]);
x
	delta <- NULL;#
	w <- NULL;
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
	}
x
delta
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}
AICscores
delta
w
sis.res
delta[,1]
	base <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));
base
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w")
res
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));
res
	modelSummary <- cbind(Model=c("Base", "Sisters"), res);
modelSummary
	modelSummary <- as.data.frame(cbind(Model=c("Base", "Sisters"), res));
modelSummary
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	#
	res <- as.data.frame(res);
res
	modelSummary <- cbind(Model=c("Base", "Sisters"), res);
modelSummary
delta[,1] == 0
	best <- sum(delta[,1] == 0) / length(delta[,1]);
	best <- c(best, 1-best);
best
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);
modelSummary
summarizeMultipleModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}
summarizeMultipleModelFit(AICscores)
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		base <- results[[1]];#
		sis <- results[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=results$fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=results$fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			base <- results[[i]][[1]];#
			sis <- results[[i]][[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(phy)
phy
phy <- phy[[1]]
fitSisters(phy)
node
fitSisters(phy, node=422)
ls()
x
x <- rep(phy, 3)
x
phy
x <- rep(phy, 3)
class(x)
x <- c(phy, phy, phy)
x
fitSisters(x, node=422)
fitSisters(x, node=422) -> foo
class(foo)
foo
fitSisters(phy, node=422) -> foo2
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(models);#
	}
		models <- runFitSisters(phy, richness);
models
length(models)
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		base <- results[[1]];#
		sis <- results[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=results$fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=results$fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			base <- results[[i]][[1]];#
			sis <- results[[i]][[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
	summ <- sisterFitSummary(results=models, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);
fitSisters(phy, node=422) -> foo2
class(foo2)
foo2
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		base <- results[[1]];#
		sis <- results[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=results$fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=results$fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			base <- results[[i]][[1]];#
			sis <- results[[i]][[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
foo
attributes(foo)
foo$phy
models
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		model$phy <- phy;#
		#
		return(models);#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		models <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		models <- lapply(phy, runFitSisters, richness);#
	}#
	#
	#
## Summary#
	summ <- sisterFitSummary(results=models, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, desc=desc, models=models, phy=phy, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
#
#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		models$phy <- phy;#
		#
		return(models);#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		models <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		models <- lapply(phy, runFitSisters, richness);#
	}#
	#
	#
## Summary#
	summ <- sisterFitSummary(results=models, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, desc=desc, models=models, phy=phy, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
#
#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		models$phy <- phy;#
		#
		return(models);#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		models <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		models <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=models, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, desc=desc, models=models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
#
#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}
fitSisters(phy, node=422) -> foo2
fitSisters(x, node=422) -> foo
phy
fitSisters(phy, node=422) -> foo2
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy);#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res$models, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
#
#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}
fitSisters(x, node=422) -> foo
fitSisters(phy, node=422) -> foo
res <- runFitSisters(phy, richness);
res
	summ <- sisterFitSummary(results=res$models, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);
results=res$models
results
		res <- runFitSisters(phy, richness);
res
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy);#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res$models, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
#
#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}
		res <- runFitSisters(phy, richness);
res
attributes(res)
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);
models
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res$models, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
#
#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}
		res <- runFitSisters(phy, richness);
phy
richness
phy <- x[[1]]
phy
		res <- runFitSisters(phy, richness);
res
	summ <- sisterFitSummary(results=res$models, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);
results=res$models
res
attributes(res)
models
list(models=models, phy=phy)
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res$models, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
#
#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}
runFitSisters
rm(runFitSisters)
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}
runFitSisters
		res <- runFitSisters(phy, richness);
res
	summ <- sisterFitSummary(results=res$models, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res$models, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
#
#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		base <- results[[1]];#
		sis <- results[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=results$fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=results$fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			base <- results[[i]][[1]];#
			sis <- results[[i]][[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(x, node=422) -> foo
fitSisters(phy, node=422) -> foo
phy <- x
		res <- lapply(phy, runFitSisters, richness);
res
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		base <- results[[1]];#
		sis <- results[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=results$fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=results$fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		models <- results$models;#
		#
		for (i in 1:length(models))#
		{#
			base <- models[[i]][[1]];#
			sis <- models[[i]][[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res$models, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
#
#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}
fitSisters(phy, node=422) -> foo
fitSisters(x, node=422) -> foo
fitSisters(x[[1]], node=422) -> foo
		res <- lapply(phy, runFitSisters, richness);
res
res$models
attributes(res)
res
length(res)
i
results[[i]]$models;
results[[i]]
results
results <- res
res
res[[3]]
res[[3]]$models
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		base <- results[[1]];#
		sis <- results[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=results$fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=results$fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[i]][[1]];#
			sis <- models[[i]][[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
#
#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}
fitSisters(x[[1]], node=422) -> foo
fitSisters(x, node=422) -> foo
phy
phy <- phy[[1]]
		res <- runFitSisters(phy, richness);
res
length(res)
		res <- runFitSisters(phy, richness);
res
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[i]][[1]];#
			sis <- models[[i]][[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(x, node=422) -> foo
fitSisters(x[[1]], node=422) -> foo
phy
phy <- x
		res <- lapply(phy, runFitSisters, richness);
res
class(res)
length(res)
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(x[[1]], node=422) -> foo
fitSisters(x, node=422) -> foo
fitSisters(x, node="root") -> foo
fitSisters(x, node="root") -> foo
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(x, node="root") -> foo
plotNN(phy)
plotNN(phy[[1]])
fitSisters(x, node=326) -> foo
fitSisters(x, node=327) -> foo
## Only used for base model#
medusaMLFitBase <- function (z, sp, model, fixPar, criterion)#
{#
	fit <- getOptimalModelFlavour(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	steps <- c("add", as.numeric(min(z[,"anc"])));#
	#
	return(list(par=matrix(fit$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=fit$lnLik, lnLik=fit$lnLik,#
		split.at=min(z[,"anc"]), aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3],#
		cut.at="node", model=fit$model, z=z, step=matrix(steps, nrow=1, dimnames=list(NULL,c("step", "node")))));#
}#
#
#
## Split the edge matrix 'z' by adding a partition at node 'node'.#
## The list 'desc' is a list of descendants (see makeCacheMedusa).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
medusaSplitStem <- function (node, z, desc, extract=FALSE)#
{#
	part <- z[,"partition"];#
	base <- min(part[z[,"anc"] == node | z[,"dec"] == node]);#
	tag <- max(part) + 1;#
	i <- desc[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	if (extract) {z <- z[idx,,drop=FALSE];}#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
medusaSplitNode <- function (node, z, desc, extract=FALSE)#
{#
	part <- z[,"partition"];#
	base <- min(part[z[,"anc"] == node]);#
	tag <- max(part) + 1;#
	i <- desc[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	if (extract) {z <- z[idx,,drop=FALSE];}#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
## The general function for when the flavour of shiftCut is unknown#
medusaSplit <- function (node, z, desc, shiftCut)#
{#
	descendants <- desc$stem; # will be correct half the time#
	if (shiftCut == "node") {descendants <- desc$node;}#
	#
	part <- z[,"partition"];#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted, especially for large trees.#
prefitTips <- function (pend.nodes, z, sp, model, fixPar, criterion, mc, numCores)#
{#
	if (all(z[z[,"dec"] %in% pend.nodes,"n.t"] == 1) && (model == "yule" || model == "mixed"))#
	{#
		fit <- list(list(par=c(0, NA), lnLik=0, model="yule"));#
		fit <- rep(fit, length(pend.nodes));#
		return(fit);#
	}#
	#
	if (model == "mixed") # yule will always have a better AIC for tip, regardless of richness#
	{#
		if (mc) {#
			tips <- mclapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model="yule", fixPar=fixPar, criterion=criterion, mc.cores=numCores);#
		} else {#
			tips <- lapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model="yule", fixPar=fixPar, criterion=criterion);#
		}#
	} else {#
		if (mc) {#
			tips <- mclapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model=model, fixPar=fixPar, criterion=criterion, mc.cores=numCores);#
		} else {#
			tips <- lapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	return(tips);#
}#
#
medusaMLPrefitTip <- function (node, z, sp, model, fixPar, criterion)#
{#
	z.tip <- z[z[,"dec"] == node,,drop=FALSE];#
	#
	if (all(z.tip[,"n.t"] == 1) && (model == "yule" || model == "mixed"))#
	{#
		return(list(par=c(0, NA), lnLik=0, model="yule"));#
	}#
	#
	fit <- getOptimalModelFlavour(z=z.tip, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
medusaMLPrefitNode <- function (node, z, desc, sp, model, fixPar, criterion)#
{#
	z.node <- medusaSplitNode(node=node, z=z, desc=desc, extract=TRUE)$z;#
	fit <- getOptimalModelFlavour(z=z.node, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
medusaMLPrefitStem <- function (node, z, desc, sp, model, fixPar, criterion)#
{#
	z.stem <- medusaSplitStem(node=node, z=z, desc=desc, extract=TRUE)$z;#
#	z.stem <- z.stem[z.stem[,"partition"] == 2,,drop=FALSE];#
	fit <- getOptimalModelFlavour(z=z.stem, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
#
## When model == mixed, fit both and find optimal flavour#
getOptimalModelFlavour <- function (z, sp, model, fixPar, criterion)#
{#
	fit.bd <- NULL;#
	fit.yule <- NULL;#
	fit <- NULL;#
	#
	if (model == "yule" | model == "mixed")#
	{#
		fit.yule <- medusaMLFitPartition(z=z, sp=sp, model="yule");#
		fit.yule$model <- "yule";#
	}#
	if (model == "bd" | model == "mixed")#
	{#
		if (is.na(sp[2])) {sp[2] <- 0.5;}#
		fit.bd <- medusaMLFitPartition(z=z, sp=sp, model="bd");#
		fit.bd$model <- "bd";#
	}#
	if (model != "mixed" && model != "bd" && model != "yule") # i.e. the constrained models#
	{#
		fit <- medusaMLFitPartition(z=z, sp=sp, model=model, fixPar=fixPar);#
		fit$model <- model;#
		return(fit);#
	}#
	#
## Figure out which model fits best#
	if (is.null(fit.bd))#
	{#
		fit <- fit.yule;#
	} else if (is.null(fit.yule)) {#
		fit <- fit.bd;#
	} else {#
## Considering both models#
		fit <- getBestPartialModel(fit1=fit.yule, fit2=fit.bd, z=z, criterion=criterion);#
		#
		#
		# fit.bd.val <- calculateModelFit(fit=fit.bd, z=z); ## NOT valid here, as sample size is NOT z#
		# fit.yule.val <- calculateModelFit(fit=fit.yule, z=z);#
		#
## The length condition below deals with single edges, where AICc correction becomes undefined (n-k-1)#
  # Undefined#
	}#
	return(fit);#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
medusaMLUpdate <- function (node, z, desc, fit, prefit, num.tips, root.node, model, fixPar, criterion, shiftCut, preserveModelFlavour)#
{#
## various combinations possible#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cool <- TRUE;#
	#
	# new.part.1 <- NULL;#
	# new.part.2 <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" | shiftCut == "both" | node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		obj.stem <- medusaSplitStem(node=node, z=z, desc=desc$stem);#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
		if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
		{#
			fit$lnLik <- -Inf;#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			return(fit);#
		}#
		#
## Everything is cool; proceed.#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
## first, consider diminshed clade. may result in a clade that has been cached previously#
		dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		#
## check if diminished clade conforms to a cached clade#
		x <- which(dimClade[,"anc"] == min(dimClade[,"anc"]));#
		if (length(x) == 1) # a cut-at-stem scenario#
		{#
			y <- as.numeric(dimClade[x, "dec"]);#
			if (length(unique(dimClade[(dimClade[,"dec"] < root.node),"dec"])) == prefit$num.tips[[y]])#
			{#
				if (y < root.node)#
				{#
					fit1.stem <- prefit$tips[[y]];#
				} else {#
					fit1.stem <- prefit$virgin.nodes$stem[[y - root.node]];#
				}#
#				cat("Worked! Clade is of size:", length(dimClade[,1]), "\n")#
			}#
		}#
				#
		if(is.null(fit1.stem))#
		{#
			if (model == "mixed")#
			{#
				if (preserveModelFlavour)  ## In mixed models, may want to conserve flavour of previously fit model#
				{#
					if (sum(!is.na(sp)) < 2) # yule#
					{#
						fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model="yule");#
					} else {#
						fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model="bd");#
					}#
				} else {#
## consider both model flavours#
					fit1.stem <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
				}#
			} else {#
				fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model=model, fixPar=fixPar);#
				fit1.stem$model <- model;#
			}#
		}#
		#
		#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == prefit$num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else {#
## novel shift#
			newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
			fit2.stem <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	#
	if ((shiftCut == "node" || shiftCut == "both") && (node > root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		obj.node <- medusaSplitNode(node=node, z=z, desc=desc$node);#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		#
## Need to check if cut is valid. May be inadmissable because of pattern of previous breaks (especially with shiftCut=both)#
		if (is.na(aff[1]) || is.na(aff[2]))#
		{#
			cool <- FALSE;#
		}		#
## Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (sum(z.node[,"partition"] == aff[1]) == 0 || sum(z.node[,"partition"] == aff[2]) == 0 || !cool)#
		{#
			fit$lnLik <- -Inf;#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			return(fit);#
		}#
		#
## Everything is cool; proceed.#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
## first, consider diminshed clade. may result in a clade that has been cached#
		dimClade <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		#
		if (model == "mixed")#
		{#
			if (preserveModelFlavour)  ## In mixed models, may want to conserve flavour of previously fit model#
			{#
				if (sum(!is.na(sp)) < 2) # yule#
				{#
					fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model="yule"); # should this change? probably.#
				} else {#
					fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model="bd");#
				}#
			} else {#
## consider both model flavours#
				fit1.node <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
			}#
		} else {#
			fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model=model, fixPar=fixPar);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == prefit$num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		} else {#
## novel shift#
			newClade <- z.node[z.node[,"partition"] == aff[2],,drop=FALSE];#
			fit2.node <- getOptimalModelFlavour (z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par, model=model);#
		stem.fit <- calculateModelFit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par, model=model);#
		node.fit <- calculateModelFit(fit=node.val, z=z);#
		#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
## sp = initializing values for r & epsilon. fixPar = fixed value for constrained model.#
## Default values should never be used (except for first model), as the values from the previous model are passed in.#
## The 'suppressWarnings' catches harmless warnings for when extreme parameter values are tried, #
## generating -Inf log-likelihoods. Depends on sclae of the tree.#
medusaMLFitPartition <- function (z, sp=c(0.05, 0.5), model, fixPar=NULL)#
{#
#	new.part <- z[z[,"partition"] == partition.id,,drop=FALSE]; # now subsetted earlier#
	new.part <- z;#
	#
# Construct likelihood function:#
	lik <- makePartitionLikelihood(partition=new.part, model=model, fixPar=fixPar);#
	foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
	#
	if (model == "bd")#
	{#
		fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=5000));#
		#
		if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
		#
		return(list(par=exp(fit$par), lnLik=-fit$value));#
	}#
		#
## grab values to get an intelligent upper bound on b or r#
		node.richness  <- sum(new.part[,"n.t"], na.rm=TRUE);#
		depth <- max(new.part[,"t.0"]);#
		#
# use different intervals based on model flavour#
	#
	if (model == "yule") {#
		#
		maxVal <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {maxVal <- 1e-5;#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-25, log(maxVal))));#
		par <- c(exp(fit$minimum), NA);#
		#
		while (par[1]/maxVal > 0.95) # crash against boundary; doesn't seem to get used...#
		{#
			maxVal <- par[1] * 3;#
			cat("Hit boundary\n")#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(par[1]/2), log(maxVal))));#
			par <- c(exp(fit$minimum), NA);#
		}#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedD") {#
## this is the messiest model flavour; reasonable range depends on magnitude of fixD#
		#
		x <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {x <- 0.01;} # MLE for single tip will be r ~ 0#
		maxVal <- fixPar + x;#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(log(fixPar), log(maxVal))));#
		b <- exp(fit$minimum);#
		par <- c((b - fixPar), (fixPar / b));#
		#
		while (fit$objective == Inf)#
		{#
			cat("maxVal =", maxVal, "; b =", b, "; r =", b - fixPar, "; epsilon =", fixPar/b, "\n")#
			#
			x <- x * 0.75;#
			maxVal <- fixPar + x;#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(fixPar), log(maxVal))));#
			b <- exp(fit$minimum);#
			par <- c((b - fixPar), (fixPar / b));#
		}#
		#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedEpsilon") {#
		#
		maxVal <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {maxVal <- 1;}#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-25, log(maxVal))));#
		par <- c(exp(fit$minimum), sp[2]);#
		#
		while (par[1]/maxVal > 0.9) # crash against boundary#
		{#
			maxVal <- par[1] * 3;#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(par[1]/2), log(maxVal))));#
			par <- c(exp(fit$minimum), sp[2]);#
		}#
		#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedB") {#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-50, log(fixPar))));#
		d <- exp(fit$minimum);#
		par <- c((fixPar - d), (d / fixPar));#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedR") {#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-50, 0)));#
		par <- c(sp[1], exp(fit$minimum));#
		return(list(par=par, lnLik=-fit$objective));#
	}#
}#
#
#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
#
## makePartitionLikelihood: generate a likelihood function for a single partition.#
makePartitionLikelihood <- function (partition, model, fixPar)#
{#
	i.int <- is.na(partition[,"n.t"])#
	i.pend <- !(i.int)#
	n.int <- sum(i.int);#
	#
	simple <- FALSE;#
	if (all(partition[,"n.t"] == 1, na.rm = TRUE)) {simple <- TRUE;}#
	#
	if (simple) {#
		if (model == "yule") {#
			sum.t <- sum(partition[,"t.len"]);#
			f <- function(pars) {#
				if (pars <= 0) return(-Inf);#
				r <- pars[1];#
				return(n.int * log(r) - r * sum.t);#
			}#
			return(f)#
		} #
		#
		sum.int.t.len <- sum(partition[i.int,"t.len"]);#
		int.t.0 <- partition[i.int,"t.0"];#
		pend.t.len <- partition[i.pend,"t.len"];#
		#
		if (model == "bd") {#
			f <- function(pars) {#
				r <- pars[1];#
				epsilon <- pars[2];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedD") {#
			fixD <- fixPar;#
			f <- function(pars) {#
				b <- pars[1];#
				r <- b - fixD;#
				epsilon <- fixD/b;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedEpsilon") {#
			epsilon <- fixPar;#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedR") {#
			r <- fixPar;#
			f <- function(pars) {#
				epsilon <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedB") {#
			fixB <- fixPar;#
			f <- function(pars) {#
				d <- pars[1];#
				r <- fixB - d;#
				epsilon <- d/fixB;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		}#
	} else {#
		sum.int.t.len <- sum(partition[i.int,"t.len"]);#
		pend.t.len <- partition[i.pend,"t.len"];#
		pend.n.t.minus.1 <- partition[i.pend,"n.t"] - 1;#
		#
		if (model == "yule") {#
			sum.pend.t.len <- sum(pend.t.len);#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0) return(-Inf);#
				return(n.int * log(r) - r * sum.int.t.len + sum(-pend.t.len * r + pend.n.t.minus.1*log(1 - exp(-pend.t.len * r))));#
			}#
			return(f)#
		}#
		#
		int.t.0 <- partition[i.int,"t.0"];#
		#
		if (model == "bd") {#
			f <- function(pars) {#
				r <- pars[1];#
				epsilon <- pars[2];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedD") {#
			fixD <- fixPar;#
			f <- function(pars) {#
				b <- pars[1];#
				r <- b - fixD;#
				epsilon <- fixD/b;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedEpsilon") {#
			epsilon <- fixPar;#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedR") {#
			r <- fixPar;#
			f <- function(pars) {#
				epsilon <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedB") {#
			fixB <- fixPar;#
			f <- function(pars) {#
				d <- pars[1];#
				r <- fixB - d;#
				epsilon <- d/fixB;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		}#
	}#
}#
#
#
#
## 'fit' contains '$par' and '$lnlik' and '$model'; check last value for presence of fixed parameters#
calculateModelFit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	model = fit$model[1];#
	#
	if (model == "fixedEpsilon" || model == "fixedR" || model == "fixedB" || model == "fixedD")#
	{#
		k <- 2 * num.models - 1;#
	} else {#
		k <- sum(!is.na(fit$par)) + num.models - 1; # number of estimated parameters + number of breaks#
	}#
	#
	lnLik <- fit$lnLik;#
	#
#	aic <- -2 * lnLik + 2*k;#
	aic <- getAIC(lnLik, k);#
#	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	aicc <- getAICc(lnLik, k, n);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
getAIC <- function (lnLik, k)#
{#
	return(-2 * lnLik + 2*k);#
}#
#
getAICc <- function (lnLik, k, n)#
{#
	return(getAIC(lnLik,k) + 2*k*(k+1)/(n-k-1));#
}#
#
## Used for comparing models fit to the same partition#
getBestPartialModel <- function (fit1, fit2, z, criterion)#
{#
	n <- (length(z[,1]) + 1); # the number of nodes involved#
## Add '1' to parameters to account for break#
	k1 <- 1 + sum(!is.na(fit1$par));#
	k2 <- 1 + sum(!is.na(fit2$par));#
	#
	if (n - k1 <= 1 || n - k2 <= 1) # deals with single edges, where AICc correction becomes undefined. use AIC.#
	{#
		if (getAIC(fit1$lnLik,k1) < getAIC(fit2$lnLik,k2))#
		{#
			return(fit1);#
		} else {#
			return(fit2);#
		}#
	} else {#
		if (criterion == "aicc")#
		{#
			if (getAICc(fit1$lnLik,k1,n) < getAICc(fit2$lnLik,k2,n))#
			{#
				return(fit1);#
			} else {#
				return(fit2);#
			}#
		} else {#
			if (getAIC(fit1$lnLik,k1) < getAIC(fit2$lnLik,k2))#
			{#
				return(fit1);#
			} else {#
				return(fit2);#
			}#
		}#
	}#
}
## Only used for base model#
medusaMLFitBase <- function (z, sp, model, fixPar, criterion)#
{#
	fit <- getOptimalModelFlavour(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	steps <- c("add", as.numeric(min(z[,"anc"])));#
	#
	return(list(par=matrix(fit$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=fit$lnLik, lnLik=fit$lnLik,#
		split.at=min(z[,"anc"]), aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3],#
		cut.at="node", model=fit$model, z=z, step=matrix(steps, nrow=1, dimnames=list(NULL,c("step", "node")))));#
}#
#
#
## Split the edge matrix 'z' by adding a partition at node 'node'.#
## The list 'desc' is a list of descendants (see makeCacheMedusa).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
medusaSplitStem <- function (node, z, desc, extract=FALSE)#
{#
	part <- z[,"partition"];#
	base <- min(part[z[,"anc"] == node | z[,"dec"] == node]);#
	tag <- max(part) + 1;#
	i <- desc[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	if (extract) {z <- z[idx,,drop=FALSE];}#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
medusaSplitNode <- function (node, z, desc, extract=FALSE)#
{#
	part <- z[,"partition"];#
	base <- min(part[z[,"anc"] == node]);#
	tag <- max(part) + 1;#
	i <- desc[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	if (extract) {z <- z[idx,,drop=FALSE];}#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
## The general function for when the flavour of shiftCut is unknown#
medusaSplit <- function (node, z, desc, shiftCut)#
{#
	descendants <- desc$stem; # will be correct half the time#
	if (shiftCut == "node") {descendants <- desc$node;}#
	#
	part <- z[,"partition"];#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted, especially for large trees.#
prefitTips <- function (pend.nodes, z, sp, model, fixPar, criterion, mc, numCores)#
{#
	if (all(z[z[,"dec"] %in% pend.nodes,"n.t"] == 1) && (model == "yule" || model == "mixed"))#
	{#
		fit <- list(list(par=c(0, NA), lnLik=0, model="yule"));#
		fit <- rep(fit, length(pend.nodes));#
		return(fit);#
	}#
	#
	if (model == "mixed") # yule will always have a better AIC for tip, regardless of richness#
	{#
		if (mc) {#
			tips <- mclapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model="yule", fixPar=fixPar, criterion=criterion, mc.cores=numCores);#
		} else {#
			tips <- lapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model="yule", fixPar=fixPar, criterion=criterion);#
		}#
	} else {#
		if (mc) {#
			tips <- mclapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model=model, fixPar=fixPar, criterion=criterion, mc.cores=numCores);#
		} else {#
			tips <- lapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	return(tips);#
}#
#
medusaMLPrefitTip <- function (node, z, sp, model, fixPar, criterion)#
{#
	z.tip <- z[z[,"dec"] == node,,drop=FALSE];#
	#
	if (all(z.tip[,"n.t"] == 1) && (model == "yule" || model == "mixed"))#
	{#
		return(list(par=c(0, NA), lnLik=0, model="yule"));#
	}#
	#
	fit <- getOptimalModelFlavour(z=z.tip, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
medusaMLPrefitNode <- function (node, z, desc, sp, model, fixPar, criterion)#
{#
	z.node <- medusaSplitNode(node=node, z=z, desc=desc, extract=TRUE)$z;#
	fit <- getOptimalModelFlavour(z=z.node, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
medusaMLPrefitStem <- function (node, z, desc, sp, model, fixPar, criterion)#
{#
	z.stem <- medusaSplitStem(node=node, z=z, desc=desc, extract=TRUE)$z;#
#	z.stem <- z.stem[z.stem[,"partition"] == 2,,drop=FALSE];#
	fit <- getOptimalModelFlavour(z=z.stem, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
#
## When model == mixed, fit both and find optimal flavour#
getOptimalModelFlavour <- function (z, sp, model, fixPar, criterion)#
{#
	fit.bd <- NULL;#
	fit.yule <- NULL;#
	fit <- NULL;#
	#
	if (model == "yule" | model == "mixed")#
	{#
		fit.yule <- medusaMLFitPartition(z=z, sp=sp, model="yule");#
		fit.yule$model <- "yule";#
	}#
	if (model == "bd" | model == "mixed")#
	{#
		if (is.na(sp[2])) {sp[2] <- 0.5;}#
		fit.bd <- medusaMLFitPartition(z=z, sp=sp, model="bd");#
		fit.bd$model <- "bd";#
	}#
	if (model != "mixed" && model != "bd" && model != "yule") # i.e. the constrained models#
	{#
		fit <- medusaMLFitPartition(z=z, sp=sp, model=model, fixPar=fixPar);#
		fit$model <- model;#
		return(fit);#
	}#
	#
## Figure out which model fits best#
	if (is.null(fit.bd))#
	{#
		fit <- fit.yule;#
	} else if (is.null(fit.yule)) {#
		fit <- fit.bd;#
	} else {#
## Considering both models#
		fit <- getBestPartialModel(fit1=fit.yule, fit2=fit.bd, z=z, criterion=criterion);#
		#
		#
		# fit.bd.val <- calculateModelFit(fit=fit.bd, z=z); ## NOT valid here, as sample size is NOT z#
		# fit.yule.val <- calculateModelFit(fit=fit.yule, z=z);#
		#
## The length condition below deals with single edges, where AICc correction becomes undefined (n-k-1)#
  # Undefined#
	}#
	return(fit);#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
medusaMLUpdate <- function (node, z, desc, fit, prefit, num.tips, root.node, model, fixPar, criterion, shiftCut, preserveModelFlavour)#
{#
## various combinations possible#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cool <- TRUE;#
	#
	# new.part.1 <- NULL;#
	# new.part.2 <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" | shiftCut == "both" | node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		obj.stem <- medusaSplitStem(node=node, z=z, desc=desc$stem);#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
		if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
		{#
			fit$lnLik <- -Inf;#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			return(fit);#
		}#
		#
## Everything is cool; proceed.#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
## first, consider diminshed clade. may result in a clade that has been cached previously#
		dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		#
## check if diminished clade conforms to a cached clade#
		x <- which(dimClade[,"anc"] == min(dimClade[,"anc"]));#
		if (length(x) == 1) # a cut-at-stem scenario#
		{#
			y <- as.numeric(dimClade[x, "dec"]);#
			if (length(unique(dimClade[(dimClade[,"dec"] < root.node),"dec"])) == prefit$num.tips[[y]])#
			{#
				if (y < root.node)#
				{#
					fit1.stem <- prefit$tips[[y]];#
				} else {#
					fit1.stem <- prefit$virgin.nodes$stem[[y - root.node]];#
				}#
#				cat("Worked! Clade is of size:", length(dimClade[,1]), "\n")#
			}#
		}#
				#
		if(is.null(fit1.stem))#
		{#
			if (model == "mixed")#
			{#
				if (preserveModelFlavour)  ## In mixed models, may want to conserve flavour of previously fit model#
				{#
					if (sum(!is.na(sp)) < 2) # yule#
					{#
						fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model="yule");#
					} else {#
						fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model="bd");#
					}#
				} else {#
## consider both model flavours#
					fit1.stem <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
				}#
			} else {#
				fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model=model, fixPar=fixPar);#
				fit1.stem$model <- model;#
			}#
		}#
		#
		#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == prefit$num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else {#
## novel shift#
			newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
			fit2.stem <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	#
	if ((shiftCut == "node" || shiftCut == "both") && (node > root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		obj.node <- medusaSplitNode(node=node, z=z, desc=desc$node);#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		#
## Need to check if cut is valid. May be inadmissable because of pattern of previous breaks (especially with shiftCut=both)#
		if (is.na(aff[1]) || is.na(aff[2]))#
		{#
			cool <- FALSE;#
		}		#
## Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (sum(z.node[,"partition"] == aff[1]) == 0 || sum(z.node[,"partition"] == aff[2]) == 0 || !cool)#
		{#
			fit$lnLik <- -Inf;#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			return(fit);#
		}#
		#
## Everything is cool; proceed.#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
## first, consider diminshed clade. may result in a clade that has been cached#
		dimClade <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		#
		if (model == "mixed")#
		{#
			if (preserveModelFlavour)  ## In mixed models, may want to conserve flavour of previously fit model#
			{#
				if (sum(!is.na(sp)) < 2) # yule#
				{#
					fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model="yule"); # should this change? probably.#
				} else {#
					fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model="bd");#
				}#
			} else {#
## consider both model flavours#
				fit1.node <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
			}#
		} else {#
			fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model=model, fixPar=fixPar);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == prefit$num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		} else {#
## novel shift#
			newClade <- z.node[z.node[,"partition"] == aff[2],,drop=FALSE];#
			fit2.node <- getOptimalModelFlavour (z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par, model=model);#
		stem.fit <- calculateModelFit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par, model=model);#
		node.fit <- calculateModelFit(fit=node.val, z=z);#
		#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
## sp = initializing values for r & epsilon. fixPar = fixed value for constrained model.#
## Default values should never be used (except for first model), as the values from the previous model are passed in.#
## The 'suppressWarnings' catches harmless warnings for when extreme parameter values are tried, #
## generating -Inf log-likelihoods. Depends on sclae of the tree.#
medusaMLFitPartition <- function (z, sp=c(0.05, 0.5), model, fixPar=NULL)#
{#
#	new.part <- z[z[,"partition"] == partition.id,,drop=FALSE]; # now subsetted earlier#
	new.part <- z;#
	#
# Construct likelihood function:#
	lik <- makePartitionLikelihood(partition=new.part, model=model, fixPar=fixPar);#
	foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
	#
	if (model == "bd")#
	{#
		fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=5000));#
		#
		if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
		#
		return(list(par=exp(fit$par), lnLik=-fit$value));#
	}#
		#
## grab values to get an intelligent upper bound on b or r#
		node.richness  <- sum(new.part[,"n.t"], na.rm=TRUE);#
		depth <- max(new.part[,"t.0"]);#
		#
# use different intervals based on model flavour#
	#
	if (model == "yule") {#
		#
		maxVal <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {maxVal <- 1e-5;}#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-25, log(maxVal))));#
		par <- c(exp(fit$minimum), NA);#
		#
		while (par[1]/maxVal > 0.95) # crash against boundary; doesn't seem to get used...#
		{#
			maxVal <- par[1] * 3;#
			cat("Hit boundary\n")#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(par[1]/2), log(maxVal))));#
			par <- c(exp(fit$minimum), NA);#
		}#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedD") {#
## this is the messiest model flavour; reasonable range depends on magnitude of fixD#
		#
		x <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {x <- 0.01;} # MLE for single tip will be r ~ 0#
		maxVal <- fixPar + x;#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(log(fixPar), log(maxVal))));#
		b <- exp(fit$minimum);#
		par <- c((b - fixPar), (fixPar / b));#
		#
		while (fit$objective == Inf)#
		{#
			cat("maxVal =", maxVal, "; b =", b, "; r =", b - fixPar, "; epsilon =", fixPar/b, "\n")#
			#
			x <- x * 0.75;#
			maxVal <- fixPar + x;#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(fixPar), log(maxVal))));#
			b <- exp(fit$minimum);#
			par <- c((b - fixPar), (fixPar / b));#
		}#
		#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedEpsilon") {#
		#
		maxVal <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {maxVal <- 1;}#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-25, log(maxVal))));#
		par <- c(exp(fit$minimum), sp[2]);#
		#
		while (par[1]/maxVal > 0.9) # crash against boundary#
		{#
			maxVal <- par[1] * 3;#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(par[1]/2), log(maxVal))));#
			par <- c(exp(fit$minimum), sp[2]);#
		}#
		#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedB") {#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-50, log(fixPar))));#
		d <- exp(fit$minimum);#
		par <- c((fixPar - d), (d / fixPar));#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedR") {#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-50, 0)));#
		par <- c(sp[1], exp(fit$minimum));#
		return(list(par=par, lnLik=-fit$objective));#
	}#
}#
#
#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
#
## makePartitionLikelihood: generate a likelihood function for a single partition.#
makePartitionLikelihood <- function (partition, model, fixPar)#
{#
	i.int <- is.na(partition[,"n.t"])#
	i.pend <- !(i.int)#
	n.int <- sum(i.int);#
	#
	simple <- FALSE;#
	if (all(partition[,"n.t"] == 1, na.rm = TRUE)) {simple <- TRUE;}#
	#
	if (simple) {#
		if (model == "yule") {#
			sum.t <- sum(partition[,"t.len"]);#
			f <- function(pars) {#
				if (pars <= 0) return(-Inf);#
				r <- pars[1];#
				return(n.int * log(r) - r * sum.t);#
			}#
			return(f)#
		} #
		#
		sum.int.t.len <- sum(partition[i.int,"t.len"]);#
		int.t.0 <- partition[i.int,"t.0"];#
		pend.t.len <- partition[i.pend,"t.len"];#
		#
		if (model == "bd") {#
			f <- function(pars) {#
				r <- pars[1];#
				epsilon <- pars[2];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedD") {#
			fixD <- fixPar;#
			f <- function(pars) {#
				b <- pars[1];#
				r <- b - fixD;#
				epsilon <- fixD/b;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedEpsilon") {#
			epsilon <- fixPar;#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedR") {#
			r <- fixPar;#
			f <- function(pars) {#
				epsilon <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedB") {#
			fixB <- fixPar;#
			f <- function(pars) {#
				d <- pars[1];#
				r <- fixB - d;#
				epsilon <- d/fixB;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		}#
	} else {#
		sum.int.t.len <- sum(partition[i.int,"t.len"]);#
		pend.t.len <- partition[i.pend,"t.len"];#
		pend.n.t.minus.1 <- partition[i.pend,"n.t"] - 1;#
		#
		if (model == "yule") {#
			sum.pend.t.len <- sum(pend.t.len);#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0) return(-Inf);#
				return(n.int * log(r) - r * sum.int.t.len + sum(-pend.t.len * r + pend.n.t.minus.1*log(1 - exp(-pend.t.len * r))));#
			}#
			return(f)#
		}#
		#
		int.t.0 <- partition[i.int,"t.0"];#
		#
		if (model == "bd") {#
			f <- function(pars) {#
				r <- pars[1];#
				epsilon <- pars[2];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedD") {#
			fixD <- fixPar;#
			f <- function(pars) {#
				b <- pars[1];#
				r <- b - fixD;#
				epsilon <- fixD/b;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedEpsilon") {#
			epsilon <- fixPar;#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedR") {#
			r <- fixPar;#
			f <- function(pars) {#
				epsilon <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedB") {#
			fixB <- fixPar;#
			f <- function(pars) {#
				d <- pars[1];#
				r <- fixB - d;#
				epsilon <- d/fixB;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		}#
	}#
}#
#
#
#
## 'fit' contains '$par' and '$lnlik' and '$model'; check last value for presence of fixed parameters#
calculateModelFit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	model = fit$model[1];#
	#
	if (model == "fixedEpsilon" || model == "fixedR" || model == "fixedB" || model == "fixedD")#
	{#
		k <- 2 * num.models - 1;#
	} else {#
		k <- sum(!is.na(fit$par)) + num.models - 1; # number of estimated parameters + number of breaks#
	}#
	#
	lnLik <- fit$lnLik;#
	#
#	aic <- -2 * lnLik + 2*k;#
	aic <- getAIC(lnLik, k);#
#	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	aicc <- getAICc(lnLik, k, n);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
getAIC <- function (lnLik, k)#
{#
	return(-2 * lnLik + 2*k);#
}#
#
getAICc <- function (lnLik, k, n)#
{#
	return(getAIC(lnLik,k) + 2*k*(k+1)/(n-k-1));#
}#
#
## Used for comparing models fit to the same partition#
getBestPartialModel <- function (fit1, fit2, z, criterion)#
{#
	n <- (length(z[,1]) + 1); # the number of nodes involved#
## Add '1' to parameters to account for break#
	k1 <- 1 + sum(!is.na(fit1$par));#
	k2 <- 1 + sum(!is.na(fit2$par));#
	#
	if (n - k1 <= 1 || n - k2 <= 1) # deals with single edges, where AICc correction becomes undefined. use AIC.#
	{#
		if (getAIC(fit1$lnLik,k1) < getAIC(fit2$lnLik,k2))#
		{#
			return(fit1);#
		} else {#
			return(fit2);#
		}#
	} else {#
		if (criterion == "aicc")#
		{#
			if (getAICc(fit1$lnLik,k1,n) < getAICc(fit2$lnLik,k2,n))#
			{#
				return(fit1);#
			} else {#
				return(fit2);#
			}#
		} else {#
			if (getAIC(fit1$lnLik,k1) < getAIC(fit2$lnLik,k2))#
			{#
				return(fit1);#
			} else {#
				return(fit2);#
			}#
		}#
	}#
}
}
## Only used for base model#
medusaMLFitBase <- function (z, sp, model, fixPar, criterion)#
{#
	fit <- getOptimalModelFlavour(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	steps <- c("add", as.numeric(min(z[,"anc"])));#
	#
	return(list(par=matrix(fit$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=fit$lnLik, lnLik=fit$lnLik,#
		split.at=min(z[,"anc"]), aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3],#
		cut.at="node", model=fit$model, z=z, step=matrix(steps, nrow=1, dimnames=list(NULL,c("step", "node")))));#
}#
#
#
## Split the edge matrix 'z' by adding a partition at node 'node'.#
## The list 'desc' is a list of descendants (see makeCacheMedusa).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
medusaSplitStem <- function (node, z, desc, extract=FALSE)#
{#
	part <- z[,"partition"];#
	base <- min(part[z[,"anc"] == node | z[,"dec"] == node]);#
	tag <- max(part) + 1;#
	i <- desc[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	if (extract) {z <- z[idx,,drop=FALSE];}#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
medusaSplitNode <- function (node, z, desc, extract=FALSE)#
{#
	part <- z[,"partition"];#
	base <- min(part[z[,"anc"] == node]);#
	tag <- max(part) + 1;#
	i <- desc[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	if (extract) {z <- z[idx,,drop=FALSE];}#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
## The general function for when the flavour of shiftCut is unknown#
medusaSplit <- function (node, z, desc, shiftCut)#
{#
	descendants <- desc$stem; # will be correct half the time#
	if (shiftCut == "node") {descendants <- desc$node;}#
	#
	part <- z[,"partition"];#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted, especially for large trees.#
prefitTips <- function (pend.nodes, z, sp, model, fixPar, criterion, mc, numCores)#
{#
	if (all(z[z[,"dec"] %in% pend.nodes,"n.t"] == 1) && (model == "yule" || model == "mixed"))#
	{#
		fit <- list(list(par=c(0, NA), lnLik=0, model="yule"));#
		fit <- rep(fit, length(pend.nodes));#
		return(fit);#
	}#
	#
	if (model == "mixed") # yule will always have a better AIC for tip, regardless of richness#
	{#
		if (mc) {#
			tips <- mclapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model="yule", fixPar=fixPar, criterion=criterion, mc.cores=numCores);#
		} else {#
			tips <- lapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model="yule", fixPar=fixPar, criterion=criterion);#
		}#
	} else {#
		if (mc) {#
			tips <- mclapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model=model, fixPar=fixPar, criterion=criterion, mc.cores=numCores);#
		} else {#
			tips <- lapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	return(tips);#
}#
#
medusaMLPrefitTip <- function (node, z, sp, model, fixPar, criterion)#
{#
	z.tip <- z[z[,"dec"] == node,,drop=FALSE];#
	#
	if (all(z.tip[,"n.t"] == 1) && (model == "yule" || model == "mixed"))#
	{#
		return(list(par=c(0, NA), lnLik=0, model="yule"));#
	}#
	#
	fit <- getOptimalModelFlavour(z=z.tip, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
medusaMLPrefitNode <- function (node, z, desc, sp, model, fixPar, criterion)#
{#
	z.node <- medusaSplitNode(node=node, z=z, desc=desc, extract=TRUE)$z;#
	fit <- getOptimalModelFlavour(z=z.node, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
medusaMLPrefitStem <- function (node, z, desc, sp, model, fixPar, criterion)#
{#
	z.stem <- medusaSplitStem(node=node, z=z, desc=desc, extract=TRUE)$z;#
#	z.stem <- z.stem[z.stem[,"partition"] == 2,,drop=FALSE];#
	fit <- getOptimalModelFlavour(z=z.stem, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
#
## When model == mixed, fit both and find optimal flavour#
getOptimalModelFlavour <- function (z, sp, model, fixPar, criterion)#
{#
	fit.bd <- NULL;#
	fit.yule <- NULL;#
	fit <- NULL;#
	#
	if (model == "yule" | model == "mixed")#
	{#
		fit.yule <- medusaMLFitPartition(z=z, sp=sp, model="yule");#
		fit.yule$model <- "yule";#
	}#
	if (model == "bd" | model == "mixed")#
	{#
		if (is.na(sp[2])) {sp[2] <- 0.5;}#
		fit.bd <- medusaMLFitPartition(z=z, sp=sp, model="bd");#
		fit.bd$model <- "bd";#
	}#
	if (model != "mixed" && model != "bd" && model != "yule") # i.e. the constrained models#
	{#
		fit <- medusaMLFitPartition(z=z, sp=sp, model=model, fixPar=fixPar);#
		fit$model <- model;#
		return(fit);#
	}#
	#
## Figure out which model fits best#
	if (is.null(fit.bd))#
	{#
		fit <- fit.yule;#
	} else if (is.null(fit.yule)) {#
		fit <- fit.bd;#
	} else {#
## Considering both models#
		fit <- getBestPartialModel(fit1=fit.yule, fit2=fit.bd, z=z, criterion=criterion);#
		#
		#
		# fit.bd.val <- calculateModelFit(fit=fit.bd, z=z); ## NOT valid here, as sample size is NOT z#
		# fit.yule.val <- calculateModelFit(fit=fit.yule, z=z);#
		#
## The length condition below deals with single edges, where AICc correction becomes undefined (n-k-1)#
  # Undefined#
	}#
	return(fit);#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
medusaMLUpdate <- function (node, z, desc, fit, prefit, num.tips, root.node, model, fixPar, criterion, shiftCut, preserveModelFlavour)#
{#
## various combinations possible#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cool <- TRUE;#
	#
	# new.part.1 <- NULL;#
	# new.part.2 <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" | shiftCut == "both" | node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		obj.stem <- medusaSplitStem(node=node, z=z, desc=desc$stem);#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
		if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
		{#
			fit$lnLik <- -Inf;#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			return(fit);#
		}#
		#
## Everything is cool; proceed.#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
## first, consider diminshed clade. may result in a clade that has been cached previously#
		dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		#
## check if diminished clade conforms to a cached clade#
		x <- which(dimClade[,"anc"] == min(dimClade[,"anc"]));#
		if (length(x) == 1) # a cut-at-stem scenario#
		{#
			y <- as.numeric(dimClade[x, "dec"]);#
			if (length(unique(dimClade[(dimClade[,"dec"] < root.node),"dec"])) == prefit$num.tips[[y]])#
			{#
				if (y < root.node)#
				{#
					fit1.stem <- prefit$tips[[y]];#
				} else {#
					fit1.stem <- prefit$virgin.nodes$stem[[y - root.node]];#
				}#
#				cat("Worked! Clade is of size:", length(dimClade[,1]), "\n")#
			}#
		}#
				#
		if(is.null(fit1.stem))#
		{#
			if (model == "mixed")#
			{#
				if (preserveModelFlavour)  ## In mixed models, may want to conserve flavour of previously fit model#
				{#
					if (sum(!is.na(sp)) < 2) # yule#
					{#
						fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model="yule");#
					} else {#
						fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model="bd");#
					}#
				} else {#
## consider both model flavours#
					fit1.stem <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
				}#
			} else {#
				fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model=model, fixPar=fixPar);#
				fit1.stem$model <- model;#
			}#
		}#
		#
		#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == prefit$num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else {#
## novel shift#
			newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
			fit2.stem <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	#
	if ((shiftCut == "node" || shiftCut == "both") && (node > root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		obj.node <- medusaSplitNode(node=node, z=z, desc=desc$node);#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		#
## Need to check if cut is valid. May be inadmissable because of pattern of previous breaks (especially with shiftCut=both)#
		if (is.na(aff[1]) || is.na(aff[2]))#
		{#
			cool <- FALSE;#
		}		#
## Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (sum(z.node[,"partition"] == aff[1]) == 0 || sum(z.node[,"partition"] == aff[2]) == 0 || !cool)#
		{#
			fit$lnLik <- -Inf;#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			return(fit);#
		}#
		#
## Everything is cool; proceed.#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
## first, consider diminshed clade. may result in a clade that has been cached#
		dimClade <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		#
		if (model == "mixed")#
		{#
			if (preserveModelFlavour)  ## In mixed models, may want to conserve flavour of previously fit model#
			{#
				if (sum(!is.na(sp)) < 2) # yule#
				{#
					fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model="yule"); # should this change? probably.#
				} else {#
					fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model="bd");#
				}#
			} else {#
## consider both model flavours#
				fit1.node <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
			}#
		} else {#
			fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model=model, fixPar=fixPar);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == prefit$num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		} else {#
## novel shift#
			newClade <- z.node[z.node[,"partition"] == aff[2],,drop=FALSE];#
			fit2.node <- getOptimalModelFlavour (z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par, model=model);#
		stem.fit <- calculateModelFit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par, model=model);#
		node.fit <- calculateModelFit(fit=node.val, z=z);#
		#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
## sp = initializing values for r & epsilon. fixPar = fixed value for constrained model.#
## Default values should never be used (except for first model), as the values from the previous model are passed in.#
## The 'suppressWarnings' catches harmless warnings for when extreme parameter values are tried, #
## generating -Inf log-likelihoods. Depends on sclae of the tree.#
medusaMLFitPartition <- function (z, sp=c(0.05, 0.5), model, fixPar=NULL)#
{#
#	new.part <- z[z[,"partition"] == partition.id,,drop=FALSE]; # now subsetted earlier#
	new.part <- z;#
	#
# Construct likelihood function:#
	lik <- makePartitionLikelihood(partition=new.part, model=model, fixPar=fixPar);#
	foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
	#
	if (model == "bd")#
	{#
		fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=5000));#
		#
		if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
		#
		return(list(par=exp(fit$par), lnLik=-fit$value));#
	}#
		#
## grab values to get an intelligent upper bound on b or r#
		node.richness  <- sum(new.part[,"n.t"], na.rm=TRUE);#
		depth <- max(new.part[,"t.0"]);#
		#
# use different intervals based on model flavour#
	#
	if (model == "yule") {#
		#
		maxVal <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {maxVal <- 1e-5;}#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-25, log(maxVal))));#
		par <- c(exp(fit$minimum), NA);#
		#
		while (par[1]/maxVal > 0.95) # crash against boundary; doesn't seem to get used...#
		{#
			maxVal <- par[1] * 3;#
			cat("Hit boundary\n")#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(par[1]/2), log(maxVal))));#
			par <- c(exp(fit$minimum), NA);#
		}#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedD") {#
## this is the messiest model flavour; reasonable range depends on magnitude of fixD#
		#
		x <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {x <- 0.01;} # MLE for single tip will be r ~ 0#
		maxVal <- fixPar + x;#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(log(fixPar), log(maxVal))));#
		b <- exp(fit$minimum);#
		par <- c((b - fixPar), (fixPar / b));#
		#
		while (fit$objective == Inf)#
		{#
			cat("maxVal =", maxVal, "; b =", b, "; r =", b - fixPar, "; epsilon =", fixPar/b, "\n")#
			#
			x <- x * 0.75;#
			maxVal <- fixPar + x;#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(fixPar), log(maxVal))));#
			b <- exp(fit$minimum);#
			par <- c((b - fixPar), (fixPar / b));#
		}#
		#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedEpsilon") {#
		#
		maxVal <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {maxVal <- 1;}#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-25, log(maxVal))));#
		par <- c(exp(fit$minimum), sp[2]);#
		#
		while (par[1]/maxVal > 0.9) # crash against boundary#
		{#
			maxVal <- par[1] * 3;#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(par[1]/2), log(maxVal))));#
			par <- c(exp(fit$minimum), sp[2]);#
		}#
		#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedB") {#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-50, log(fixPar))));#
		d <- exp(fit$minimum);#
		par <- c((fixPar - d), (d / fixPar));#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedR") {#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-50, 0)));#
		par <- c(sp[1], exp(fit$minimum));#
		return(list(par=par, lnLik=-fit$objective));#
	}#
}#
#
#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
#
## makePartitionLikelihood: generate a likelihood function for a single partition.#
makePartitionLikelihood <- function (partition, model, fixPar)#
{#
	i.int <- is.na(partition[,"n.t"])#
	i.pend <- !(i.int)#
	n.int <- sum(i.int);#
	#
	simple <- FALSE;#
	if (all(partition[,"n.t"] == 1, na.rm = TRUE)) {simple <- TRUE;}#
	#
	if (simple) {#
		if (model == "yule") {#
			sum.t <- sum(partition[,"t.len"]);#
			f <- function(pars) {#
				if (pars <= 0) return(-Inf);#
				r <- pars[1];#
				return(n.int * log(r) - r * sum.t);#
			}#
			return(f)#
		} #
		#
		sum.int.t.len <- sum(partition[i.int,"t.len"]);#
		int.t.0 <- partition[i.int,"t.0"];#
		pend.t.len <- partition[i.pend,"t.len"];#
		#
		if (model == "bd") {#
			f <- function(pars) {#
				r <- pars[1];#
				epsilon <- pars[2];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedD") {#
			fixD <- fixPar;#
			f <- function(pars) {#
				b <- pars[1];#
				r <- b - fixD;#
				epsilon <- fixD/b;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedEpsilon") {#
			epsilon <- fixPar;#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedR") {#
			r <- fixPar;#
			f <- function(pars) {#
				epsilon <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedB") {#
			fixB <- fixPar;#
			f <- function(pars) {#
				d <- pars[1];#
				r <- fixB - d;#
				epsilon <- d/fixB;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		}#
	} else {#
		sum.int.t.len <- sum(partition[i.int,"t.len"]);#
		pend.t.len <- partition[i.pend,"t.len"];#
		pend.n.t.minus.1 <- partition[i.pend,"n.t"] - 1;#
		#
		if (model == "yule") {#
			sum.pend.t.len <- sum(pend.t.len);#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0) return(-Inf);#
				return(n.int * log(r) - r * sum.int.t.len + sum(-pend.t.len * r + pend.n.t.minus.1*log(1 - exp(-pend.t.len * r))));#
			}#
			return(f)#
		}#
		#
		int.t.0 <- partition[i.int,"t.0"];#
		#
		if (model == "bd") {#
			f <- function(pars) {#
				r <- pars[1];#
				epsilon <- pars[2];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedD") {#
			fixD <- fixPar;#
			f <- function(pars) {#
				b <- pars[1];#
				r <- b - fixD;#
				epsilon <- fixD/b;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedEpsilon") {#
			epsilon <- fixPar;#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedR") {#
			r <- fixPar;#
			f <- function(pars) {#
				epsilon <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedB") {#
			fixB <- fixPar;#
			f <- function(pars) {#
				d <- pars[1];#
				r <- fixB - d;#
				epsilon <- d/fixB;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		}#
	}#
}#
#
#
#
## 'fit' contains '$par' and '$lnlik' and '$model'; check last value for presence of fixed parameters#
calculateModelFit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	model = fit$model[1];#
	#
	if (model == "fixedEpsilon" || model == "fixedR" || model == "fixedB" || model == "fixedD")#
	{#
		k <- 2 * num.models - 1;#
	} else {#
		k <- sum(!is.na(fit$par)) + num.models - 1; # number of estimated parameters + number of breaks#
	}#
	#
	lnLik <- fit$lnLik;#
	#
#	aic <- -2 * lnLik + 2*k;#
	aic <- getAIC(lnLik, k);#
#	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	aicc <- getAICc(lnLik, k, n);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
getAIC <- function (lnLik, k)#
{#
	return(-2 * lnLik + 2*k);#
}#
#
getAICc <- function (lnLik, k, n)#
{#
	return(getAIC(lnLik,k) + 2*k*(k+1)/(n-k-1));#
}#
#
## Used for comparing models fit to the same partition#
getBestPartialModel <- function (fit1, fit2, z, criterion)#
{#
	n <- (length(z[,1]) + 1); # the number of nodes involved#
## Add '1' to parameters to account for break#
	k1 <- 1 + sum(!is.na(fit1$par));#
	k2 <- 1 + sum(!is.na(fit2$par));#
	#
	if (n - k1 <= 1 || n - k2 <= 1) # deals with single edges, where AICc correction becomes undefined. use AIC.#
	{#
		if (getAIC(fit1$lnLik,k1) < getAIC(fit2$lnLik,k2))#
		{#
			return(fit1);#
		} else {#
			return(fit2);#
		}#
	} else {#
		if (criterion == "aicc")#
		{#
			if (getAICc(fit1$lnLik,k1,n) < getAICc(fit2$lnLik,k2,n))#
			{#
				return(fit1);#
			} else {#
				return(fit2);#
			}#
		} else {#
			if (getAIC(fit1$lnLik,k1) < getAIC(fit2$lnLik,k2))#
			{#
				return(fit1);#
			} else {#
				return(fit2);#
			}#
		}#
	}#
}
fitSisters(x, node=327) -> foo
fitSisters(x, node=422) -> foo
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}

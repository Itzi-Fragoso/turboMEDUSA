summarizeTurboMEDUSA
summarizeTurboMEDUSA(res.mam.nlminb, time=F)
summarizeTurboMEDUSA(res.mam.nlminb, time=F, cex=0.3)
foo <- extract.clade(pruned.phy, node=458)
foo <- extract.clade(phy.pruned, node=458)
plot(foo)
plotNN(foo)
plotNN(foo, time=T)
runTurboMEDUSA(foo)
## Only used for base model#
medusa.ml.initial <- function (z, initialR, initialE, model)#
{#
	rootnode <- min(z[,"anc"]);#
	obj <- medusa.ml.fit.partition(partition=1, z=z, sp=c(initialR, initialE), model=model);#
	#
	model.fit <- calculate.model.fit(fit=obj, z=z);#
	#
	return(list(par=matrix(obj$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=obj$lnLik, #
	   lnLik=obj$lnLik, split.at=rootnode, aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3], cut.at="node"));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted.#
## shiftCut can only be "stem" or "node" (not "both"), as both are evaluated separately#
medusa.ml.prefit <- function (node, z, desc, initialR, initialE, model, shiftCut, criterion)#
{#
	fitted.bd <- NULL;#
	fitted.yule <- NULL;#
#	fit <- NULL;#
	#
## if model is mixed, grab the optimally fitted one, drop the other; it is cutAtStem that matters, as it is the sum of 2 break likelihoods#
  ## optimal alone may be different than optimal in tandem#
	if (shiftCut == "stem")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.stem <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.stem, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "stem";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.stem <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.stem, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "stem";#
		}#
	} else if (shiftCut == "node")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.node <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.node, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "node";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.node <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.node, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "node";#
		}#
	}#
## Check which flavour of model fits best#
	if (is.null(fitted.bd) & !is.null(fitted.yule))#
	{#
		return(fitted.yule);#
	} else if (is.null(fitted.yule) & !is.null(fitted.bd)) {#
		return(fitted.bd);#
	} else {#
## Dealing with a 'mixed' model here; need to consider number of parameters.#
		bd.model.fit <- calculate.model.fit(fit=fitted.bd, z=z);#
		yule.model.fit <- calculate.model.fit(fit=fitted.yule, z=z);#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		if (is.nan(yule.model.fit[[element]]))#
		{#
			return(fitted.bd);#
		} else if (bd.model.fit[[element]] < yule.model.fit[[element]])#
		{#
			return(fitted.bd);#
		} else {#
			return(fitted.yule);#
		}#
	}#
}#
#
#
#
#
#
#
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
# Construct likelihood function:#
	lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);	#
	foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
	#
	if (model == "bd")#
	{#
		fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
		#
		if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
		#
		return(list(par=exp(fit$par), lnLik=-fit$value));#
	} else {#
		# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
		# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
		# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
		#
		# fit <- nlm(log(sp[1]), f=foo)#
		# par <- c(exp(fit$estimate), NA);#
		# return(list(par=par, lnLik=-fit$minimum));#
		#
		fit <- nlminb(log(0.001), objective=foo, upper=log(50))#
		par <- c(exp(fit$par), NA);#
		return(list(par=par, lnLik=-fit$objective));#
#
		# fit <- optimize(f=foo, interval=c(-25, 1));#
		# par <- c(exp(fit$minimum), NA);#
		# return(list(par=par, lnLik=-fit$objective));#
	}#
}#
#
#
#
#
#
#
## Split the edge matrix 'z' by adding a partition rooted at node 'node'.#
##   Note: in original MEDUSA parlance, this is cutAtStem=T.#
## The list 'desc' is a list of descendants (see make.cache.medusa, above).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
## This is where 'shiftCut' matters#
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	part <- z[,"partition"];#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, or mixed models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
## fit1 model is already logged; only need to record fit2 model, and only non-prefitted nodes#
medusa.ml.update <- function (node, z, desc, fit, prefit, num.tips, root.node, model, criterion, shiftCut)#
{#
## various combinations possible#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par;#
	cut.at <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" || shiftCut == "both")#
	{#
## First, diminshed clade#
		obj.stem <- medusa.split(node=node, z=z, desc=desc, shiftCut="stem");#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="yule");#
			} else {#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="bd");#
			}#
		} else {#
			fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model=model);#
			fit1.stem$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else { # novel shift#
			fit2.stem.bd <- NULL;#
			fit2.stem.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.stem.yule <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="yule");#
				fit2.stem.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.stem.bd <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="bd");#
				fit2.stem.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.stem.bd))#
			{#
				fit2.stem <- fit2.stem.yule;#
			} else if (is.null(fit2.stem.yule)) {#
				fit2.stem <- fit2.stem.bd;#
			} else {#
## Considering both places for a shift#
				fit2.stem.bd.val <- calculate.model.fit(fit=fit2.stem.bd, z=z);#
				fit2.stem.yule.val <- calculate.model.fit(fit=fit2.stem.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.stem.bd.val[[element]] < fit2.stem.yule.val[[element]])#
				{#
					fit2.stem <- fit2.stem.bd;#
				} else {#
					fit2.stem <- fit2.stem.yule;#
				}#
			}#
		}#
	}#
	if (shiftCut == "node" || shiftCut == "both")#
	{#
## First, diminshed clade#
		obj.node <- medusa.split(node=node, z=z, desc=desc, shiftCut="node");#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="yule");#
				fit1.node$model <- "yule";#
			} else {#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="bd");#
				fit1.node$model <- "bd";#
			}#
		} else {#
			fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model=model);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.node <- prefit$tips[[node]];#
		} else if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		}#
		else { # novel shift#
			fit2.node.bd <- NULL;#
			fit2.node.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.node.yule <- medusa.ml.fit.partition(aff[2], z.node, sp, model="yule");#
				fit2.node.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.node.bd <- medusa.ml.fit.partition(aff[2], z.node, sp, model="bd");#
				fit2.node.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.node.bd))#
			{#
				fit2.node <- fit2.node.yule;#
			} else if (is.null(fit2.node.yule)) {#
				fit2.node <- fit2.node.bd;#
			} else {#
## Considering both places for a shift#
				fit2.node.bd.val <- calculate.model.fit(fit=fit2.node.bd, z=z);#
				fit2.node.yule.val <- calculate.model.fit(fit=fit2.node.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.node.bd.val[[element]] < fit2.node.yule.val[[element]])#
				{#
					fit2.node <- fit2.node.bd;#
				} else {#
					fit2.node <- fit2.node.yule;#
				}#
			}	#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par);#
		stem.fit <- calculate.model.fit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par);#
		node.fit <- calculate.model.fit(fit=node.val, z=z);#
		#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
#			cat("Stem wins!\n");#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
#			cat("Node wins!\n");#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculate.model.fit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
#
## make.lik.medusa.part: generate a likelihood function for a single partition.#
make.lik.medusa.part <- function (partition, model)#
{#
# Handle internal and pendant edges separately#
	is.int <- is.na(partition[,"n.t"]);#
	is.pend <- !is.int;#
	#
	n.int <- sum(is.int);#
	n.pend <- sum(is.pend);#
	#
	if (n.int + n.pend != length(partition[,1])) stop("You messed up, yo.");#
	#
## Internal and pendant calculations differ; split'em up#
	int  <- partition[is.int,,drop=FALSE];#
	pend <- partition[is.pend,,drop=FALSE];#
	#
	sum.int.t.len <- sum(int[,"t.len"]);  # Simply sum all internal edges#
	int.t.0 <- int[,"t.0"];#
	#
# 'n.0' = Foote's 'a', initial diversity; 'n.t' = Foote's 'n', final diversity#
	pend.n.0 <- pend[,"n.0"]; # Foote's 'a': initial diversity#
	pend.n.t <- pend[,"n.t"]; # Foote's 'n': final diversity#
	pend.t.len <- pend[,"t.len"];#
	#
# User may pass in epsilon; don't change it, just estimate r#
	f <- function(pars)#
	{#
		if (model == "bd")#
		{#
			r <- pars[1];#
			epsilon <- pars[2];#
			#
			if (r <= 0 || epsilon <= 0 || epsilon >= 1) {return(-Inf);}#
		} else {#
			#
			r <- pars[1];#
			epsilon <- 0;#
			#
			if (r <= 0 || is.nan(r)) {return(-Inf);}#
		}#
		#
		l.int <- numeric();#
		l.pend <- numeric();#
		#
		if (n.int == 0) {l.int <- 0;} else {#
## Likelihood of internal edges from Rabosky et al. (2007) equation (2.3):#
			l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
		}#
		#
		if (n.pend == 0) {l.pend <- 0} else {#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
			#
			ert <- exp(r * pend.t.len);#
			B <- (ert - 1) / (ert - epsilon); # Equivalently: B <- (bert - b) / (bert - d)#
			#
			l.pend <- sum(log(1 - B) + (pend.n.t - 1)*log(B));#
		}#
		return(l.int + l.pend);#
	}#
}#
#
#
## 'fit' contains '$par' and '$lnlik'#
calculate.model.fit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	#
# Updated for more general models: check how many parameter values != NA#
#	k <- 2 + (3 * (num.models - 1))#
	k <- sum(!is.na(fit$par)) + (num.models - 1); # number of estimated parameters + number of breaks#
	#
	lnLik <- fit$lnLik;#
	#
	aic <- (-2 * lnLik) + (2*k);#
	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
get.b.d <- function (r, epsilon)#
{#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
## Print out tree with ape-style node-numbering#
## Possibly of interest for users to identify numbers of node(s) off interest#
 ## If this is the case, make sure to pass in pruned tree#
plotNN <- function (phy, time=TRUE, margin=TRUE, label.offset=0.5, cex=0.5, ...) #
{#
	phy$node.label <- (length(phy$tip.label) + 1):max(phy$edge);#
	plot.phylo(phy, show.node.label=TRUE, no.margin=!margin, label.offset=label.offset, cex=cex, ...);#
	if (time && !margin) {cat("Cannot plot time axis without a margin.\n");}#
	else if (time && margin) {axisPhylo(cex.axis=0.75)};#
}
runTurboMEDUSA(foo)
runTurboMEDUSA(foo, shiftCut="stem")
runTurboMEDUSA(foo, shiftCut="node")
runTurboMEDUSA(foo, shiftCut="both")
traceback()
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
# Construct likelihood function:#
	lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);	#
	foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
	#
	if (model == "bd")#
	{#
		fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
		#
		if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
		#
		return(list(par=exp(fit$par), lnLik=-fit$value));#
	} else {#
		# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
		# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
		# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
		#
		# fit <- nlm(log(sp[1]), f=foo)#
		# par <- c(exp(fit$estimate), NA);#
		# return(list(par=par, lnLik=-fit$minimum));#
		#
		fit <- nlminb(log(sp[1]), objective=foo, upper=log(50))#
		par <- c(exp(fit$par), NA);#
		return(list(par=par, lnLik=-fit$objective));#
#
		# fit <- optimize(f=foo, interval=c(-25, 1));#
		# par <- c(exp(fit$minimum), NA);#
		# return(list(par=par, lnLik=-fit$objective));#
	}#
}
runTurboMEDUSA(foo, shiftCut="both")
get.height
get.age
z
age
z[z[,"partition"] == 2,]
phy
plotNN(phy)
log(4)
log(50)
? nlminb
? nlm
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
# Construct likelihood function:#
	lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);	#
	foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
	#
	if (model == "bd")#
	{#
		fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
		#
		if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
		#
		return(list(par=exp(fit$par), lnLik=-fit$value));#
	} else {#
		# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
		# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
		# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
		# best.guess2 <- log(node.richness) / #
		#
		# fit <- nlm(log(sp[1]), f=foo)#
		# par <- c(exp(fit$estimate), NA);#
		# return(list(par=par, lnLik=-fit$minimum));#
		#
		fit <- nlminb(log(sp[1]), objective=foo, upper=log(50), control=list(maxiter=1000))#
		par <- c(exp(fit$par), NA);#
		return(list(par=par, lnLik=-fit$objective));#
#
		# fit <- optimize(f=foo, interval=c(-25, 1));#
		# par <- c(exp(fit$minimum), NA);#
		# return(list(par=par, lnLik=-fit$objective));#
	}#
}
runTurboMEDUSA(foo, shiftCut="both") -> res
runTurboMEDUSA(tmp$phy, tmp$richness, model.limit=10) -> res.nlminb.maxiter; summarizeTurboMEDUSA(res.nlminb.maxiter, plotTree=F)
plotNN(tmp$phy)
length(tmp$phy$tip.label)
getage
getAge
?ape
ape(version)
version(ape)
citation(ape)
version("ape")
citation("ape")
library(help="ape")
version("r")
library(help="r")
load("/Users/josephwb/Projects/R_working/turboMEDUSA/turboMEDUSA/data/whales.RData")
require(geiger)
## Only used for base model#
medusa.ml.initial <- function (z, initialR, initialE, model)#
{#
	rootnode <- min(z[,"anc"]);#
	obj <- medusa.ml.fit.partition(partition=1, z=z, sp=c(initialR, initialE), model=model);#
	#
	model.fit <- calculate.model.fit(fit=obj, z=z);#
	#
	return(list(par=matrix(obj$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=obj$lnLik, #
	   lnLik=obj$lnLik, split.at=rootnode, aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3], cut.at="node"));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted.#
## shiftCut can only be "stem" or "node" (not "both"), as both are evaluated separately#
medusa.ml.prefit <- function (node, z, desc, initialR, initialE, model, shiftCut, criterion)#
{#
	fitted.bd <- NULL;#
	fitted.yule <- NULL;#
#	fit <- NULL;#
	#
## if model is mixed, grab the optimally fitted one, drop the other; it is cutAtStem that matters, as it is the sum of 2 break likelihoods#
  ## optimal alone may be different than optimal in tandem#
	if (shiftCut == "stem")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.stem <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.stem, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "stem";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.stem <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.stem, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "stem";#
		}#
	} else if (shiftCut == "node")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.node <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.node, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "node";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.node <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.node, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "node";#
		}#
	}#
## Check which flavour of model fits best#
	if (is.null(fitted.bd) & !is.null(fitted.yule))#
	{#
		return(fitted.yule);#
	} else if (is.null(fitted.yule) & !is.null(fitted.bd)) {#
		return(fitted.bd);#
	} else {#
## Dealing with a 'mixed' model here; need to consider number of parameters.#
		bd.model.fit <- calculate.model.fit(fit=fitted.bd, z=z);#
		yule.model.fit <- calculate.model.fit(fit=fitted.yule, z=z);#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		if (is.nan(yule.model.fit[[element]]))#
		{#
			return(fitted.bd);#
		} else if (bd.model.fit[[element]] < yule.model.fit[[element]])#
		{#
			return(fitted.bd);#
		} else {#
			return(fitted.yule);#
		}#
	}#
}#
#
#
#
#
#
#
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
	new.part <- z[z[,"partition"] == partition,,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
	if (length(new.part) == 0)#
	{#
		cat("\nSaved time, bitches!\n")#
		par <- c(NA, NA);#
		return(list(par=par, lnLik=-Inf));#
	} else {#
# Construct likelihood function:#
		lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);#
		foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
		#
		if (model == "bd")#
		{#
			fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
			#
			if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
			#
			return(list(par=exp(fit$par), lnLik=-fit$value));#
		} else {#
			# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
			# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
			# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
			# best.guess2 <- log(node.richness) / #
			#
			# fit <- nlm(log(sp[1]), f=foo)#
			# par <- c(exp(fit$estimate), NA);#
			# return(list(par=par, lnLik=-fit$minimum));#
			#
			fit <- nlminb(log(sp[1]), objective=foo, upper=log(50), control=list(maxiter=1000))#
			par <- c(exp(fit$par), NA);#
			return(list(par=par, lnLik=-fit$objective));#
	#
			# fit <- optimize(f=foo, interval=c(-25, 1));#
			# par <- c(exp(fit$minimum), NA);#
			# return(list(par=par, lnLik=-fit$objective));#
		}#
	}#
}#
#
#
#
#
#
#
## Split the edge matrix 'z' by adding a partition rooted at node 'node'.#
##   Note: in original MEDUSA parlance, this is cutAtStem=T.#
## The list 'desc' is a list of descendants (see make.cache.medusa, above).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
## This is where 'shiftCut' matters#
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, or mixed models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
## fit1 model is already logged; only need to record fit2 model, and only non-prefitted nodes#
medusa.ml.update <- function (node, z, desc, fit, prefit, num.tips, root.node, model, criterion, shiftCut)#
{#
## various combinations possible#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" || shiftCut == "both" || node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		obj.stem <- medusa.split(node=node, z=z, desc=desc, shiftCut="stem");#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'stem', bitches! Working on node #", node)#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="yule");#
			} else {#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="bd");#
			}#
		} else {#
			fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model=model);#
			fit1.stem$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else { # novel shift#
			fit2.stem.bd <- NULL;#
			fit2.stem.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.stem.yule <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="yule");#
				fit2.stem.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.stem.bd <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="bd");#
				fit2.stem.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.stem.bd))#
			{#
				fit2.stem <- fit2.stem.yule;#
			} else if (is.null(fit2.stem.yule)) {#
				fit2.stem <- fit2.stem.bd;#
			} else {#
## Considering both places for a shift#
				fit2.stem.bd.val <- calculate.model.fit(fit=fit2.stem.bd, z=z);#
				fit2.stem.yule.val <- calculate.model.fit(fit=fit2.stem.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.stem.bd.val[[element]] < fit2.stem.yule.val[[element]])#
				{#
					fit2.stem <- fit2.stem.bd;#
				} else {#
					fit2.stem <- fit2.stem.yule;#
				}#
			}#
		}#
	}#
	if ((shiftCut == "node" || shiftCut == "both") && !(node < root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		obj.node <- medusa.split(node=node, z=z, desc=desc, shiftCut="node");#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
		#
		#
		# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'node', bitches! Working on node #", node)#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="yule");#
				fit1.node$model <- "yule";#
			} else {#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="bd");#
				fit1.node$model <- "bd";#
			}#
		} else {#
			fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model=model);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.node <- prefit$tips[[node]];#
		} else if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		}#
		else { # novel shift#
			fit2.node.bd <- NULL;#
			fit2.node.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.node.yule <- medusa.ml.fit.partition(aff[2], z.node, sp, model="yule");#
				fit2.node.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.node.bd <- medusa.ml.fit.partition(aff[2], z.node, sp, model="bd");#
				fit2.node.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.node.bd))#
			{#
				fit2.node <- fit2.node.yule;#
			} else if (is.null(fit2.node.yule)) {#
				fit2.node <- fit2.node.bd;#
			} else {#
## Considering both places for a shift#
				fit2.node.bd.val <- calculate.model.fit(fit=fit2.node.bd, z=z);#
				fit2.node.yule.val <- calculate.model.fit(fit=fit2.node.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.node.bd.val[[element]] < fit2.node.yule.val[[element]])#
				{#
					fit2.node <- fit2.node.bd;#
				} else {#
					fit2.node <- fit2.node.yule;#
				}#
			}	#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par);#
		stem.fit <- calculate.model.fit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par);#
		node.fit <- calculate.model.fit(fit=node.val, z=z);#
		#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
#			cat("Stem wins!\n");#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
#			cat("Node wins!\n");#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculate.model.fit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
#
#
#
#
#
#
#
## make.lik.medusa.part: generate a likelihood function for a single partition.#
make.lik.medusa.part <- function (partition, model)#
{#
# Handle internal and pendant edges separately#
	is.int <- is.na(partition[,"n.t"]);#
	is.pend <- !is.int;#
	#
	n.int <- sum(is.int);#
	n.pend <- sum(is.pend);#
	#
## Internal and pendant calculations differ; split'em up#
	int  <- partition[is.int,,drop=FALSE];#
	pend <- partition[is.pend,,drop=FALSE];#
	#
	sum.int.t.len <- sum(int[,"t.len"]);  # Simply sum all internal edges#
	int.t.0 <- int[,"t.0"];#
	#
# 'n.0' = Foote's 'a', initial diversity; 'n.t' = Foote's 'n', final diversity#
	pend.n.0 <- pend[,"n.0"]; # Foote's 'a': initial diversity#
	pend.n.t <- pend[,"n.t"]; # Foote's 'n': final diversity#
	pend.t.len <- pend[,"t.len"];#
	#
	if (n.int + n.pend != length(partition[,1])) stop("You messed up, yo.");#
	#
# User may pass in epsilon; don't change it, just estimate r#
	f <- function(pars)#
	{#
		if (model == "bd")#
		{#
			r <- pars[1];#
			epsilon <- pars[2];#
			#
			if (r <= 0 || epsilon <= 0 || epsilon >= 1) {return(-Inf);}#
		} else {#
			#
			r <- pars[1];#
			epsilon <- 0;#
			#
			if (r <= 0 || is.nan(r)) {return(-Inf);}#
		}#
		#
		l.int <- numeric();#
		l.pend <- numeric();#
		#
		if (n.int == 0) {l.int <- 0;} else {#
## Likelihood of internal edges from Rabosky et al. (2007) equation (2.3):#
			l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
		}#
		#
		if (n.pend == 0) {l.pend <- 0} else {#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
			#
			ert <- exp(r * pend.t.len);#
			B <- (ert - 1) / (ert - epsilon); # Equivalently: B <- (bert - b) / (bert - d)#
			#
			l.pend <- sum(log(1 - B) + (pend.n.t - 1)*log(B));#
		}#
		return(l.int + l.pend);#
	}#
}#
#
#
## 'fit' contains '$par' and '$lnlik'#
calculate.model.fit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	#
# Updated for more general models: check how many parameter values != NA#
#	k <- 2 + (3 * (num.models - 1))#
	k <- sum(!is.na(fit$par)) + (num.models - 1); # number of estimated parameters + number of breaks#
	#
	lnLik <- fit$lnLik;#
	#
	aic <- (-2 * lnLik) + (2*k);#
	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
get.b.d <- function (r, epsilon)#
{#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
## Print out tree with ape-style node-numbering#
## Possibly of interest for users to identify numbers of node(s) off interest#
 ## If this is the case, make sure to pass in pruned tree#
plotNN <- function (phy, time=TRUE, margin=TRUE, label.offset=0.5, cex=0.5, ...) #
{#
	phy$node.label <- (length(phy$tip.label) + 1):max(phy$edge);#
	plot.phylo(phy, show.node.label=TRUE, no.margin=!margin, label.offset=label.offset, cex=cex, ...);#
	if (time && !margin) {cat("Cannot plot time axis without a margin.\n");}#
	else if (time && margin) {axisPhylo(cex.axis=0.75)};#
}
runTurboMEDUSA <-#
function(phy, richness=NULL, model.limit=20, stop="model.limit", model="mixed",#
	criterion="aicc", shiftCut="both", initialR=0.05, initialE=0.5, plotFig=FALSE, nexus=FALSE,#
	verbose=TRUE, mc=FALSE, num.cores=NULL, ...)#
{#
	if (nexus) phy <- read.nexus(phy);#
	if (is.null(richness))  # Assume tree represents single species tips and is completely sampled#
	{#
		richness <- data.frame(taxon=phy$tip.label, n.taxa=1);#
	} else {#
## Before determining model.limit, prune tree as necessary (from 'taxon' information in 'richness')#
		phyData <- prune.tree.merge.data(phy=phy, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	}#
	#
## Limit on number of piecewise models fitted; based on tree size, aicc correction factor, #
## and flavour of model fitted (i.e. # parameters estimated; birth-death or pure-birth)#
	model.limit <- get.max.model.limit(richness=richness, model.limit=model.limit, model=model, stop=stop, verbose=verbose);#
	#
## Determine correct AICc threshold from tree size (based on simulations)#
 ## Should be used for interpreting model-fit#
	threshold <- get.threshold(length(phy$tip.label));#
	cat("Appropriate AICc threshold for tree of ", length(phy$tip.label), " tips is: ", threshold, ".\n\n", sep="");#
	#
## Store pertinent information: branch times, richness, descendants#
	cat("Preparing data for analysis... ");#
	#
## Keep track of all nodes, internal and pendant (for keeping track of breakpoints)#
	pend.nodes <- seq_len(length(phy$tip.label));   # Calculate pendant splits just once, keep track through various models#
	int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
	root.node <- length(phy$tip.label) + 1;#
	all.nodes <- c(pend.nodes, root.node, int.nodes);#
	#
## The important bits. Set up z, get descendants and number of tips per node#
	obj <- make.cache.medusa(phy=phy, richness=richness, all.nodes=all.nodes, mc=mc, num.cores=num.cores);#
	#
	desc <- list(desc.stem=obj$desc.stem, desc.node=obj$desc.node);#
	z <- obj$z;#
	z.orig <- z; # Save for summarizing models later#
	num.tips <- obj$num.tips;#
	#
	cat("done.\n");#
	#
## Pre-fit pendant edges so these values need not be re(re(re))calculated; amounts to ~25% of all calculations#
 ## Will show particular performance gain for edges with many fossil observations#
	cat("Optimizing parameters for pendant edges... ");#
	tips <- NULL;#
# Will always be shiftCut="stem"; if mixed model, keep only best fit and throw out other in medusa.ml.prefit#
	if (mc)#
	{#
		tips <- mclapply(pend.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion, mc.cores=num.cores);#
	} else {#
		tips <- lapply(pend.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion);#
	}#
	cat("done.\n");#
	#
## Pre-fit virgin internal nodes; should deliver performance gain for early models, and especially for large trees#
 ## Remain useful until a spilt is accepted within the clade#
 ## Need to incorporate cutAtStem here#
	cat("Pre-calculating parameters for virgin internal nodes... ");#
	virgin.stem <- list(); virgin.node <- list();#
	if (mc)#
	{#
		if (shiftCut == "stem" || shiftCut == "both")#
		{#
			virgin.stem <- mclapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion, mc.cores=num.cores);#
		}#
		if (shiftCut == "node" || shiftCut == "both")#
		{#
			virgin.node <- mclapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="node", criterion=criterion, mc.cores=num.cores);#
		}#
	} else {#
		if (shiftCut == "stem" || shiftCut == "both")#
		{#
			virgin.stem <- lapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion);#
		}#
		if (shiftCut == "node" || shiftCut == "both")#
		{#
			virgin.node <- lapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="node", criterion=criterion);#
		}#
	}#
	virgin.nodes <- list(stem=virgin.stem, node=virgin.node);#
	cat("done.\n\n");#
	#
	prefit <- list(tips=tips, virgin.nodes=virgin.nodes);#
	#
## Fit the base model#
## 'fit' holds current results; useful for initializing subsequent models#
	fit <- list();#
	if (model == "mixed")#
	{#
		fit.bd <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="bd");#
		fit.yule <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="yule");#
		if (fit.bd[[criterion]] < fit.yule[[criterion]]) {#
			fit <- fit.bd;#
			fit$model <- "bd";#
		} else {#
			fit <- fit.yule;#
			fit$model <- "yule";#
		}#
	} else if (model == "bd") {#
		fit <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="bd");#
		fit$model <- "bd";#
	} else {#
		fit <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="yule");#
		fit$model <- "yule";#
	}#
	models <- list(fit);#
	#
	if (stop == "model.limit")#
	{#
		cat("Step 1 (of ", model.limit, "): best likelihood = ", models[[1]]$lnLik, "; AICc = ", models[[1]]$aicc, "; model = ", models[[1]]$model, "\n", sep="");#
		for (i in seq_len(model.limit-1))#
		{#
			node.list <- all.nodes[-fit$split.at];#
			if (mc)  # multicore (i.e. multithreaded) processing. No GUI, and not at all on Windows#
			{#
				res <- mclapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut, mc.cores=num.cores);#
			} else {#
				res <- lapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut);#
			}#
# Select model with best score according to the specific criterion employed (default aicc)#
			best <- which.min(unlist(lapply(res, "[[", criterion)));#
			models <- c(models, res[best]);#
			fit <- res[[best]];   # keep track of '$split.at' i.e. nodes already considered#
			#
			z <- medusa.split(node=node.list[best], z=z, desc=desc, shiftCut=fit$cut.at[i+1])$z;#
			#
			cat("Step ", i+1, " (of ", model.limit, "): best likelihood = ", round(models[[i+1]]$lnLik, digits=7), "; AICc = ", models[[i+1]]$aicc,#
				"; shift at node ", models[[i+1]]$split.at[i+1], "; model=", models[[i+1]]$model[i+1], "; cut=", models[[i+1]]$cut.at[i+1], "\n", sep="");#
		}#
	} else if (stop == "threshold") {#
		i <- 1;#
		done <- FALSE;#
		cat("Step 1: best likelihood = ", round(models[[i+1]]$lnLik, digits=7), "; AICc = ", round(models[[i+1]]$aicc, digits=7), "; model = ", models[[1]]$model[i+1], "\n", sep="");#
		while (!done & i < model.limit)#
		{#
			node.list <- all.nodes[-fit$split.at];#
			if (mc)  # multicore (i.e. multithreaded) processing. No GUI, and not at all on Windows#
			{#
				res <- mclapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut, mc.cores=num.cores);#
			} else {#
				res <- lapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut);#
			}#
# Select model with best score according to the specific criterion employed (default aicc)#
			best <- which.min(unlist(lapply(res, "[[", criterion)));#
	# Compare last accepted model to current best model#
			if (as.numeric(models[[length(models)]][criterion]) - as.numeric(res[[best]][criterion]) < threshold)#
			{#
				cat("\nNo significant increase in ", criterion, " score. Disregarding subsequent piecewise models.\n", sep="");#
				done <- TRUE;#
				break;#
			}#
			models <- c(models, res[best]);#
			fit <- res[[best]];   # keep track of '$split.at' i.e. nodes already considered#
			#
			z <- medusa.split(node=node.list[best], z=z, desc=desc, shiftCut=fit$cut.at[i+1])$z;#
			#
			cat("Step ", i+1, ": best likelihood = ", round(models[[i+1]]$lnLik, digits=7), "; AICc = ", round(models[[i+1]]$aicc, digits=7),#
				"; shift at node ", models[[i+1]]$split.at[i+1], "; model=", models[[i+1]]$model[i+1], "; cut=", models[[i+1]]$cut.at[i+1], "\n", sep="");#
			i <- i+1;#
		}#
	}#
	#
	modelSummary <- calculate.model.fit.summary(models=models, phy=phy, plotFig=ifelse(length(models) > 1 & plotFig & !mc, TRUE, FALSE), threshold=threshold);#
	if (verbose)#
	{#
		cat("\n", "Model fit summary:", "\n\n", sep="");#
		print(modelSummary);#
		if (threshold > 0)#
		{#
			cat("\nAIC weights are not reported, as they are meaningless when using a threshold criterion.\n")#
		}#
	}#
	results <- list(z=z.orig, desc=desc, models=models, phy=phy, threshold=threshold, modelSummary=modelSummary);#
	#
#	return(results);#
}
summarizeTurboMEDUSA <-#
function(results, modelNum=NULL, cutoff="threshold", criterion="aicc", plotTree=TRUE, time=TRUE, node.labels=TRUE, cex=0.5,#
	plotSurface=FALSE, printTitle=TRUE, n.points=100, ...)#
{#
# Desirables:#
#  1. table listing parameter values of selected model#
#  2. list parameters of base model#
#  3. tree printed with colour-coded edges, node labels to indicate split position(s)#
#  4. plot likelihood surface#
	#
# Extract constituent components from results#
	fit <- results$models;#
	phy <- results$phy;#
	z <- results$z;#
	desc <- results$desc;#
	modelSummary <- results$modelSummary;#
	threshold <- results$threshold;#
	cutAt <- as.character(modelSummary$Cut.at);#
	cutAt[1] <- "NA";#
	#
# First, determine which model is desired#
	model.id <- 0;#
	if (!is.null(modelNum))#
	{#
		model.id <- modelNum;#
	} else {   # Find best model using some criterion (threshold or user-defined)#
		if (cutoff != "threshold") {threshold <- cutoff}#
		else {cat("\nSelecting model based on corrected threshold (improvement in information theoretic score of ", threshold, " units).\n", sep="");}#
		model.id <- 1;#
		while (1)#
		{#
			if ((model.id + 1) > length(fit)) break;#
			if ((unlist(fit[[model.id]][criterion]) - unlist(fit[[model.id+1]][criterion])) < threshold) break;#
			model.id <- model.id + 1;#
		}#
	}#
	#
	break.pts <- fit[[model.id]]$split.at;#
	cuts <- cutAt[1: model.id];#
		#
	opt.model <- cbind(N.Models=seq(1:length(fit[[model.id]]$split.at)), Shift.Node=fit[[model.id]]$split.at, fit[[model.id]]$par, LnLik.part=fit[[model.id]]$lnLik.part)#
	opt.model <- as.data.frame(opt.model);#
	opt.model <- cbind(opt.model[,c(1:2)], Cut.at=cuts, opt.model[,c(3:5)])#
	opt.model[1,2] <- NA # root node for base model#
	#
	base.model <- as.data.frame(fit[[1]]$par);#
	#
	cat("\nEstimated parameter values for model #", model.id, ":\n\n", sep="");#
	print.data.frame(opt.model, digits=5);#
	#
	opt.fit <- 0;#
	base.fit <- 0;#
	if (criterion == "aicc")#
	{#
		opt.fit <- modelSummary$aicc[model.id];#
		base.fit <- modelSummary$aicc[1];#
	} else { # aic used#
		opt.fit <- modelSummary$aic[model.id];#
		base.fit <- modelSummary$aic[1];#
	}#
	cat("\nModel fit summary for model #", model.id, ":\n\n", sep="");#
	cat("\tLog-likelihood = ", as.numeric(results$models[[model.id]]["lnLik"]), "\n", sep="");#
	cat("\t", criterion, " = ", opt.fit, "\n", sep="");#
	#
	if (model.id != 1)#
	{#
		if (modelSummary$N.Param[1] == 1) {model <- "Yule";} else {model <- "BD";}#
		cat("\nFor comparison, estimated values for the base (single homogeneous-", model, ") model are:\n\n", sep="");#
		print.data.frame(base.model, digits=5, row.names=FALSE);#
		cat("\nModel fit summary for base model:\n\n", sep="");#
		cat("\tLog-likelihood = ", as.numeric(results$models[[1]]["lnLik"]), "\n", sep="");#
		cat("\t", criterion, " = ", base.fit, "\n", sep="");#
	}#
	#
# Get desired tree-model conformation#
# Check on cutAtStem option to accurately recover model and paint tree#
	labels <- break.pts;#
	if (length(break.pts) > 1)#
	{#
		labels[1] <- break.pts[1];#
		for (i in 2:length(break.pts))#
		{#
			tmp <- medusa.split(node=break.pts[i], z=z, desc=desc, shiftCut=cutAt[i]);#
			if (cutAt[i] == "stem")#
			{#
				labels[i] <- z[which(z[,"dec"] == break.pts[i]),"anc"]#
			}#
			z <- tmp$z;#
		}#
	}#
	#
	mm <- match(phy$edge[,2], z[,"dec"]);#
# Plot tree with purdy colours and labelled nodes (to better map between tree and table)#
	if (plotTree)#
	{#
		dev.new();#
		margin <- FALSE;#
		#
		if (time) {margin=TRUE;}#
		plot.phylo(phy, edge.color=z[mm,"partition"], no.margin=!margin, cex=cex, ...);#
		if (time)#
		{#
			axisPhylo(cex.axis=0.75);#
			mtext("Divergence Time (MYA)", at=(max(get("last_plot.phylo", envir = .PlotPhyloEnv)$xx)*0.5), side = 1, line = 2, cex=0.75);#
		}#
		if (node.labels) # label with stem/node breaks in mind#
		{#
			for (i in  1:length(break.pts))#
			{#
				nodelabels(i, node=labels[i], frame = "c", font = 1, cex=0.5);#
			}#
		}#
	}#
	#
## Due to my current ineptitude in plotting in R, plotting surface is currently [0,1] for#
#  both r and epsilon, even if values of interest are clustered in some subregion.#
	if (plotSurface)#
	{#
		n.pieces <- length(opt.model[,1]);#
		for (k in 1: n.pieces)#
		{	#
	## *** NEED TO MAKE CHECKS IF CURRENT MODEL IS YULE, AND THEN FIGURE HOW TO PLOT IT ***#
		#	if Yule, need different plot type#
			if (fit[[model.id]]$model[k] == "bd")#
			{#
				lik <- make.lik.medusa.part(z[z[,"partition"] == k,,drop=FALSE], model="bd");#
				#
## center these around the MLEs#
				opt.r <- as.numeric(opt.model[k,"r"]);#
				opt.epsilon <- as.numeric(opt.model[k,"epsilon"]);#
				#
				lik.vals <- matrix(nrow=n.points, ncol=n.points);#
				r.vals <- seq(from=(opt.r/10), to=(opt.r*2), length.out=n.points);#
				eps.vals <- seq(from=1e-10, to=1.0, length.out=n.points);#
				#
				for (i in 1:length(r.vals))#
				{#
					for (j in 1:(length(eps.vals))) {lik.vals[i,j] <- lik(pars=c(r.vals[i], eps.vals[j]));}#
				}#
				if (n.pieces > 1) {cat("Completed computing surface for piecewise model #", k, "\n", sep="");}#
				#
# Contour plot#
				plot.new()#
				#
				max.lik <- as.numeric(opt.model[k,"LnLik.part"])  # MLE#
				#
				lines <- c(max.lik-0.5, max.lik-1, max.lik-2, max.lik-3, max.lik-4, max.lik-5, max.lik-10, max.lik-50, max.lik-100)#
				contour(lik.vals, levels=lines, labels=c(0.5, 1, 2, 3, 4, 5, 10, 50, 100), axes=FALSE, xlab="r (b-d)", ylab="epsilon (d/b)", method="flattest")#
				tics<-floor(c(1, n.points/4, n.points/2, n.points*3/4, n.points));#
				axis(1, at=c(0, 0.25, 0.5, 0.75, 1), labels=round(r.vals[tics], 3));#
				axis(2, at=c(0, 0.25, 0.5, 0.75, 1), labels=round(eps.vals[tics], 3));#
				points(x=opt.r*(1/(min(r.vals)+max(r.vals))), y=opt.epsilon*(1/(min(eps.vals)+max(eps.vals))), pch=16, col="black"); # inferred ML values#
				if (n.pieces > 1 && printTitle) {title(main=paste("Piecewise Birth-Death Model #", k, sep=""));}#
			} else {#
				lik <- make.lik.medusa.part(z[z[,"partition"] == k,,drop=FALSE], model="yule");#
				#
				opt.r <- as.numeric(opt.model[k,"r"]);#
				lik.vals <- numeric(n.points);#
				r.vals <- seq(from=0, to=0.05, length.out=n.points);#
#				r.vals <- seq(from=(opt.r/10), to=(opt.r*2), length.out=n.points);#
				#
				for (i in 1:length(r.vals))#
				{#
					lik.vals[i] <- lik(pars=r.vals[i]);#
				}#
				if (n.pieces > 1) {cat("Completed computing surface for piecewise model #", k, "\n", sep="");}#
				#
				max.lik <- as.numeric(opt.model[k,"LnLik.part"]);  # MLE#
				#
				plot(r.vals, lik.vals, xlab="r (b-d)", ylab="Log-Likelihood", type="l");#
				points(x=opt.r, y=max.lik, pch=16, col="black");#
				if (n.pieces > 1 && printTitle) {title(main=paste("Piecewise Yule Model #", k, sep=""));}#
			}#
		}#
	}#
	treeParameters <- list(z=z, edge.colour=mm, break.pts=break.pts, phy=phy, labels=labels);#
}#
#
#
## Prints out a table of likelihoods, parameters, and aic scores#
calculate.model.fit.summary <- function (models, phy, plotFig, fig.title=NULL, threshold, ...)#
{#
	tmp <- matrix(nrow=(length(models)), ncol=6);#
	colnames(tmp) <- c("N.Models", "Shift.Node", "N.Param", "Ln.Lik", "aic", "aicc");#
	#
	w.aic <- numeric(length(models));#
	w.aicc <- numeric(length(models));#
	cut.at <- character(length(models));#
	model <- character(length(models));#
	#
	for (i in 1:length(tmp[,1]))#
	{#
		tmp[i,] <- c(i, as.integer(models[[i]]$split.at[i]), models[[i]]$num.par, models[[i]]$lnLik, models[[i]]$aic, models[[i]]$aicc);#
		cut.at[i] <- models[[i]]$cut.at[i];#
		model[i] <- models[[i]]$model[i];#
	}#
	cut.at[1] <- "NA";#
	#
	all.res <- as.data.frame(tmp);#
	#
	if (threshold == 0)#
	{#
		w.aic <- round(calculate.model.weights(all.res$aic), digits=5);#
		w.aicc <- round(calculate.model.weights(all.res$aicc), digits=5);#
		all.res <- cbind(all.res[,c(1:2)], Cut.at=cut.at, Model=model, all.res[,c(3:5)], w.aic=w.aic$w, aicc=all.res$aicc, w.aicc=w.aicc$w);#
	} else {#
		all.res <- cbind(all.res[,c(1:2)], Cut.at=cut.at, Model=model, all.res[,c(3:6)]);#
	}#
	#
	all.res[1,2] <- NA # root node for base model#
	#
	if (plotFig)#
	{#
		dev.new();#
		plotModelFit(all.res);#
		if (!is.null(fig.title)) {title(main=fig.title, cex.main=0.75);}#
	}#
	return(all.res);#
}#
#
#
## Self explanatory#
## These are meaningless when using a threshold criterion#
calculate.model.weights <- function (fit)#
{#
	best <- min(fit);#
	delta <- fit-best;#
	sumDelta <- sum(exp(-0.5 * delta));#
	w <- (exp(-0.5 * delta)/sumDelta);#
	#
	results <- data.frame(fit=fit,delta=delta,w=w);#
	#
	return(results);#
}#
#
#
## Create a plot of model-fit vs. model-size#
plotModelFit <- function (all.res)#
{#
	ylim <- c(min(all.res[,"aic"],all.res[,"aicc"]), max(all.res[,"aic"],all.res[,"aicc"]));#
	plot(all.res[,"N.Models"],all.res[,"aicc"], xlab="Number of Piecewise Models", ylab="Model Fit", ylim=ylim, type="l", col="blue");#
	points(all.res[,"N.Models"],all.res[,"aicc"], col="blue", pch=21, bg="white");#
	points(all.res[,"N.Models"],all.res[,"aic"], col="black", type="l");#
	points(all.res[,"N.Models"],all.res[,"aic"], col="black", pch=21, bg="white");#
	#
	legend("topleft", c("aicc","aic"), pch=21, pt.bg="white", lty=1, col=c("blue", "black"), inset = .05, cex=0.75, bty="n"); # 'bottomright' also works#
}
## Takes in tree summary data from summarizeTurboMEDUSA#
## treeParameters <- list(z, edge.colour, break.pts, phy, labels)#
## make it possible to change default colors#
plotPrettyTree <- function (treeParameters, time=TRUE, node.labels=FALSE, margin=FALSE, cex=0.5, label.offset=0,#
	font=3, color.tip.label=FALSE, ...)#
{#
	edge.colour <- treeParameters$edge.colour;#
	labels <- treeParameters$labels;#
	break.pts <- treeParameters$break.pts;#
	phy <- treeParameters$phy;#
	z <- treeParameters$z;#
	colour <- NULL;#
	#
	dev.new();#
	#
	if (color.tip.label)#
	{#
		for (i in 1:length(phy$tip.label))#
		{#
			colour[i] <- as.integer(z[which(z[,"dec"] == i),"partition"]);#
		}#
	}#
	if (time) {margin=TRUE;}#
	plot.phylo(phy, edge.color=z[edge.colour,"partition"], no.margin=!margin, cex=cex, label.offset=label.offset, tip.color=colour, font=font, ...);#
	if (time)#
	{#
		axisPhylo(cex.axis=0.75);#
		mtext("Divergence Time (MYA)", at=(max(get("last_plot.phylo", envir = .PlotPhyloEnv)$xx)*0.5), side = 1, line = 2, cex=0.75);#
	}#
	if (node.labels)#
	{#
		for (i in  1:length(break.pts))#
		{#
			nodelabels(i, node= break.pts[i], frame = "c", font = 1, cex=0.5);#
		}#
	}#
}
runTurboMEDUSA(whales$phy, whales$richness) -> whales.res
## Function to prune tree using 'richness' information, assumed to have minimally two columns, "taxon" and "n.taxa"#
##   Perhaps relax on these column names, may cause too many problems#
## May also include 'exemplar' column; in that case, rename relevant tip.label before pruning.#
prune.tree.merge.data <- function (phy, richness, verbose)#
{#
# Rename exemplar taxa with taxon name in richness file#
	if (!is.null(richness$exemplar))#
	{#
# Change relevant tip.labels in phy; individual 'exemplar' may be NA, use original tip.label.#
# Ordering in richness file should NOT be assumed to match order of tip.labels#
		i.na <- is.na(richness$exemplar);#
		phy$tip.label[match(richness$exemplar[!i.na], phy$tip.label)] <- as.character(richness$taxon[!i.na]);#
	}#
	#
# make sure things are in the correct order and of correct format#
	if (length(richness[1,]) == 2)#
	{#
		if (colnames(richness)[1] != "taxon" || colnames(richness)[2] != "n.taxa")#
		{#
			if (class(richness[,1]) == "factor" & class(richness[,2]) == "integer")#
			{#
				colnames(richness) = c("taxon", "n.taxa");#
			} else if (class(richness[,1]) == "integer" & class(richness[,2]) == "factor")#
			{#
				colnames(richness) = c("n.taxa", "taxon");#
			} else {#
				cat("turboMEDUSA thinks your richness data is in an incorrect format. See ?runTurboMEDUSA.\n")#
				stop;#
			}#
		}#
	}#
	#
# Prune tree down to lineages with assigned richnesses#
	temp <- richness[, "n.taxa"];#
	names(temp) <- richness[, "taxon"];#
	pruned <- treedata(phy, temp, warnings=verbose)  # geiger function calling ape (namecheck)#
	#
# checking for typos#
	if (length(pruned$phy$tip.label) == 0) {#
		cat("\n\nWARNING: turboMEDUSA encountered a serious error. Tree has no tips after processing richness information! \nIt is likely that an incorrect richness file is being used. \nAnalysis cannot proceed. Please examine the information below to identify the error.\\nn");#
		cat("\nTree tip labels:\n");#
		print(phy$tip.label);#
		cat("\nRichness taxon labels:\n");#
		print(as.character(richness[, "taxon"]));#
		stop;#
	} else if (length(phy$tip.label) != length(pruned$phy$tip.label)) {#
		cat("turboMEDUSA thinks there is a typo in either the tree or richness files, as one or more tips were dropped from the tree.\n");#
		stop;#
	}#
#
	phy <- pruned$phy;#
# Check the tree#
	#	plotNN(phy)					# Node numbers (ape-style) plotted#
	#
	return(list(phy=phy, richness=richness));#
}#
#
#
## Original default was to fit 20 models (or less if the tree was small).#
## Changing to a stop-criterion (stop="model.limit") e.g. when k = n-1 (i.e. when denominator of aicc correction is undefined).#
## k <- (3*i-1) # when both birth and death are estimated, where i is the number of piecewise models#
  ## This occurs when i = n/3#
  ## If Yule, max i = n/2#
## n <- (2*num.taxa - 1) == (2*length(richness[,1]) - 1) # i.e. total number of nodes in tree (internal + pendant)#
## Alternatively use aicc threshold itself as a stopping criterion (stop="threshold").#
# AICc = AIC + 2*k*(k+1)/(n-k-1);#
get.max.model.limit <- function (richness, model.limit, model, stop, verbose)#
{#
	samp.size <- (2*length(richness[,1]) - 1)#
	if (model == "bd" || model == "mixed")#
	{#
		max.model.limit <- as.integer(samp.size/3) - ((!(samp.size %% 3)) * 1);#
	} else {#
		max.model.limit <- as.integer(samp.size/2) - ((!(samp.size %% 2)) * 1);#
	}#
	#
	if (stop == "model.limit")#
	{#
		if (model.limit > max.model.limit) {model.limit <- max.model.limit;}#
	} else {#
		model.limit <- max.model.limit;#
	}#
	#
	if (verbose)#
	{#
		cat("\nLimiting consideration to a maximum of ", model.limit, " piecewise", sep="");#
		if (model == "bd")#
		{#
			cat(" birth-death models")#
		} else if (model == "mixed")#
		{#
			cat(" mixed models")#
		} else {#
			cat(" pure-birth (Yule) models");#
		}#
		if (stop == "threshold") {cat(" (or until threshold is not satisfied)");}#
		cat(".\n\n")#
	}#
	#
	return(model.limit);#
}#
#
#
## Fitted curve from random b-d simulations#
## Value corresponds to 95th percentile of AICc(split) - AICc(no-split) for no-split simulations#
## x-shifted power function#
get.threshold <- function (x)#
{#
	a = -3.5941052380332650E+01;#
	b =  6.7372587299747000E+00;#
	c = -1.0061508340754866E-01;#
	Offset =  2.7516678664333408E+01;#
	y <- a * (x-b)^c + Offset;#
	if (y < 0) y <- 0;#
	return(y);#
}#
#
#
## The make.cache.medusa function is like the first half of the original splitEdgeMatrix().#
## It works through and reorders the edges, then works out start and end times of these#
## based on the phylogeny's branching times.#
###
## In addition, every node's descendants are also calculated.  The element 'desc' is a list.#
## $desc[i] contains the indices within $edge, $t.start, etc., of all descendants of node 'i'#
## (in ape node numbering format).#
make.cache.medusa <- function (phy, richness, all.nodes, mc, num.cores)#
{#
	n.tips <- length(phy$tip.label);#
	n.int <- nrow(phy$edge) - n.tips;#
	#
## Ape numbers the tips first#
	i.int <- seq_len(n.int);#
	interior <- phy$edge[,2] %in% phy$edge[,1];#
	bt <- branching.times(phy);#
	#
# Consider only internal edges first#
	edges.int <- phy$edge[interior,];#
	colnames(edges.int) <- c("anc", "dec");#
	#
	t.0 <- bt[match(edges.int[,1], (n.tips+1):max(edges.int))];#
	t.1 <- c(t.0[i.int] - phy$edge.length[interior]);#
	#
	z.internal <- cbind(edges.int, t.0, t.1, t.len=t.0 - t.1,#
		n.0=rep(1, n.int), n.t=rep(NA, n.int));#
	#
# Now, pendant edges; #
	edges.pendant <- phy$edge[match(seq_len(n.tips), phy$edge[,2]),];#
	colnames(edges.pendant) <- c("anc", "dec");#
	#
	t.0 <- bt[match(edges.pendant[,1], (n.tips+1):max(edges.pendant))];#
	t.1 <- rep(0, n.tips);#
# cannot assume richness ordering necessarily matches that of tip labels#
	ext.richness <- richness$n.taxa[match(phy$tip.label, richness$taxon)];#
	#
	z.pendant <- cbind(edges.pendant, t.0, t.1, t.len=t.0 - t.1,#
		n.0=rep(1, n.tips), n.t=ext.richness);#
	#
	z <- rbind(z.internal, z.pendant);#
	z <- cbind(z,partition=rep(1, length(z[,1]))); # Stores piecewise model structure#
	rownames(z) <- NULL;#
	#
# Used for identifying descendant nodes below i.e. tracking breakpoints#
	all.edges <- as.matrix(z[,c("anc","dec")]);#
	desc.stem <- list();#
	desc.node <- list();#
	#
	if (mc)#
	{#
		desc.stem <- mclapply(seq_len(max(all.edges)), descendants.cutAtStem.idx, all.edges=all.edges, mc.cores=num.cores);#
		desc.node <- mclapply(seq_len(max(all.edges)), descendants.cutAtNode.idx, all.edges=all.edges, mc.cores=num.cores);#
	} else {#
		desc.stem <- lapply(seq_len(max(all.edges)), descendants.cutAtStem.idx, all.edges=all.edges);#
		desc.node <- lapply(seq_len(max(all.edges)), descendants.cutAtNode.idx, all.edges=all.edges);#
	}#
	#
	for (i in 1:length(desc.node))#
	{#
		if (length(desc.node[[i]]) == 0) # tips#
		{#
			desc.node[[i]] = descendants.cutAtStem.idx(node.list=i, all.edges=all.edges)#
		}#
	}#
	#
## Needed downstream; don't recalculate#
 ## Gives the number of tips associated with an internal node; determines whether a node is 'virgin' or not#
	num.tips <- list()#
	if (mc)#
	{#
		num.tips <- mclapply(all.nodes, get.num.tips, phy=phy, mc.cores=num.cores);#
	} else {#
		num.tips <- lapply(all.nodes, get.num.tips, phy=phy);#
	}#
	#
	res <- list(z=z, desc.stem=desc.stem, desc.node=desc.node, num.tips=num.tips);#
	return(res);#
}#
#
#
## Needed for determining whther nodes are virgin nodes#
get.num.tips <- function (node, phy)#
{#
	n <- length(node.leaves(phy,node));#
	return(n);#
}#
#
#
## This generates the indices of all descendants of a node, using ape's edge matrix.#
## Deals with row numbers of the edge matrix rather than node numbers of the tree.#
descendants.cutAtStem <- function (node, all.edges)#
{#
	ans <- numeric();#
	ans <- node;#
	repeat {#
		node <- all.edges[all.edges[,1] %in% node,2];#
		if (length(node) > 0)#
		{#
			ans <- c(ans, node);#
		} else {break;}#
	}#
	return(unlist(ans));#
}#
#
#
## The function 'descendants' returns the indices of all descendants within the edge matrix.#
descendants.cutAtStem.idx <- function (node.list, all.edges)#
{#
	which(all.edges[,1] == node.list | all.edges[,2] %in% descendants.cutAtStem(node.list, all.edges));#
}#
#
#
## This generates the indices of all descendants of a node, using ape's edge matrix.#
## Deals with row numbers of the edge matrix rather than node numbers of the tree.#
descendants.cutAtNode <- function (node, all.edges)#
{#
	ans <- numeric();#
	repeat {#
		node <- all.edges[all.edges[,1] %in% node,2];#
		if (length(node) > 0)#
		{#
			ans <- c(ans, node);#
		} else {break;}#
	}#
	return(unlist(ans));#
}#
#
#
## The function 'descendants' returns the indices of all descendants within the edge matrix.#
descendants.cutAtNode.idx <- function (node.list, all.edges)#
{#
	which(all.edges[,1] == node.list | all.edges[,2] %in% descendants.cutAtNode(node.list, all.edges));#
}
runTurboMEDUSA(whales$phy, whales$richness) -> whales.res
runTurboMEDUSA(whales$phy, whales$richness, model.limit=40) -> whales.res
runTurboMEDUSA(whales$phy, whales$richness, model.limit=40, shiftCut="node") -> whales.res
runTurboMEDUSA(whales$phy, whales$richness, model.limit=40, shiftCut="stem") -> whales.res
runTurboMEDUSA(whales$phy, whales$richness, model.limit=40, shiftCut="stem", model="yule") -> whales.res
runTurboMEDUSA(whales$phy, whales$richness, model.limit=80, shiftCut="stem", model="yule") -> whales.res
runTurboMEDUSA(whales$phy, whales$richness, model.limit=80, shiftCut="node", model="yule") -> whales.res
load("/Users/josephwb/Projects/R_working/turboMEDUSA/tmp.rda")
load("/Users/josephwb/Projects/R_working/turboMEDUSA/mazama.RData")
ls()
runTurboMEDUSA(tmp$phy, tmp$richness, model.limit=80, shiftCut="node", model="yule") -> whales.res
runTurboMEDUSA(tmp$phy, tmp$richness, model.limit=80, shiftCut="stem", model="yule") -> whales.res
runTurboMEDUSA(foo, shiftCut="both")
ls()
load("/Users/josephwb/Projects/R_working/turboMEDUSA/mazama.RData")
ls()
rm(list=ls())
load("/Users/josephwb/Projects/R_working/turboMEDUSA/mazama.RData")
ls()
phy -> mazama.tre
## Only used for base model#
medusa.ml.initial <- function (z, initialR, initialE, model)#
{#
	rootnode <- min(z[,"anc"]);#
	obj <- medusa.ml.fit.partition(partition=1, z=z, sp=c(initialR, initialE), model=model);#
	#
	model.fit <- calculate.model.fit(fit=obj, z=z);#
	#
	return(list(par=matrix(obj$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=obj$lnLik, #
	   lnLik=obj$lnLik, split.at=rootnode, aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3], cut.at="node"));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted.#
## shiftCut can only be "stem" or "node" (not "both"), as both are evaluated separately#
medusa.ml.prefit <- function (node, z, desc, initialR, initialE, model, shiftCut, criterion)#
{#
	fitted.bd <- NULL;#
	fitted.yule <- NULL;#
#	fit <- NULL;#
	#
## if model is mixed, grab the optimally fitted one, drop the other; it is cutAtStem that matters, as it is the sum of 2 break likelihoods#
  ## optimal alone may be different than optimal in tandem#
	if (shiftCut == "stem")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.stem <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.stem, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "stem";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.stem <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.stem, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "stem";#
		}#
	} else if (shiftCut == "node")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.node <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.node, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "node";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.node <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.node, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "node";#
		}#
	}#
## Check which flavour of model fits best#
	if (is.null(fitted.bd) & !is.null(fitted.yule))#
	{#
		return(fitted.yule);#
	} else if (is.null(fitted.yule) & !is.null(fitted.bd)) {#
		return(fitted.bd);#
	} else {#
## Dealing with a 'mixed' model here; need to consider number of parameters.#
		bd.model.fit <- calculate.model.fit(fit=fitted.bd, z=z);#
		yule.model.fit <- calculate.model.fit(fit=fitted.yule, z=z);#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		if (is.nan(yule.model.fit[[element]]))#
		{#
			return(fitted.bd);#
		} else if (bd.model.fit[[element]] < yule.model.fit[[element]])#
		{#
			return(fitted.bd);#
		} else {#
			return(fitted.yule);#
		}#
	}#
}#
#
#
#
#
#
#
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
	new.part <- z[z[,"partition"] == partition,,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
	if (length(new.part) == 0)#
	{#
		cat("\nSaved time, bitches!\n")#
		par <- c(NA, NA);#
		return(list(par=par, lnLik=-Inf));#
	} else {#
# Construct likelihood function:#
		lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);#
		foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
		#
		if (model == "bd")#
		{#
			fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
			#
			if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
			#
			return(list(par=exp(fit$par), lnLik=-fit$value));#
		} else {#
			# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
			# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
			# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
			# best.guess2 <- log(node.richness) / #
			#
			# fit <- nlm(log(sp[1]), f=foo)#
			# par <- c(exp(fit$estimate), NA);#
			# return(list(par=par, lnLik=-fit$minimum));#
			#
			fit <- nlminb(log(sp[1]), objective=foo, upper=log(50), control=list(maxiter=1000))#
			par <- c(exp(fit$par), NA);#
			return(list(par=par, lnLik=-fit$objective));#
	#
			# fit <- optimize(f=foo, interval=c(-25, 1));#
			# par <- c(exp(fit$minimum), NA);#
			# return(list(par=par, lnLik=-fit$objective));#
		}#
	}#
}#
#
#
#
#
#
#
## Split the edge matrix 'z' by adding a partition rooted at node 'node'.#
##   Note: in original MEDUSA parlance, this is cutAtStem=T.#
## The list 'desc' is a list of descendants (see make.cache.medusa, above).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
## This is where 'shiftCut' matters#
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, or mixed models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
## fit1 model is already logged; only need to record fit2 model, and only non-prefitted nodes#
medusa.ml.update <- function (node, z, desc, fit, prefit, num.tips, root.node, model, criterion, shiftCut)#
{#
## various combinations possible#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" || shiftCut == "both" || node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		obj.stem <- medusa.split(node=node, z=z, desc=desc, shiftCut="stem");#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'stem', bitches! Working on node #", node)#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="yule");#
			} else {#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="bd");#
			}#
		} else {#
			fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model=model);#
			fit1.stem$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else { # novel shift#
			fit2.stem.bd <- NULL;#
			fit2.stem.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.stem.yule <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="yule");#
				fit2.stem.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.stem.bd <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="bd");#
				fit2.stem.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.stem.bd))#
			{#
				fit2.stem <- fit2.stem.yule;#
			} else if (is.null(fit2.stem.yule)) {#
				fit2.stem <- fit2.stem.bd;#
			} else {#
## Considering both places for a shift#
				fit2.stem.bd.val <- calculate.model.fit(fit=fit2.stem.bd, z=z);#
				fit2.stem.yule.val <- calculate.model.fit(fit=fit2.stem.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.stem.bd.val[[element]] < fit2.stem.yule.val[[element]])#
				{#
					fit2.stem <- fit2.stem.bd;#
				} else {#
					fit2.stem <- fit2.stem.yule;#
				}#
			}#
		}#
	}#
	if ((shiftCut == "node" || shiftCut == "both") && !(node < root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		obj.node <- medusa.split(node=node, z=z, desc=desc, shiftCut="node");#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
		#
		#
		# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'node', bitches! Working on node #", node)#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="yule");#
				fit1.node$model <- "yule";#
			} else {#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="bd");#
				fit1.node$model <- "bd";#
			}#
		} else {#
			fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model=model);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.node <- prefit$tips[[node]];#
		} else if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		}#
		else { # novel shift#
			fit2.node.bd <- NULL;#
			fit2.node.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.node.yule <- medusa.ml.fit.partition(aff[2], z.node, sp, model="yule");#
				fit2.node.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.node.bd <- medusa.ml.fit.partition(aff[2], z.node, sp, model="bd");#
				fit2.node.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.node.bd))#
			{#
				fit2.node <- fit2.node.yule;#
			} else if (is.null(fit2.node.yule)) {#
				fit2.node <- fit2.node.bd;#
			} else {#
## Considering both places for a shift#
				fit2.node.bd.val <- calculate.model.fit(fit=fit2.node.bd, z=z);#
				fit2.node.yule.val <- calculate.model.fit(fit=fit2.node.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.node.bd.val[[element]] < fit2.node.yule.val[[element]])#
				{#
					fit2.node <- fit2.node.bd;#
				} else {#
					fit2.node <- fit2.node.yule;#
				}#
			}	#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par);#
		stem.fit <- calculate.model.fit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par);#
		node.fit <- calculate.model.fit(fit=node.val, z=z);#
		#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
#			cat("Stem wins!\n");#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
#			cat("Node wins!\n");#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculate.model.fit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
#
#
#
#
#
#
#
## make.lik.medusa.part: generate a likelihood function for a single partition.#
make.lik.medusa.part <- function (partition, model)#
{#
# Handle internal and pendant edges separately#
	is.int <- is.na(partition[,"n.t"]);#
	is.pend <- !is.int;#
	#
	n.int <- sum(is.int);#
	n.pend <- sum(is.pend);#
	#
## Internal and pendant calculations differ; split'em up#
	int  <- partition[is.int,,drop=FALSE];#
	pend <- partition[is.pend,,drop=FALSE];#
	#
	sum.int.t.len <- sum(int[,"t.len"]);  # Simply sum all internal edges#
	int.t.0 <- int[,"t.0"];#
	#
# 'n.0' = Foote's 'a', initial diversity; 'n.t' = Foote's 'n', final diversity#
	pend.n.0 <- pend[,"n.0"]; # Foote's 'a': initial diversity#
	pend.n.t <- pend[,"n.t"]; # Foote's 'n': final diversity#
	pend.t.len <- pend[,"t.len"];#
	#
	if (n.int + n.pend != length(partition[,1])) stop("You messed up, yo.");#
	#
# User may pass in epsilon; don't change it, just estimate r#
	f <- function(pars)#
	{#
		if (model == "bd")#
		{#
			r <- pars[1];#
			epsilon <- pars[2];#
			#
			if (r <= 0 || epsilon <= 0 || epsilon >= 1) {return(-Inf);}#
		} else {#
			#
			r <- pars[1];#
			epsilon <- 0;#
			#
			if (r <= 0 || is.nan(r)) {return(-Inf);}#
		}#
		#
		l.int <- numeric();#
		l.pend <- numeric();#
		#
		if (n.int == 0) {l.int <- 0;} else {#
## Likelihood of internal edges from Rabosky et al. (2007) equation (2.3):#
			l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
		}#
		#
		if (n.pend == 0) {l.pend <- 0} else {#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
			#
			ert <- exp(r * pend.t.len);#
			B <- (ert - 1) / (ert - epsilon); # Equivalently: B <- (bert - b) / (bert - d)#
			#
			l.pend <- sum(log(1 - B) + (pend.n.t - 1)*log(B));#
		}#
		return(l.int + l.pend);#
	}#
}#
#
#
## 'fit' contains '$par' and '$lnlik'#
calculate.model.fit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	#
# Updated for more general models: check how many parameter values != NA#
#	k <- 2 + (3 * (num.models - 1))#
	k <- sum(!is.na(fit$par)) + (num.models - 1); # number of estimated parameters + number of breaks#
	#
	lnLik <- fit$lnLik;#
	#
	aic <- (-2 * lnLik) + (2*k);#
	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
get.b.d <- function (r, epsilon)#
{#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
## Print out tree with ape-style node-numbering#
## Possibly of interest for users to identify numbers of node(s) off interest#
 ## If this is the case, make sure to pass in pruned tree#
plotNN <- function (phy, time=TRUE, margin=TRUE, label.offset=0.5, cex=0.5, ...) #
{#
	phy$node.label <- (length(phy$tip.label) + 1):max(phy$edge);#
	plot.phylo(phy, show.node.label=TRUE, no.margin=!margin, label.offset=label.offset, cex=cex, ...);#
	if (time && !margin) {cat("Cannot plot time axis without a margin.\n");}#
	else if (time && margin) {axisPhylo(cex.axis=0.75)};#
}
runTurboMEDUSA <-#
function(phy, richness=NULL, model.limit=20, stop="model.limit", model="mixed",#
	criterion="aicc", shiftCut="both", initialR=0.05, initialE=0.5, plotFig=FALSE, nexus=FALSE,#
	verbose=TRUE, mc=FALSE, num.cores=NULL, ...)#
{#
	if (nexus) phy <- read.nexus(phy);#
	if (is.null(richness))  # Assume tree represents single species tips and is completely sampled#
	{#
		richness <- data.frame(taxon=phy$tip.label, n.taxa=1);#
	} else {#
## Before determining model.limit, prune tree as necessary (from 'taxon' information in 'richness')#
		phyData <- prune.tree.merge.data(phy=phy, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	}#
	#
## Limit on number of piecewise models fitted; based on tree size, aicc correction factor, #
## and flavour of model fitted (i.e. # parameters estimated; birth-death or pure-birth)#
	model.limit <- get.max.model.limit(richness=richness, model.limit=model.limit, model=model, stop=stop, verbose=verbose);#
	#
## Determine correct AICc threshold from tree size (based on simulations)#
 ## Should be used for interpreting model-fit#
	threshold <- get.threshold(length(phy$tip.label));#
	cat("Appropriate AICc threshold for tree of ", length(phy$tip.label), " tips is: ", threshold, ".\n\n", sep="");#
	#
## Store pertinent information: branch times, richness, descendants#
	cat("Preparing data for analysis... ");#
	#
## Keep track of all nodes, internal and pendant (for keeping track of breakpoints)#
	pend.nodes <- seq_len(length(phy$tip.label));   # Calculate pendant splits just once, keep track through various models#
	int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
	root.node <- length(phy$tip.label) + 1;#
	all.nodes <- c(pend.nodes, root.node, int.nodes);#
	#
## The important bits. Set up z, get descendants and number of tips per node#
	obj <- make.cache.medusa(phy=phy, richness=richness, all.nodes=all.nodes, mc=mc, num.cores=num.cores);#
	#
	desc <- list(desc.stem=obj$desc.stem, desc.node=obj$desc.node);#
	z <- obj$z;#
	z.orig <- z; # Save for summarizing models later#
	num.tips <- obj$num.tips;#
	#
	cat("done.\n");#
	#
## Pre-fit pendant edges so these values need not be re(re(re))calculated; amounts to ~25% of all calculations#
 ## Will show particular performance gain for edges with many fossil observations#
	cat("Optimizing parameters for pendant edges... ");#
	tips <- NULL;#
# Will always be shiftCut="stem"; if mixed model, keep only best fit and throw out other in medusa.ml.prefit#
	if (mc)#
	{#
		tips <- mclapply(pend.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion, mc.cores=num.cores);#
	} else {#
		tips <- lapply(pend.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion);#
	}#
	cat("done.\n");#
	#
## Pre-fit virgin internal nodes; should deliver performance gain for early models, and especially for large trees#
 ## Remain useful until a spilt is accepted within the clade#
 ## Need to incorporate cutAtStem here#
	cat("Pre-calculating parameters for virgin internal nodes... ");#
	virgin.stem <- list(); virgin.node <- list();#
	if (mc)#
	{#
		if (shiftCut == "stem" || shiftCut == "both")#
		{#
			virgin.stem <- mclapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion, mc.cores=num.cores);#
		}#
		if (shiftCut == "node" || shiftCut == "both")#
		{#
			virgin.node <- mclapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="node", criterion=criterion, mc.cores=num.cores);#
		}#
	} else {#
		if (shiftCut == "stem" || shiftCut == "both")#
		{#
			virgin.stem <- lapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion);#
		}#
		if (shiftCut == "node" || shiftCut == "both")#
		{#
			virgin.node <- lapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="node", criterion=criterion);#
		}#
	}#
	virgin.nodes <- list(stem=virgin.stem, node=virgin.node);#
	cat("done.\n\n");#
	#
	prefit <- list(tips=tips, virgin.nodes=virgin.nodes);#
	#
## Fit the base model#
## 'fit' holds current results; useful for initializing subsequent models#
	fit <- list();#
	if (model == "mixed")#
	{#
		fit.bd <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="bd");#
		fit.yule <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="yule");#
		if (fit.bd[[criterion]] < fit.yule[[criterion]]) {#
			fit <- fit.bd;#
			fit$model <- "bd";#
		} else {#
			fit <- fit.yule;#
			fit$model <- "yule";#
		}#
	} else if (model == "bd") {#
		fit <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="bd");#
		fit$model <- "bd";#
	} else {#
		fit <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="yule");#
		fit$model <- "yule";#
	}#
	models <- list(fit);#
	#
	if (stop == "model.limit")#
	{#
		cat("Step 1 (of ", model.limit, "): best likelihood = ", models[[1]]$lnLik, "; AICc = ", models[[1]]$aicc, "; model = ", models[[1]]$model, "\n", sep="");#
		for (i in seq_len(model.limit-1))#
		{#
			node.list <- all.nodes[-fit$split.at];#
			if (mc)  # multicore (i.e. multithreaded) processing. No GUI, and not at all on Windows#
			{#
				res <- mclapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut, mc.cores=num.cores);#
			} else {#
				res <- lapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut);#
			}#
# Select model with best score according to the specific criterion employed (default aicc)#
			best <- which.min(unlist(lapply(res, "[[", criterion)));#
			models <- c(models, res[best]);#
			fit <- res[[best]];   # keep track of '$split.at' i.e. nodes already considered#
			#
			z <- medusa.split(node=node.list[best], z=z, desc=desc, shiftCut=fit$cut.at[i+1])$z;#
			#
			cat("Step ", i+1, " (of ", model.limit, "): best likelihood = ", round(models[[i+1]]$lnLik, digits=7), "; AICc = ", models[[i+1]]$aicc,#
				"; shift at node ", models[[i+1]]$split.at[i+1], "; model=", models[[i+1]]$model[i+1], "; cut=", models[[i+1]]$cut.at[i+1], "\n", sep="");#
		}#
	} else if (stop == "threshold") {#
		i <- 1;#
		done <- FALSE;#
		cat("Step 1: best likelihood = ", round(models[[i+1]]$lnLik, digits=7), "; AICc = ", round(models[[i+1]]$aicc, digits=7), "; model = ", models[[1]]$model[i+1], "\n", sep="");#
		while (!done & i < model.limit)#
		{#
			node.list <- all.nodes[-fit$split.at];#
			if (mc)  # multicore (i.e. multithreaded) processing. No GUI, and not at all on Windows#
			{#
				res <- mclapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut, mc.cores=num.cores);#
			} else {#
				res <- lapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut);#
			}#
# Select model with best score according to the specific criterion employed (default aicc)#
			best <- which.min(unlist(lapply(res, "[[", criterion)));#
	# Compare last accepted model to current best model#
			if (as.numeric(models[[length(models)]][criterion]) - as.numeric(res[[best]][criterion]) < threshold)#
			{#
				cat("\nNo significant increase in ", criterion, " score. Disregarding subsequent piecewise models.\n", sep="");#
				done <- TRUE;#
				break;#
			}#
			models <- c(models, res[best]);#
			fit <- res[[best]];   # keep track of '$split.at' i.e. nodes already considered#
			#
			z <- medusa.split(node=node.list[best], z=z, desc=desc, shiftCut=fit$cut.at[i+1])$z;#
			#
			cat("Step ", i+1, ": best likelihood = ", round(models[[i+1]]$lnLik, digits=7), "; AICc = ", round(models[[i+1]]$aicc, digits=7),#
				"; shift at node ", models[[i+1]]$split.at[i+1], "; model=", models[[i+1]]$model[i+1], "; cut=", models[[i+1]]$cut.at[i+1], "\n", sep="");#
			i <- i+1;#
		}#
	}#
	#
	modelSummary <- calculate.model.fit.summary(models=models, phy=phy, plotFig=ifelse(length(models) > 1 & plotFig & !mc, TRUE, FALSE), threshold=threshold);#
	if (verbose)#
	{#
		cat("\n", "Model fit summary:", "\n\n", sep="");#
		print(modelSummary);#
		if (threshold > 0)#
		{#
			cat("\nAIC weights are not reported, as they are meaningless when using a threshold criterion.\n")#
		}#
	}#
	results <- list(z=z.orig, desc=desc, models=models, phy=phy, threshold=threshold, modelSummary=modelSummary);#
	#
#	return(results);#
}
summarizeTurboMEDUSA <-#
function(results, modelNum=NULL, cutoff="threshold", criterion="aicc", plotTree=TRUE, time=TRUE, node.labels=TRUE, cex=0.5,#
	plotSurface=FALSE, printTitle=TRUE, n.points=100, ...)#
{#
# Desirables:#
#  1. table listing parameter values of selected model#
#  2. list parameters of base model#
#  3. tree printed with colour-coded edges, node labels to indicate split position(s)#
#  4. plot likelihood surface#
	#
# Extract constituent components from results#
	fit <- results$models;#
	phy <- results$phy;#
	z <- results$z;#
	desc <- results$desc;#
	modelSummary <- results$modelSummary;#
	threshold <- results$threshold;#
	cutAt <- as.character(modelSummary$Cut.at);#
	cutAt[1] <- "NA";#
	#
# First, determine which model is desired#
	model.id <- 0;#
	if (!is.null(modelNum))#
	{#
		model.id <- modelNum;#
	} else {   # Find best model using some criterion (threshold or user-defined)#
		if (cutoff != "threshold") {threshold <- cutoff}#
		else {cat("\nSelecting model based on corrected threshold (improvement in information theoretic score of ", threshold, " units).\n", sep="");}#
		model.id <- 1;#
		while (1)#
		{#
			if ((model.id + 1) > length(fit)) break;#
			if ((unlist(fit[[model.id]][criterion]) - unlist(fit[[model.id+1]][criterion])) < threshold) break;#
			model.id <- model.id + 1;#
		}#
	}#
	#
	break.pts <- fit[[model.id]]$split.at;#
	cuts <- cutAt[1: model.id];#
		#
	opt.model <- cbind(N.Models=seq(1:length(fit[[model.id]]$split.at)), Shift.Node=fit[[model.id]]$split.at, fit[[model.id]]$par, LnLik.part=fit[[model.id]]$lnLik.part)#
	opt.model <- as.data.frame(opt.model);#
	opt.model <- cbind(opt.model[,c(1:2)], Cut.at=cuts, opt.model[,c(3:5)])#
	opt.model[1,2] <- NA # root node for base model#
	#
	base.model <- as.data.frame(fit[[1]]$par);#
	#
	cat("\nEstimated parameter values for model #", model.id, ":\n\n", sep="");#
	print.data.frame(opt.model, digits=5);#
	#
	opt.fit <- 0;#
	base.fit <- 0;#
	if (criterion == "aicc")#
	{#
		opt.fit <- modelSummary$aicc[model.id];#
		base.fit <- modelSummary$aicc[1];#
	} else { # aic used#
		opt.fit <- modelSummary$aic[model.id];#
		base.fit <- modelSummary$aic[1];#
	}#
	cat("\nModel fit summary for model #", model.id, ":\n\n", sep="");#
	cat("\tLog-likelihood = ", as.numeric(results$models[[model.id]]["lnLik"]), "\n", sep="");#
	cat("\t", criterion, " = ", opt.fit, "\n", sep="");#
	#
	if (model.id != 1)#
	{#
		if (modelSummary$N.Param[1] == 1) {model <- "Yule";} else {model <- "BD";}#
		cat("\nFor comparison, estimated values for the base (single homogeneous-", model, ") model are:\n\n", sep="");#
		print.data.frame(base.model, digits=5, row.names=FALSE);#
		cat("\nModel fit summary for base model:\n\n", sep="");#
		cat("\tLog-likelihood = ", as.numeric(results$models[[1]]["lnLik"]), "\n", sep="");#
		cat("\t", criterion, " = ", base.fit, "\n", sep="");#
	}#
	#
# Get desired tree-model conformation#
# Check on cutAtStem option to accurately recover model and paint tree#
	labels <- break.pts;#
	if (length(break.pts) > 1)#
	{#
		labels[1] <- break.pts[1];#
		for (i in 2:length(break.pts))#
		{#
			tmp <- medusa.split(node=break.pts[i], z=z, desc=desc, shiftCut=cutAt[i]);#
			if (cutAt[i] == "stem")#
			{#
				labels[i] <- z[which(z[,"dec"] == break.pts[i]),"anc"]#
			}#
			z <- tmp$z;#
		}#
	}#
	#
	mm <- match(phy$edge[,2], z[,"dec"]);#
# Plot tree with purdy colours and labelled nodes (to better map between tree and table)#
	if (plotTree)#
	{#
		dev.new();#
		margin <- FALSE;#
		#
		if (time) {margin=TRUE;}#
		plot.phylo(phy, edge.color=z[mm,"partition"], no.margin=!margin, cex=cex, ...);#
		if (time)#
		{#
			axisPhylo(cex.axis=0.75);#
			mtext("Divergence Time (MYA)", at=(max(get("last_plot.phylo", envir = .PlotPhyloEnv)$xx)*0.5), side = 1, line = 2, cex=0.75);#
		}#
		if (node.labels) # label with stem/node breaks in mind#
		{#
			for (i in  1:length(break.pts))#
			{#
				nodelabels(i, node=labels[i], frame = "c", font = 1, cex=0.5);#
			}#
		}#
	}#
	#
## Due to my current ineptitude in plotting in R, plotting surface is currently [0,1] for#
#  both r and epsilon, even if values of interest are clustered in some subregion.#
	if (plotSurface)#
	{#
		n.pieces <- length(opt.model[,1]);#
		for (k in 1: n.pieces)#
		{	#
	## *** NEED TO MAKE CHECKS IF CURRENT MODEL IS YULE, AND THEN FIGURE HOW TO PLOT IT ***#
		#	if Yule, need different plot type#
			if (fit[[model.id]]$model[k] == "bd")#
			{#
				lik <- make.lik.medusa.part(z[z[,"partition"] == k,,drop=FALSE], model="bd");#
				#
## center these around the MLEs#
				opt.r <- as.numeric(opt.model[k,"r"]);#
				opt.epsilon <- as.numeric(opt.model[k,"epsilon"]);#
				#
				lik.vals <- matrix(nrow=n.points, ncol=n.points);#
				r.vals <- seq(from=(opt.r/10), to=(opt.r*2), length.out=n.points);#
				eps.vals <- seq(from=1e-10, to=1.0, length.out=n.points);#
				#
				for (i in 1:length(r.vals))#
				{#
					for (j in 1:(length(eps.vals))) {lik.vals[i,j] <- lik(pars=c(r.vals[i], eps.vals[j]));}#
				}#
				if (n.pieces > 1) {cat("Completed computing surface for piecewise model #", k, "\n", sep="");}#
				#
# Contour plot#
				plot.new()#
				#
				max.lik <- as.numeric(opt.model[k,"LnLik.part"])  # MLE#
				#
				lines <- c(max.lik-0.5, max.lik-1, max.lik-2, max.lik-3, max.lik-4, max.lik-5, max.lik-10, max.lik-50, max.lik-100)#
				contour(lik.vals, levels=lines, labels=c(0.5, 1, 2, 3, 4, 5, 10, 50, 100), axes=FALSE, xlab="r (b-d)", ylab="epsilon (d/b)", method="flattest")#
				tics<-floor(c(1, n.points/4, n.points/2, n.points*3/4, n.points));#
				axis(1, at=c(0, 0.25, 0.5, 0.75, 1), labels=round(r.vals[tics], 3));#
				axis(2, at=c(0, 0.25, 0.5, 0.75, 1), labels=round(eps.vals[tics], 3));#
				points(x=opt.r*(1/(min(r.vals)+max(r.vals))), y=opt.epsilon*(1/(min(eps.vals)+max(eps.vals))), pch=16, col="black"); # inferred ML values#
				if (n.pieces > 1 && printTitle) {title(main=paste("Piecewise Birth-Death Model #", k, sep=""));}#
			} else {#
				lik <- make.lik.medusa.part(z[z[,"partition"] == k,,drop=FALSE], model="yule");#
				#
				opt.r <- as.numeric(opt.model[k,"r"]);#
				lik.vals <- numeric(n.points);#
				r.vals <- seq(from=0, to=0.05, length.out=n.points);#
#				r.vals <- seq(from=(opt.r/10), to=(opt.r*2), length.out=n.points);#
				#
				for (i in 1:length(r.vals))#
				{#
					lik.vals[i] <- lik(pars=r.vals[i]);#
				}#
				if (n.pieces > 1) {cat("Completed computing surface for piecewise model #", k, "\n", sep="");}#
				#
				max.lik <- as.numeric(opt.model[k,"LnLik.part"]);  # MLE#
				#
				plot(r.vals, lik.vals, xlab="r (b-d)", ylab="Log-Likelihood", type="l");#
				points(x=opt.r, y=max.lik, pch=16, col="black");#
				if (n.pieces > 1 && printTitle) {title(main=paste("Piecewise Yule Model #", k, sep=""));}#
			}#
		}#
	}#
	treeParameters <- list(z=z, edge.colour=mm, break.pts=break.pts, phy=phy, labels=labels);#
}#
#
#
## Prints out a table of likelihoods, parameters, and aic scores#
calculate.model.fit.summary <- function (models, phy, plotFig, fig.title=NULL, threshold, ...)#
{#
	tmp <- matrix(nrow=(length(models)), ncol=6);#
	colnames(tmp) <- c("N.Models", "Shift.Node", "N.Param", "Ln.Lik", "aic", "aicc");#
	#
	w.aic <- numeric(length(models));#
	w.aicc <- numeric(length(models));#
	cut.at <- character(length(models));#
	model <- character(length(models));#
	#
	for (i in 1:length(tmp[,1]))#
	{#
		tmp[i,] <- c(i, as.integer(models[[i]]$split.at[i]), models[[i]]$num.par, models[[i]]$lnLik, models[[i]]$aic, models[[i]]$aicc);#
		cut.at[i] <- models[[i]]$cut.at[i];#
		model[i] <- models[[i]]$model[i];#
	}#
	cut.at[1] <- "NA";#
	#
	all.res <- as.data.frame(tmp);#
	#
	if (threshold == 0)#
	{#
		w.aic <- round(calculate.model.weights(all.res$aic), digits=5);#
		w.aicc <- round(calculate.model.weights(all.res$aicc), digits=5);#
		all.res <- cbind(all.res[,c(1:2)], Cut.at=cut.at, Model=model, all.res[,c(3:5)], w.aic=w.aic$w, aicc=all.res$aicc, w.aicc=w.aicc$w);#
	} else {#
		all.res <- cbind(all.res[,c(1:2)], Cut.at=cut.at, Model=model, all.res[,c(3:6)]);#
	}#
	#
	all.res[1,2] <- NA # root node for base model#
	#
	if (plotFig)#
	{#
		dev.new();#
		plotModelFit(all.res);#
		if (!is.null(fig.title)) {title(main=fig.title, cex.main=0.75);}#
	}#
	return(all.res);#
}#
#
#
## Self explanatory#
## These are meaningless when using a threshold criterion#
calculate.model.weights <- function (fit)#
{#
	best <- min(fit);#
	delta <- fit-best;#
	sumDelta <- sum(exp(-0.5 * delta));#
	w <- (exp(-0.5 * delta)/sumDelta);#
	#
	results <- data.frame(fit=fit,delta=delta,w=w);#
	#
	return(results);#
}#
#
#
## Create a plot of model-fit vs. model-size#
plotModelFit <- function (all.res)#
{#
	ylim <- c(min(all.res[,"aic"],all.res[,"aicc"]), max(all.res[,"aic"],all.res[,"aicc"]));#
	plot(all.res[,"N.Models"],all.res[,"aicc"], xlab="Number of Piecewise Models", ylab="Model Fit", ylim=ylim, type="l", col="blue");#
	points(all.res[,"N.Models"],all.res[,"aicc"], col="blue", pch=21, bg="white");#
	points(all.res[,"N.Models"],all.res[,"aic"], col="black", type="l");#
	points(all.res[,"N.Models"],all.res[,"aic"], col="black", pch=21, bg="white");#
	#
	legend("topleft", c("aicc","aic"), pch=21, pt.bg="white", lty=1, col=c("blue", "black"), inset = .05, cex=0.75, bty="n"); # 'bottomright' also works#
}
## Function to prune tree using 'richness' information, assumed to have minimally two columns, "taxon" and "n.taxa"#
##   Perhaps relax on these column names, may cause too many problems#
## May also include 'exemplar' column; in that case, rename relevant tip.label before pruning.#
prune.tree.merge.data <- function (phy, richness, verbose)#
{#
# Rename exemplar taxa with taxon name in richness file#
	if (!is.null(richness$exemplar))#
	{#
# Change relevant tip.labels in phy; individual 'exemplar' may be NA, use original tip.label.#
# Ordering in richness file should NOT be assumed to match order of tip.labels#
		i.na <- is.na(richness$exemplar);#
		phy$tip.label[match(richness$exemplar[!i.na], phy$tip.label)] <- as.character(richness$taxon[!i.na]);#
	}#
	#
# make sure things are in the correct order and of correct format#
	if (length(richness[1,]) == 2)#
	{#
		if (colnames(richness)[1] != "taxon" || colnames(richness)[2] != "n.taxa")#
		{#
			if (class(richness[,1]) == "factor" & class(richness[,2]) == "integer")#
			{#
				colnames(richness) = c("taxon", "n.taxa");#
			} else if (class(richness[,1]) == "integer" & class(richness[,2]) == "factor")#
			{#
				colnames(richness) = c("n.taxa", "taxon");#
			} else {#
				cat("turboMEDUSA thinks your richness data is in an incorrect format. See ?runTurboMEDUSA.\n")#
				stop;#
			}#
		}#
	}#
	#
# Prune tree down to lineages with assigned richnesses#
	temp <- richness[, "n.taxa"];#
	names(temp) <- richness[, "taxon"];#
	pruned <- treedata(phy, temp, warnings=verbose)  # geiger function calling ape (namecheck)#
	#
# checking for typos#
	if (length(pruned$phy$tip.label) == 0) {#
		cat("\n\nWARNING: turboMEDUSA encountered a serious error. Tree has no tips after processing richness information! \nIt is likely that an incorrect richness file is being used. \nAnalysis cannot proceed. Please examine the information below to identify the error.\\nn");#
		cat("\nTree tip labels:\n");#
		print(phy$tip.label);#
		cat("\nRichness taxon labels:\n");#
		print(as.character(richness[, "taxon"]));#
		stop;#
	} else if (length(phy$tip.label) != length(pruned$phy$tip.label)) {#
		cat("turboMEDUSA thinks there is a typo in either the tree or richness files, as one or more tips were dropped from the tree.\n");#
		stop;#
	}#
#
	phy <- pruned$phy;#
# Check the tree#
	#	plotNN(phy)					# Node numbers (ape-style) plotted#
	#
	return(list(phy=phy, richness=richness));#
}#
#
#
## Original default was to fit 20 models (or less if the tree was small).#
## Changing to a stop-criterion (stop="model.limit") e.g. when k = n-1 (i.e. when denominator of aicc correction is undefined).#
## k <- (3*i-1) # when both birth and death are estimated, where i is the number of piecewise models#
  ## This occurs when i = n/3#
  ## If Yule, max i = n/2#
## n <- (2*num.taxa - 1) == (2*length(richness[,1]) - 1) # i.e. total number of nodes in tree (internal + pendant)#
## Alternatively use aicc threshold itself as a stopping criterion (stop="threshold").#
# AICc = AIC + 2*k*(k+1)/(n-k-1);#
get.max.model.limit <- function (richness, model.limit, model, stop, verbose)#
{#
	samp.size <- (2*length(richness[,1]) - 1)#
	if (model == "bd" || model == "mixed")#
	{#
		max.model.limit <- as.integer(samp.size/3) - ((!(samp.size %% 3)) * 1);#
	} else {#
		max.model.limit <- as.integer(samp.size/2) - ((!(samp.size %% 2)) * 1);#
	}#
	#
	if (stop == "model.limit")#
	{#
		if (model.limit > max.model.limit) {model.limit <- max.model.limit;}#
	} else {#
		model.limit <- max.model.limit;#
	}#
	#
	if (verbose)#
	{#
		cat("\nLimiting consideration to a maximum of ", model.limit, " piecewise", sep="");#
		if (model == "bd")#
		{#
			cat(" birth-death models")#
		} else if (model == "mixed")#
		{#
			cat(" mixed models")#
		} else {#
			cat(" pure-birth (Yule) models");#
		}#
		if (stop == "threshold") {cat(" (or until threshold is not satisfied)");}#
		cat(".\n\n")#
	}#
	#
	return(model.limit);#
}#
#
#
## Fitted curve from random b-d simulations#
## Value corresponds to 95th percentile of AICc(split) - AICc(no-split) for no-split simulations#
## x-shifted power function#
get.threshold <- function (x)#
{#
	a = -3.5941052380332650E+01;#
	b =  6.7372587299747000E+00;#
	c = -1.0061508340754866E-01;#
	Offset =  2.7516678664333408E+01;#
	y <- a * (x-b)^c + Offset;#
	if (y < 0) y <- 0;#
	return(y);#
}#
#
#
## The make.cache.medusa function is like the first half of the original splitEdgeMatrix().#
## It works through and reorders the edges, then works out start and end times of these#
## based on the phylogeny's branching times.#
###
## In addition, every node's descendants are also calculated.  The element 'desc' is a list.#
## $desc[i] contains the indices within $edge, $t.start, etc., of all descendants of node 'i'#
## (in ape node numbering format).#
make.cache.medusa <- function (phy, richness, all.nodes, mc, num.cores)#
{#
	n.tips <- length(phy$tip.label);#
	n.int <- nrow(phy$edge) - n.tips;#
	#
## Ape numbers the tips first#
	i.int <- seq_len(n.int);#
	interior <- phy$edge[,2] %in% phy$edge[,1];#
	bt <- branching.times(phy);#
	#
# Consider only internal edges first#
	edges.int <- phy$edge[interior,];#
	colnames(edges.int) <- c("anc", "dec");#
	#
	t.0 <- bt[match(edges.int[,1], (n.tips+1):max(edges.int))];#
	t.1 <- c(t.0[i.int] - phy$edge.length[interior]);#
	#
	z.internal <- cbind(edges.int, t.0, t.1, t.len=t.0 - t.1,#
		n.0=rep(1, n.int), n.t=rep(NA, n.int));#
	#
# Now, pendant edges; #
	edges.pendant <- phy$edge[match(seq_len(n.tips), phy$edge[,2]),];#
	colnames(edges.pendant) <- c("anc", "dec");#
	#
	t.0 <- bt[match(edges.pendant[,1], (n.tips+1):max(edges.pendant))];#
	t.1 <- rep(0, n.tips);#
# cannot assume richness ordering necessarily matches that of tip labels#
	ext.richness <- richness$n.taxa[match(phy$tip.label, richness$taxon)];#
	#
	z.pendant <- cbind(edges.pendant, t.0, t.1, t.len=t.0 - t.1,#
		n.0=rep(1, n.tips), n.t=ext.richness);#
	#
	z <- rbind(z.internal, z.pendant);#
	z <- cbind(z,partition=rep(1, length(z[,1]))); # Stores piecewise model structure#
	rownames(z) <- NULL;#
	#
# Used for identifying descendant nodes below i.e. tracking breakpoints#
	all.edges <- as.matrix(z[,c("anc","dec")]);#
	desc.stem <- list();#
	desc.node <- list();#
	#
	if (mc)#
	{#
		desc.stem <- mclapply(seq_len(max(all.edges)), descendants.cutAtStem.idx, all.edges=all.edges, mc.cores=num.cores);#
		desc.node <- mclapply(seq_len(max(all.edges)), descendants.cutAtNode.idx, all.edges=all.edges, mc.cores=num.cores);#
	} else {#
		desc.stem <- lapply(seq_len(max(all.edges)), descendants.cutAtStem.idx, all.edges=all.edges);#
		desc.node <- lapply(seq_len(max(all.edges)), descendants.cutAtNode.idx, all.edges=all.edges);#
	}#
	#
	for (i in 1:length(desc.node))#
	{#
		if (length(desc.node[[i]]) == 0) # tips#
		{#
			desc.node[[i]] = descendants.cutAtStem.idx(node.list=i, all.edges=all.edges)#
		}#
	}#
	#
## Needed downstream; don't recalculate#
 ## Gives the number of tips associated with an internal node; determines whether a node is 'virgin' or not#
	num.tips <- list()#
	if (mc)#
	{#
		num.tips <- mclapply(all.nodes, get.num.tips, phy=phy, mc.cores=num.cores);#
	} else {#
		num.tips <- lapply(all.nodes, get.num.tips, phy=phy);#
	}#
	#
	res <- list(z=z, desc.stem=desc.stem, desc.node=desc.node, num.tips=num.tips);#
	return(res);#
}#
#
#
## Needed for determining whther nodes are virgin nodes#
get.num.tips <- function (node, phy)#
{#
	n <- length(node.leaves(phy,node));#
	return(n);#
}#
#
#
## This generates the indices of all descendants of a node, using ape's edge matrix.#
## Deals with row numbers of the edge matrix rather than node numbers of the tree.#
descendants.cutAtStem <- function (node, all.edges)#
{#
	ans <- numeric();#
	ans <- node;#
	repeat {#
		node <- all.edges[all.edges[,1] %in% node,2];#
		if (length(node) > 0)#
		{#
			ans <- c(ans, node);#
		} else {break;}#
	}#
	return(unlist(ans));#
}#
#
#
## The function 'descendants' returns the indices of all descendants within the edge matrix.#
descendants.cutAtStem.idx <- function (node.list, all.edges)#
{#
	which(all.edges[,1] == node.list | all.edges[,2] %in% descendants.cutAtStem(node.list, all.edges));#
}#
#
#
## This generates the indices of all descendants of a node, using ape's edge matrix.#
## Deals with row numbers of the edge matrix rather than node numbers of the tree.#
descendants.cutAtNode <- function (node, all.edges)#
{#
	ans <- numeric();#
	repeat {#
		node <- all.edges[all.edges[,1] %in% node,2];#
		if (length(node) > 0)#
		{#
			ans <- c(ans, node);#
		} else {break;}#
	}#
	return(unlist(ans));#
}#
#
#
## The function 'descendants' returns the indices of all descendants within the edge matrix.#
descendants.cutAtNode.idx <- function (node.list, all.edges)#
{#
	which(all.edges[,1] == node.list | all.edges[,2] %in% descendants.cutAtNode(node.list, all.edges));#
}
runTurboMEDUSA(mazama.tre, shiftCut="both")
plotNN(mazama.tre)
plotNN(mazama.tre) -> res
runTurboMEDUSA(mazama.tre, shiftCut="both") -> res
runTurboMEDUSA(mazama.tre, shiftCut="both", model.limit=40) -> res
foo <- extract.clade(mazama.tre, 56)
plotNN(foo)
runTurboMEDUSA(foo, shiftCut="both", model.limit=40) -> res
summarizeTurboMEDUSA(res)
log(8)
log(8)/.8
log(8)/.9
log(8)/0.
log(8)/0.9
log(8)/0.8
z
load("/Users/josephwb/Projects/R_working/turboMEDUSA/turboMEDUSA/data/whales.RData")
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="both", model.limit=40) -> res
ls()
load("/Users/josephwb/Projects/R_working/turboMEDUSA/turboMEDUSA/tmp.rda")
runTurboMEDUSA(tmp$phy, tmp$richness, shiftCut="both", model.limit=40) -> res
summarizeTurboMEDUSA(res)
plotNN(res$phy, time=F)
plotNN(res$phy, time=F, margin=F)
foo <- extract.clade(res$phy, node=458)
plotNN(foo)
foo
attributes(foo)
foo$edge.length
foo$edge
min(foo$edge.length)
?plot.phylo
plotNN(foo, type="r")
plotNN(foo, type="r", label.offset=0)
runTurboMEDUSA(foo, shiftCut="both", model.limit=40) -> res
runTurboMEDUSA(foo, shiftCut="node", model.limit=40) -> res
runTurboMEDUSA(foo, shiftCut="stem", model.limit=40) -> res
runTurboMEDUSA(foo, shiftCut="both", model.limit=40) -> res
runTurboMEDUSA(foo, shiftCut="stem", model.limit=40) -> res
summarizeTurboMEDUSA(res, model=20, type="radial")
summarizeTurboMEDUSA(res, model=10, type="radial")
plotNN(foo, type="radial")
plotNN(foo, type="radial", label.offset=0)
summarizeTurboMEDUSA(res, model=10, type="radial")
foo$edge
foo
summarizeTurboMEDUSA(res, model=10)
ls()
phy <- tmp$phy
richness <- tmp$richness
model.limit=20; stop="model.limit"; model="mixed";#
	criterion="aicc"; shiftCut="both"; initialR=0.05; initialE=0.5; plotFig=FALSE; nexus=FALSE;#
	verbose=TRUE; mc=FALSE; num.cores=NULL
phy
	if (nexus) phy <- read.nexus(phy);#
	if (is.null(richness))  # Assume tree represents single species tips and is completely sampled#
	{#
		richness <- data.frame(taxon=phy$tip.label, n.taxa=1);#
	} else {#
## Before determining model.limit, prune tree as necessary (from 'taxon' information in 'richness')#
		phyData <- prune.tree.merge.data(phy=phy, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	}
phy
richness
length(richness[,1])
length(tmp$richness[,1])
length(phy$tip.label)
	if (nexus) phy <- read.nexus(phy);#
	if (is.null(richness))  # Assume tree represents single species tips and is completely sampled#
	{#
		richness <- data.frame(taxon=phy$tip.label, n.taxa=1);#
	} else {#
## Before determining model.limit, prune tree as necessary (from 'taxon' information in 'richness')#
		phyData <- prune.tree.merge.data(phy=phy, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	}#
	#
## Limit on number of piecewise models fitted; based on tree size, aicc correction factor, #
## and flavour of model fitted (i.e. # parameters estimated; birth-death or pure-birth)#
	model.limit <- get.max.model.limit(richness=richness, model.limit=model.limit, model=model, stop=stop, verbose=verbose);#
	#
## Determine correct AICc threshold from tree size (based on simulations)#
 ## Should be used for interpreting model-fit#
	threshold <- get.threshold(length(phy$tip.label));#
	cat("Appropriate AICc threshold for tree of ", length(phy$tip.label), " tips is: ", threshold, ".\n\n", sep="");#
	#
## Store pertinent information: branch times, richness, descendants#
	cat("Preparing data for analysis... ");#
	#
## Keep track of all nodes, internal and pendant (for keeping track of breakpoints)#
	pend.nodes <- seq_len(length(phy$tip.label));   # Calculate pendant splits just once, keep track through various models#
	int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
	root.node <- length(phy$tip.label) + 1;#
	all.nodes <- c(pend.nodes, root.node, int.nodes);#
	#
## The important bits. Set up z, get descendants and number of tips per node#
	obj <- make.cache.medusa(phy=phy, richness=richness, all.nodes=all.nodes, mc=mc, num.cores=num.cores);#
	#
	desc <- list(desc.stem=obj$desc.stem, desc.node=obj$desc.node);#
	z <- obj$z;#
	z.orig <- z; # Save for summarizing models later#
	num.tips <- obj$num.tips;#
	#
	cat("done.\n");
z
length(phy$tip.label)
length(richness[,1])
## Pre-fit pendant edges so these values need not be re(re(re))calculated; amounts to ~25% of all calculations#
 ## Will show particular performance gain for edges with many fossil observations#
	cat("Optimizing parameters for pendant edges... ");#
	tips <- NULL;#
# Will always be shiftCut="stem"; if mixed model, keep only best fit and throw out other in medusa.ml.prefit#
	if (mc)#
	{#
		tips <- mclapply(pend.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion, mc.cores=num.cores);#
	} else {#
		tips <- lapply(pend.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion);#
	}#
	cat("done.\n");#
	#
## Pre-fit virgin internal nodes; should deliver performance gain for early models, and especially for large trees#
 ## Remain useful until a spilt is accepted within the clade#
 ## Need to incorporate cutAtStem here#
	cat("Pre-calculating parameters for virgin internal nodes... ");#
	virgin.stem <- list(); virgin.node <- list();#
	if (mc)#
	{#
		if (shiftCut == "stem" || shiftCut == "both")#
		{#
			virgin.stem <- mclapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion, mc.cores=num.cores);#
		}#
		if (shiftCut == "node" || shiftCut == "both")#
		{#
			virgin.node <- mclapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="node", criterion=criterion, mc.cores=num.cores);#
		}#
	} else {#
		if (shiftCut == "stem" || shiftCut == "both")#
		{#
			virgin.stem <- lapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion);#
		}#
		if (shiftCut == "node" || shiftCut == "both")#
		{#
			virgin.node <- lapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="node", criterion=criterion);#
		}#
	}#
	virgin.nodes <- list(stem=virgin.stem, node=virgin.node);#
	cat("done.\n\n");#
	#
	prefit <- list(tips=tips, virgin.nodes=virgin.nodes);
whales
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="stem", model.limit=40) -> res
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=40) -> res
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=40, model="yule") -> res
plotNN(whales$phy, label.offset=0, type="r")
plotNN(whales$phy, label.offset=0, type="c")
plotNN(whales$phy, label.offset=0, type="c", margin=F)
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=37, model="yule") -> res
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
res
summarizeTurboMEDUSA(res, time=FALSE, margin=FALSE, type="c")
summarizeTurboMEDUSA(res, time=FALSE, margin=FALSE, type="c", model=37)
plotNN(whales$phy, label.offset=0, type="r", margin=F)
plotNN(whales$phy, label.offset=0, margin=F)
summarizeTurboMEDUSA(res, time=FALSE, margin=FALSE, type="c", model=37)
summarizeTurboMEDUSA(res, time=FALSE, margin=FALSE, model=37)
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
summarizeTurboMEDUSA(res, time=FALSE, margin=FALSE, model=37, plotTree=F)
length(whales$phy$tip.label)
phyData <- prune.tree.merge.data(phy=whales$phy, richness=whales$richness, verbose=verbose);
phy
ls()
		phy <- phyData$phy;
		richness <- phyData$richness;
phy
richness
plotNN(phy, margin=F)
summarizeTurboMEDUSA(res, time=FALSE, margin=FALSE, model=37, time=F)
summarizeTurboMEDUSA
summarizeTurboMEDUSA(res, time=FALSE, margin=FALSE, model=37, margin=F)
summarizeTurboMEDUSA(res, time=FALSE, margin=FALSE, model=37, margin=F, label.offset=0.5)
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
traceback()
all.nodes
## Only used for base model#
medusa.ml.initial <- function (z, initialR, initialE, model)#
{#
	rootnode <- min(z[,"anc"]);#
	obj <- medusa.ml.fit.partition(partition=1, z=z, sp=c(initialR, initialE), model=model);#
	#
	model.fit <- calculate.model.fit(fit=obj, z=z);#
	#
	return(list(par=matrix(obj$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=obj$lnLik, #
	   lnLik=obj$lnLik, split.at=rootnode, aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3], cut.at="node"));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted.#
## shiftCut can only be "stem" or "node" (not "both"), as both are evaluated separately#
medusa.ml.prefit <- function (node, z, desc, initialR, initialE, model, shiftCut, criterion)#
{#
	fitted.bd <- NULL;#
	fitted.yule <- NULL;#
#	fit <- NULL;#
	#
## if model is mixed, grab the optimally fitted one, drop the other; it is cutAtStem that matters, as it is the sum of 2 break likelihoods#
  ## optimal alone may be different than optimal in tandem#
	if (shiftCut == "stem")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.stem <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.stem, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "stem";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.stem <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.stem, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "stem";#
		}#
	} else if (shiftCut == "node")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.node <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.node, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "node";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.node <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.node, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "node";#
		}#
	}#
## Check which flavour of model fits best#
	if (is.null(fitted.bd) & !is.null(fitted.yule))#
	{#
		return(fitted.yule);#
	} else if (is.null(fitted.yule) & !is.null(fitted.bd)) {#
		return(fitted.bd);#
	} else {#
## Dealing with a 'mixed' model here; need to consider number of parameters.#
		bd.model.fit <- calculate.model.fit(fit=fitted.bd, z=z);#
		yule.model.fit <- calculate.model.fit(fit=fitted.yule, z=z);#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		if (is.nan(yule.model.fit[[element]]))#
		{#
			return(fitted.bd);#
		} else if (bd.model.fit[[element]] < yule.model.fit[[element]])#
		{#
			return(fitted.bd);#
		} else {#
			return(fitted.yule);#
		}#
	}#
}#
#
#
#
#
#
#
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
	new.part <- z[z[,"partition"] == partition,,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
	if (length(new.part) == 0)#
	{#
		cat("\nSaved time, bitches!\n")#
		par <- c(NA, NA);#
		return(list(par=par, lnLik=-Inf));#
	} else {#
# Construct likelihood function:#
		lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);#
		foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
		#
		if (model == "bd")#
		{#
			fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
			#
			if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
			#
			return(list(par=exp(fit$par), lnLik=-fit$value));#
		} else {#
			# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
			# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
			# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
			# best.guess2 <- log(node.richness) / #
			#
			# fit <- nlm(log(sp[1]), f=foo)#
			# par <- c(exp(fit$estimate), NA);#
			# return(list(par=par, lnLik=-fit$minimum));#
			#
			fit <- nlminb(log(sp[1]), objective=foo, upper=log(50), control=list(maxiter=1000))#
			par <- c(exp(fit$par), NA);#
			return(list(par=par, lnLik=-fit$objective));#
	#
			# fit <- optimize(f=foo, interval=c(-25, 1));#
			# par <- c(exp(fit$minimum), NA);#
			# return(list(par=par, lnLik=-fit$objective));#
		}#
	}#
}#
#
#
#
#
#
#
## Split the edge matrix 'z' by adding a partition rooted at node 'node'.#
##   Note: in original MEDUSA parlance, this is cutAtStem=T.#
## The list 'desc' is a list of descendants (see make.cache.medusa, above).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
## This is where 'shiftCut' matters#
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, or mixed models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
## fit1 model is already logged; only need to record fit2 model, and only non-prefitted nodes#
medusa.ml.update <- function (node, z, desc, fit, prefit, num.tips, root.node, model, criterion, shiftCut)#
{#
## various combinations possible#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" || shiftCut == "both" || node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		obj.stem <- medusa.split(node=node, z=z, desc=desc, shiftCut="stem");#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'stem', bitches! Working on node #", node)#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			cat("\ntrying to return fit...")#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="yule");#
			} else {#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="bd");#
			}#
		} else {#
			fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model=model);#
			fit1.stem$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else { # novel shift#
			fit2.stem.bd <- NULL;#
			fit2.stem.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.stem.yule <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="yule");#
				fit2.stem.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.stem.bd <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="bd");#
				fit2.stem.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.stem.bd))#
			{#
				fit2.stem <- fit2.stem.yule;#
			} else if (is.null(fit2.stem.yule)) {#
				fit2.stem <- fit2.stem.bd;#
			} else {#
## Considering both places for a shift#
				fit2.stem.bd.val <- calculate.model.fit(fit=fit2.stem.bd, z=z);#
				fit2.stem.yule.val <- calculate.model.fit(fit=fit2.stem.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.stem.bd.val[[element]] < fit2.stem.yule.val[[element]])#
				{#
					fit2.stem <- fit2.stem.bd;#
				} else {#
					fit2.stem <- fit2.stem.yule;#
				}#
			}#
		}#
	}#
	if ((shiftCut == "node" || shiftCut == "both") && !(node < root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		obj.node <- medusa.split(node=node, z=z, desc=desc, shiftCut="node");#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
		#
		#
		# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'node', bitches! Working on node #", node)#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="yule");#
				fit1.node$model <- "yule";#
			} else {#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="bd");#
				fit1.node$model <- "bd";#
			}#
		} else {#
			fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model=model);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.node <- prefit$tips[[node]];#
		} else if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		}#
		else { # novel shift#
			fit2.node.bd <- NULL;#
			fit2.node.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.node.yule <- medusa.ml.fit.partition(aff[2], z.node, sp, model="yule");#
				fit2.node.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.node.bd <- medusa.ml.fit.partition(aff[2], z.node, sp, model="bd");#
				fit2.node.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.node.bd))#
			{#
				fit2.node <- fit2.node.yule;#
			} else if (is.null(fit2.node.yule)) {#
				fit2.node <- fit2.node.bd;#
			} else {#
## Considering both places for a shift#
				fit2.node.bd.val <- calculate.model.fit(fit=fit2.node.bd, z=z);#
				fit2.node.yule.val <- calculate.model.fit(fit=fit2.node.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.node.bd.val[[element]] < fit2.node.yule.val[[element]])#
				{#
					fit2.node <- fit2.node.bd;#
				} else {#
					fit2.node <- fit2.node.yule;#
				}#
			}	#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par);#
		stem.fit <- calculate.model.fit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par);#
		node.fit <- calculate.model.fit(fit=node.val, z=z);#
		#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
#			cat("Stem wins!\n");#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
#			cat("Node wins!\n");#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculate.model.fit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
#
#
#
#
#
#
#
## make.lik.medusa.part: generate a likelihood function for a single partition.#
make.lik.medusa.part <- function (partition, model)#
{#
# Handle internal and pendant edges separately#
	is.int <- is.na(partition[,"n.t"]);#
	is.pend <- !is.int;#
	#
	n.int <- sum(is.int);#
	n.pend <- sum(is.pend);#
	#
## Internal and pendant calculations differ; split'em up#
	int  <- partition[is.int,,drop=FALSE];#
	pend <- partition[is.pend,,drop=FALSE];#
	#
	sum.int.t.len <- sum(int[,"t.len"]);  # Simply sum all internal edges#
	int.t.0 <- int[,"t.0"];#
	#
# 'n.0' = Foote's 'a', initial diversity; 'n.t' = Foote's 'n', final diversity#
	pend.n.0 <- pend[,"n.0"]; # Foote's 'a': initial diversity#
	pend.n.t <- pend[,"n.t"]; # Foote's 'n': final diversity#
	pend.t.len <- pend[,"t.len"];#
	#
	if (n.int + n.pend != length(partition[,1])) stop("You messed up, yo.");#
	#
# User may pass in epsilon; don't change it, just estimate r#
	f <- function(pars)#
	{#
		if (model == "bd")#
		{#
			r <- pars[1];#
			epsilon <- pars[2];#
			#
			if (r <= 0 || epsilon <= 0 || epsilon >= 1) {return(-Inf);}#
		} else {#
			#
			r <- pars[1];#
			epsilon <- 0;#
			#
			if (r <= 0 || is.nan(r)) {return(-Inf);}#
		}#
		#
		l.int <- numeric();#
		l.pend <- numeric();#
		#
		if (n.int == 0) {l.int <- 0;} else {#
## Likelihood of internal edges from Rabosky et al. (2007) equation (2.3):#
			l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
		}#
		#
		if (n.pend == 0) {l.pend <- 0} else {#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
			#
			ert <- exp(r * pend.t.len);#
			B <- (ert - 1) / (ert - epsilon); # Equivalently: B <- (bert - b) / (bert - d)#
			#
			l.pend <- sum(log(1 - B) + (pend.n.t - 1)*log(B));#
		}#
		return(l.int + l.pend);#
	}#
}#
#
#
## 'fit' contains '$par' and '$lnlik'#
calculate.model.fit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	#
# Updated for more general models: check how many parameter values != NA#
#	k <- 2 + (3 * (num.models - 1))#
	k <- sum(!is.na(fit$par)) + (num.models - 1); # number of estimated parameters + number of breaks#
	#
	lnLik <- fit$lnLik;#
	#
	aic <- (-2 * lnLik) + (2*k);#
	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
get.b.d <- function (r, epsilon)#
{#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
## Print out tree with ape-style node-numbering#
## Possibly of interest for users to identify numbers of node(s) off interest#
 ## If this is the case, make sure to pass in pruned tree#
plotNN <- function (phy, time=TRUE, margin=TRUE, label.offset=0.5, cex=0.5, ...) #
{#
	phy$node.label <- (length(phy$tip.label) + 1):max(phy$edge);#
	plot.phylo(phy, show.node.label=TRUE, no.margin=!margin, label.offset=label.offset, cex=cex, ...);#
	if (time && !margin) {cat("Cannot plot time axis without a margin.\n");}#
	else if (time && margin) {axisPhylo(cex.axis=0.75)};#
}
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
?pause
## Only used for base model#
medusa.ml.initial <- function (z, initialR, initialE, model)#
{#
	rootnode <- min(z[,"anc"]);#
	obj <- medusa.ml.fit.partition(partition=1, z=z, sp=c(initialR, initialE), model=model);#
	#
	model.fit <- calculate.model.fit(fit=obj, z=z);#
	#
	return(list(par=matrix(obj$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=obj$lnLik, #
	   lnLik=obj$lnLik, split.at=rootnode, aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3], cut.at="node"));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted.#
## shiftCut can only be "stem" or "node" (not "both"), as both are evaluated separately#
medusa.ml.prefit <- function (node, z, desc, initialR, initialE, model, shiftCut, criterion)#
{#
	fitted.bd <- NULL;#
	fitted.yule <- NULL;#
#	fit <- NULL;#
	#
## if model is mixed, grab the optimally fitted one, drop the other; it is cutAtStem that matters, as it is the sum of 2 break likelihoods#
  ## optimal alone may be different than optimal in tandem#
	if (shiftCut == "stem")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.stem <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.stem, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "stem";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.stem <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.stem, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "stem";#
		}#
	} else if (shiftCut == "node")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.node <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.node, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "node";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.node <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.node, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "node";#
		}#
	}#
## Check which flavour of model fits best#
	if (is.null(fitted.bd) & !is.null(fitted.yule))#
	{#
		return(fitted.yule);#
	} else if (is.null(fitted.yule) & !is.null(fitted.bd)) {#
		return(fitted.bd);#
	} else {#
## Dealing with a 'mixed' model here; need to consider number of parameters.#
		bd.model.fit <- calculate.model.fit(fit=fitted.bd, z=z);#
		yule.model.fit <- calculate.model.fit(fit=fitted.yule, z=z);#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		if (is.nan(yule.model.fit[[element]]))#
		{#
			return(fitted.bd);#
		} else if (bd.model.fit[[element]] < yule.model.fit[[element]])#
		{#
			return(fitted.bd);#
		} else {#
			return(fitted.yule);#
		}#
	}#
}#
#
#
#
#
#
#
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
	new.part <- z[z[,"partition"] == partition,,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
	if (length(new.part) == 0)#
	{#
		cat("\nSaved time, bitches!\n")#
		par <- c(NA, NA);#
		return(list(par=par, lnLik=-Inf));#
	} else {#
# Construct likelihood function:#
		lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);#
		foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
		#
		if (model == "bd")#
		{#
			fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
			#
			if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
			#
			return(list(par=exp(fit$par), lnLik=-fit$value));#
		} else {#
			# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
			# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
			# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
			# best.guess2 <- log(node.richness) / #
			#
			# fit <- nlm(log(sp[1]), f=foo)#
			# par <- c(exp(fit$estimate), NA);#
			# return(list(par=par, lnLik=-fit$minimum));#
			#
			fit <- nlminb(log(sp[1]), objective=foo, upper=log(50), control=list(maxiter=1000))#
			par <- c(exp(fit$par), NA);#
			return(list(par=par, lnLik=-fit$objective));#
	#
			# fit <- optimize(f=foo, interval=c(-25, 1));#
			# par <- c(exp(fit$minimum), NA);#
			# return(list(par=par, lnLik=-fit$objective));#
		}#
	}#
}#
#
#
#
#
#
#
## Split the edge matrix 'z' by adding a partition rooted at node 'node'.#
##   Note: in original MEDUSA parlance, this is cutAtStem=T.#
## The list 'desc' is a list of descendants (see make.cache.medusa, above).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
## This is where 'shiftCut' matters#
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, or mixed models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
## fit1 model is already logged; only need to record fit2 model, and only non-prefitted nodes#
medusa.ml.update <- function (node, z, desc, fit, prefit, num.tips, root.node, model, criterion, shiftCut)#
{#
## various combinations possible#
	cat("Attempting to work with node: ", node, "\n")#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" || shiftCut == "both" || node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		obj.stem <- medusa.split(node=node, z=z, desc=desc, shiftCut="stem");#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'stem', bitches! Working on node #", node)#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			cat("\ntrying to return fit...")#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="yule");#
			} else {#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="bd");#
			}#
		} else {#
			fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model=model);#
			fit1.stem$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else { # novel shift#
			fit2.stem.bd <- NULL;#
			fit2.stem.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.stem.yule <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="yule");#
				fit2.stem.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.stem.bd <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="bd");#
				fit2.stem.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.stem.bd))#
			{#
				fit2.stem <- fit2.stem.yule;#
			} else if (is.null(fit2.stem.yule)) {#
				fit2.stem <- fit2.stem.bd;#
			} else {#
## Considering both places for a shift#
				fit2.stem.bd.val <- calculate.model.fit(fit=fit2.stem.bd, z=z);#
				fit2.stem.yule.val <- calculate.model.fit(fit=fit2.stem.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.stem.bd.val[[element]] < fit2.stem.yule.val[[element]])#
				{#
					fit2.stem <- fit2.stem.bd;#
				} else {#
					fit2.stem <- fit2.stem.yule;#
				}#
			}#
		}#
	}#
	if ((shiftCut == "node" || shiftCut == "both") && !(node < root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		obj.node <- medusa.split(node=node, z=z, desc=desc, shiftCut="node");#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
		#
		#
		# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'node', bitches! Working on node #", node)#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="yule");#
				fit1.node$model <- "yule";#
			} else {#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="bd");#
				fit1.node$model <- "bd";#
			}#
		} else {#
			fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model=model);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.node <- prefit$tips[[node]];#
		} else if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		}#
		else { # novel shift#
			fit2.node.bd <- NULL;#
			fit2.node.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.node.yule <- medusa.ml.fit.partition(aff[2], z.node, sp, model="yule");#
				fit2.node.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.node.bd <- medusa.ml.fit.partition(aff[2], z.node, sp, model="bd");#
				fit2.node.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.node.bd))#
			{#
				fit2.node <- fit2.node.yule;#
			} else if (is.null(fit2.node.yule)) {#
				fit2.node <- fit2.node.bd;#
			} else {#
## Considering both places for a shift#
				fit2.node.bd.val <- calculate.model.fit(fit=fit2.node.bd, z=z);#
				fit2.node.yule.val <- calculate.model.fit(fit=fit2.node.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.node.bd.val[[element]] < fit2.node.yule.val[[element]])#
				{#
					fit2.node <- fit2.node.bd;#
				} else {#
					fit2.node <- fit2.node.yule;#
				}#
			}	#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par);#
		stem.fit <- calculate.model.fit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par);#
		node.fit <- calculate.model.fit(fit=node.val, z=z);#
		#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
#			cat("Stem wins!\n");#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
#			cat("Node wins!\n");#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculate.model.fit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
#
#
#
#
#
#
#
## make.lik.medusa.part: generate a likelihood function for a single partition.#
make.lik.medusa.part <- function (partition, model)#
{#
# Handle internal and pendant edges separately#
	is.int <- is.na(partition[,"n.t"]);#
	is.pend <- !is.int;#
	#
	n.int <- sum(is.int);#
	n.pend <- sum(is.pend);#
	#
## Internal and pendant calculations differ; split'em up#
	int  <- partition[is.int,,drop=FALSE];#
	pend <- partition[is.pend,,drop=FALSE];#
	#
	sum.int.t.len <- sum(int[,"t.len"]);  # Simply sum all internal edges#
	int.t.0 <- int[,"t.0"];#
	#
# 'n.0' = Foote's 'a', initial diversity; 'n.t' = Foote's 'n', final diversity#
	pend.n.0 <- pend[,"n.0"]; # Foote's 'a': initial diversity#
	pend.n.t <- pend[,"n.t"]; # Foote's 'n': final diversity#
	pend.t.len <- pend[,"t.len"];#
	#
	if (n.int + n.pend != length(partition[,1])) stop("You messed up, yo.");#
	#
# User may pass in epsilon; don't change it, just estimate r#
	f <- function(pars)#
	{#
		if (model == "bd")#
		{#
			r <- pars[1];#
			epsilon <- pars[2];#
			#
			if (r <= 0 || epsilon <= 0 || epsilon >= 1) {return(-Inf);}#
		} else {#
			#
			r <- pars[1];#
			epsilon <- 0;#
			#
			if (r <= 0 || is.nan(r)) {return(-Inf);}#
		}#
		#
		l.int <- numeric();#
		l.pend <- numeric();#
		#
		if (n.int == 0) {l.int <- 0;} else {#
## Likelihood of internal edges from Rabosky et al. (2007) equation (2.3):#
			l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
		}#
		#
		if (n.pend == 0) {l.pend <- 0} else {#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
			#
			ert <- exp(r * pend.t.len);#
			B <- (ert - 1) / (ert - epsilon); # Equivalently: B <- (bert - b) / (bert - d)#
			#
			l.pend <- sum(log(1 - B) + (pend.n.t - 1)*log(B));#
		}#
		return(l.int + l.pend);#
	}#
}#
#
#
## 'fit' contains '$par' and '$lnlik'#
calculate.model.fit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	#
# Updated for more general models: check how many parameter values != NA#
#	k <- 2 + (3 * (num.models - 1))#
	k <- sum(!is.na(fit$par)) + (num.models - 1); # number of estimated parameters + number of breaks#
	#
	lnLik <- fit$lnLik;#
	#
	aic <- (-2 * lnLik) + (2*k);#
	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
get.b.d <- function (r, epsilon)#
{#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
## Print out tree with ape-style node-numbering#
## Possibly of interest for users to identify numbers of node(s) off interest#
 ## If this is the case, make sure to pass in pruned tree#
plotNN <- function (phy, time=TRUE, margin=TRUE, label.offset=0.5, cex=0.5, ...) #
{#
	phy$node.label <- (length(phy$tip.label) + 1):max(phy$edge);#
	plot.phylo(phy, show.node.label=TRUE, no.margin=!margin, label.offset=label.offset, cex=cex, ...);#
	if (time && !margin) {cat("Cannot plot time axis without a margin.\n");}#
	else if (time && margin) {axisPhylo(cex.axis=0.75)};#
}
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
summarizeTurboMEDUSA(res, time=FALSE, margin=FALSE, model=37, tplotTree=F)
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
traceback()
## Only used for base model#
medusa.ml.initial <- function (z, initialR, initialE, model)#
{#
	rootnode <- min(z[,"anc"]);#
	obj <- medusa.ml.fit.partition(partition=1, z=z, sp=c(initialR, initialE), model=model);#
	#
	model.fit <- calculate.model.fit(fit=obj, z=z);#
	#
	return(list(par=matrix(obj$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=obj$lnLik, #
	   lnLik=obj$lnLik, split.at=rootnode, aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3], cut.at="node"));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted.#
## shiftCut can only be "stem" or "node" (not "both"), as both are evaluated separately#
medusa.ml.prefit <- function (node, z, desc, initialR, initialE, model, shiftCut, criterion)#
{#
	fitted.bd <- NULL;#
	fitted.yule <- NULL;#
#	fit <- NULL;#
	#
## if model is mixed, grab the optimally fitted one, drop the other; it is cutAtStem that matters, as it is the sum of 2 break likelihoods#
  ## optimal alone may be different than optimal in tandem#
	if (shiftCut == "stem")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.stem <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.stem, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "stem";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.stem <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.stem, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "stem";#
		}#
	} else if (shiftCut == "node")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.node <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.node, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "node";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.node <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.node, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "node";#
		}#
	}#
## Check which flavour of model fits best#
	if (is.null(fitted.bd) & !is.null(fitted.yule))#
	{#
		return(fitted.yule);#
	} else if (is.null(fitted.yule) & !is.null(fitted.bd)) {#
		return(fitted.bd);#
	} else {#
## Dealing with a 'mixed' model here; need to consider number of parameters.#
		bd.model.fit <- calculate.model.fit(fit=fitted.bd, z=z);#
		yule.model.fit <- calculate.model.fit(fit=fitted.yule, z=z);#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		if (is.nan(yule.model.fit[[element]]))#
		{#
			return(fitted.bd);#
		} else if (bd.model.fit[[element]] < yule.model.fit[[element]])#
		{#
			return(fitted.bd);#
		} else {#
			return(fitted.yule);#
		}#
	}#
}#
#
#
#
#
#
#
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
	new.part <- z[z[,"partition"] == partition,,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
	if (length(new.part) == 0)#
	{#
		cat("\nSaved time, bitches!\n")#
		par <- c(NA, NA);#
		return(list(par=par, lnLik=-Inf));#
	} else {#
# Construct likelihood function:#
		lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);#
		foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
		#
		if (model == "bd")#
		{#
			fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
			#
			if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
			#
			return(list(par=exp(fit$par), lnLik=-fit$value));#
		} else {#
			# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
			# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
			# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
			# best.guess2 <- log(node.richness) / #
			#
			# fit <- nlm(log(sp[1]), f=foo)#
			# par <- c(exp(fit$estimate), NA);#
			# return(list(par=par, lnLik=-fit$minimum));#
			#
			fit <- nlminb(log(sp[1]), objective=foo, upper=log(50), control=list(maxiter=1000))#
			par <- c(exp(fit$par), NA);#
			return(list(par=par, lnLik=-fit$objective));#
	#
			# fit <- optimize(f=foo, interval=c(-25, 1));#
			# par <- c(exp(fit$minimum), NA);#
			# return(list(par=par, lnLik=-fit$objective));#
		}#
	}#
}#
#
#
#
#
#
#
## Split the edge matrix 'z' by adding a partition rooted at node 'node'.#
##   Note: in original MEDUSA parlance, this is cutAtStem=T.#
## The list 'desc' is a list of descendants (see make.cache.medusa, above).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
## This is where 'shiftCut' matters#
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, or mixed models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
## fit1 model is already logged; only need to record fit2 model, and only non-prefitted nodes#
medusa.ml.update <- function (node, z, desc, fit, prefit, num.tips, root.node, model, criterion, shiftCut)#
{#
## various combinations possible#
	cat("Attempting to work with node: ", node, "\n")#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" || shiftCut == "both" || node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		cat("In 'stem', attempting to work with node: ", node, "\n")#
		obj.stem <- medusa.split(node=node, z=z, desc=desc, shiftCut="stem");#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		cat("Made it through medusa.split.\n")#
		#
# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'stem', bitches! Working on node #", node)#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			cat("\ntrying to return fit...")#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="yule");#
			} else {#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="bd");#
			}#
		} else {#
			fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model=model);#
			fit1.stem$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else { # novel shift#
			fit2.stem.bd <- NULL;#
			fit2.stem.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.stem.yule <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="yule");#
				fit2.stem.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.stem.bd <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="bd");#
				fit2.stem.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.stem.bd))#
			{#
				fit2.stem <- fit2.stem.yule;#
			} else if (is.null(fit2.stem.yule)) {#
				fit2.stem <- fit2.stem.bd;#
			} else {#
## Considering both places for a shift#
				fit2.stem.bd.val <- calculate.model.fit(fit=fit2.stem.bd, z=z);#
				fit2.stem.yule.val <- calculate.model.fit(fit=fit2.stem.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.stem.bd.val[[element]] < fit2.stem.yule.val[[element]])#
				{#
					fit2.stem <- fit2.stem.bd;#
				} else {#
					fit2.stem <- fit2.stem.yule;#
				}#
			}#
		}#
	}#
	if ((shiftCut == "node" || shiftCut == "both") && !(node < root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		obj.node <- medusa.split(node=node, z=z, desc=desc, shiftCut="node");#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
		#
		#
		# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'node', bitches! Working on node #", node)#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="yule");#
				fit1.node$model <- "yule";#
			} else {#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="bd");#
				fit1.node$model <- "bd";#
			}#
		} else {#
			fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model=model);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.node <- prefit$tips[[node]];#
		} else if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		}#
		else { # novel shift#
			fit2.node.bd <- NULL;#
			fit2.node.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.node.yule <- medusa.ml.fit.partition(aff[2], z.node, sp, model="yule");#
				fit2.node.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.node.bd <- medusa.ml.fit.partition(aff[2], z.node, sp, model="bd");#
				fit2.node.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.node.bd))#
			{#
				fit2.node <- fit2.node.yule;#
			} else if (is.null(fit2.node.yule)) {#
				fit2.node <- fit2.node.bd;#
			} else {#
## Considering both places for a shift#
				fit2.node.bd.val <- calculate.model.fit(fit=fit2.node.bd, z=z);#
				fit2.node.yule.val <- calculate.model.fit(fit=fit2.node.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.node.bd.val[[element]] < fit2.node.yule.val[[element]])#
				{#
					fit2.node <- fit2.node.bd;#
				} else {#
					fit2.node <- fit2.node.yule;#
				}#
			}	#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par);#
		stem.fit <- calculate.model.fit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par);#
		node.fit <- calculate.model.fit(fit=node.val, z=z);#
		#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
#			cat("Stem wins!\n");#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
#			cat("Node wins!\n");#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculate.model.fit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
#
#
#
#
#
#
#
## make.lik.medusa.part: generate a likelihood function for a single partition.#
make.lik.medusa.part <- function (partition, model)#
{#
# Handle internal and pendant edges separately#
	is.int <- is.na(partition[,"n.t"]);#
	is.pend <- !is.int;#
	#
	n.int <- sum(is.int);#
	n.pend <- sum(is.pend);#
	#
## Internal and pendant calculations differ; split'em up#
	int  <- partition[is.int,,drop=FALSE];#
	pend <- partition[is.pend,,drop=FALSE];#
	#
	sum.int.t.len <- sum(int[,"t.len"]);  # Simply sum all internal edges#
	int.t.0 <- int[,"t.0"];#
	#
# 'n.0' = Foote's 'a', initial diversity; 'n.t' = Foote's 'n', final diversity#
	pend.n.0 <- pend[,"n.0"]; # Foote's 'a': initial diversity#
	pend.n.t <- pend[,"n.t"]; # Foote's 'n': final diversity#
	pend.t.len <- pend[,"t.len"];#
	#
	if (n.int + n.pend != length(partition[,1])) stop("You messed up, yo.");#
	#
# User may pass in epsilon; don't change it, just estimate r#
	f <- function(pars)#
	{#
		if (model == "bd")#
		{#
			r <- pars[1];#
			epsilon <- pars[2];#
			#
			if (r <= 0 || epsilon <= 0 || epsilon >= 1) {return(-Inf);}#
		} else {#
			#
			r <- pars[1];#
			epsilon <- 0;#
			#
			if (r <= 0 || is.nan(r)) {return(-Inf);}#
		}#
		#
		l.int <- numeric();#
		l.pend <- numeric();#
		#
		if (n.int == 0) {l.int <- 0;} else {#
## Likelihood of internal edges from Rabosky et al. (2007) equation (2.3):#
			l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
		}#
		#
		if (n.pend == 0) {l.pend <- 0} else {#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
			#
			ert <- exp(r * pend.t.len);#
			B <- (ert - 1) / (ert - epsilon); # Equivalently: B <- (bert - b) / (bert - d)#
			#
			l.pend <- sum(log(1 - B) + (pend.n.t - 1)*log(B));#
		}#
		return(l.int + l.pend);#
	}#
}#
#
#
## 'fit' contains '$par' and '$lnlik'#
calculate.model.fit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	#
# Updated for more general models: check how many parameter values != NA#
#	k <- 2 + (3 * (num.models - 1))#
	k <- sum(!is.na(fit$par)) + (num.models - 1); # number of estimated parameters + number of breaks#
	#
	lnLik <- fit$lnLik;#
	#
	aic <- (-2 * lnLik) + (2*k);#
	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
get.b.d <- function (r, epsilon)#
{#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
## Print out tree with ape-style node-numbering#
## Possibly of interest for users to identify numbers of node(s) off interest#
 ## If this is the case, make sure to pass in pruned tree#
plotNN <- function (phy, time=TRUE, margin=TRUE, label.offset=0.5, cex=0.5, ...) #
{#
	phy$node.label <- (length(phy$tip.label) + 1):max(phy$edge);#
	plot.phylo(phy, show.node.label=TRUE, no.margin=!margin, label.offset=label.offset, cex=cex, ...);#
	if (time && !margin) {cat("Cannot plot time axis without a margin.\n");}#
	else if (time && margin) {axisPhylo(cex.axis=0.75)};#
}
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
## Only used for base model#
medusa.ml.initial <- function (z, initialR, initialE, model)#
{#
	rootnode <- min(z[,"anc"]);#
	obj <- medusa.ml.fit.partition(partition=1, z=z, sp=c(initialR, initialE), model=model);#
	#
	model.fit <- calculate.model.fit(fit=obj, z=z);#
	#
	return(list(par=matrix(obj$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=obj$lnLik, #
	   lnLik=obj$lnLik, split.at=rootnode, aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3], cut.at="node"));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted.#
## shiftCut can only be "stem" or "node" (not "both"), as both are evaluated separately#
medusa.ml.prefit <- function (node, z, desc, initialR, initialE, model, shiftCut, criterion)#
{#
	fitted.bd <- NULL;#
	fitted.yule <- NULL;#
#	fit <- NULL;#
	#
## if model is mixed, grab the optimally fitted one, drop the other; it is cutAtStem that matters, as it is the sum of 2 break likelihoods#
  ## optimal alone may be different than optimal in tandem#
	if (shiftCut == "stem")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.stem <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.stem, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "stem";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.stem <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.stem, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "stem";#
		}#
	} else if (shiftCut == "node")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.node <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.node, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "node";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.node <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.node, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "node";#
		}#
	}#
## Check which flavour of model fits best#
	if (is.null(fitted.bd) & !is.null(fitted.yule))#
	{#
		return(fitted.yule);#
	} else if (is.null(fitted.yule) & !is.null(fitted.bd)) {#
		return(fitted.bd);#
	} else {#
## Dealing with a 'mixed' model here; need to consider number of parameters.#
		bd.model.fit <- calculate.model.fit(fit=fitted.bd, z=z);#
		yule.model.fit <- calculate.model.fit(fit=fitted.yule, z=z);#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		if (is.nan(yule.model.fit[[element]]))#
		{#
			return(fitted.bd);#
		} else if (bd.model.fit[[element]] < yule.model.fit[[element]])#
		{#
			return(fitted.bd);#
		} else {#
			return(fitted.yule);#
		}#
	}#
}#
#
#
#
#
#
#
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
	new.part <- z[z[,"partition"] == partition,,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
	if (length(new.part) == 0)#
	{#
		cat("\nSaved time, bitches!\n")#
		par <- c(NA, NA);#
		return(list(par=par, lnLik=-Inf));#
	} else {#
# Construct likelihood function:#
		lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);#
		foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
		#
		if (model == "bd")#
		{#
			fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
			#
			if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
			#
			return(list(par=exp(fit$par), lnLik=-fit$value));#
		} else {#
			# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
			# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
			# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
			# best.guess2 <- log(node.richness) / #
			#
			# fit <- nlm(log(sp[1]), f=foo)#
			# par <- c(exp(fit$estimate), NA);#
			# return(list(par=par, lnLik=-fit$minimum));#
			#
			fit <- nlminb(log(sp[1]), objective=foo, upper=log(50), control=list(maxiter=1000))#
			par <- c(exp(fit$par), NA);#
			return(list(par=par, lnLik=-fit$objective));#
	#
			# fit <- optimize(f=foo, interval=c(-25, 1));#
			# par <- c(exp(fit$minimum), NA);#
			# return(list(par=par, lnLik=-fit$objective));#
		}#
	}#
}#
#
#
#
#
#
#
## Split the edge matrix 'z' by adding a partition rooted at node 'node'.#
##   Note: in original MEDUSA parlance, this is cutAtStem=T.#
## The list 'desc' is a list of descendants (see make.cache.medusa, above).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
## This is where 'shiftCut' matters#
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, or mixed models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
## fit1 model is already logged; only need to record fit2 model, and only non-prefitted nodes#
medusa.ml.update <- function (node, z, desc, fit, prefit, num.tips, root.node, model, criterion, shiftCut)#
{#
## various combinations possible#
	cat("Attempting to work with node: ", node, ". 'shiftCut' = ", shiftCut, "\n")#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" || shiftCut == "both" || node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		cat("In 'stem', attempting to work with node: ", node, "\n")#
		obj.stem <- medusa.split(node=node, z=z, desc=desc, shiftCut="stem");#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		cat("Made it through medusa.split.\n")#
		#
# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'stem', bitches! Working on node #", node)#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			cat("\ntrying to return fit...")#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="yule");#
			} else {#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="bd");#
			}#
		} else {#
			fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model=model);#
			fit1.stem$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else { # novel shift#
			fit2.stem.bd <- NULL;#
			fit2.stem.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.stem.yule <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="yule");#
				fit2.stem.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.stem.bd <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="bd");#
				fit2.stem.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.stem.bd))#
			{#
				fit2.stem <- fit2.stem.yule;#
			} else if (is.null(fit2.stem.yule)) {#
				fit2.stem <- fit2.stem.bd;#
			} else {#
## Considering both places for a shift#
				fit2.stem.bd.val <- calculate.model.fit(fit=fit2.stem.bd, z=z);#
				fit2.stem.yule.val <- calculate.model.fit(fit=fit2.stem.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.stem.bd.val[[element]] < fit2.stem.yule.val[[element]])#
				{#
					fit2.stem <- fit2.stem.bd;#
				} else {#
					fit2.stem <- fit2.stem.yule;#
				}#
			}#
		}#
	}#
	if ((shiftCut == "node" || shiftCut == "both") && !(node < root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		obj.node <- medusa.split(node=node, z=z, desc=desc, shiftCut="node");#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
		#
		#
		# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'node', bitches! Working on node #", node)#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="yule");#
				fit1.node$model <- "yule";#
			} else {#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="bd");#
				fit1.node$model <- "bd";#
			}#
		} else {#
			fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model=model);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.node <- prefit$tips[[node]];#
		} else if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		}#
		else { # novel shift#
			fit2.node.bd <- NULL;#
			fit2.node.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.node.yule <- medusa.ml.fit.partition(aff[2], z.node, sp, model="yule");#
				fit2.node.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.node.bd <- medusa.ml.fit.partition(aff[2], z.node, sp, model="bd");#
				fit2.node.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.node.bd))#
			{#
				fit2.node <- fit2.node.yule;#
			} else if (is.null(fit2.node.yule)) {#
				fit2.node <- fit2.node.bd;#
			} else {#
## Considering both places for a shift#
				fit2.node.bd.val <- calculate.model.fit(fit=fit2.node.bd, z=z);#
				fit2.node.yule.val <- calculate.model.fit(fit=fit2.node.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.node.bd.val[[element]] < fit2.node.yule.val[[element]])#
				{#
					fit2.node <- fit2.node.bd;#
				} else {#
					fit2.node <- fit2.node.yule;#
				}#
			}	#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par);#
		stem.fit <- calculate.model.fit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par);#
		node.fit <- calculate.model.fit(fit=node.val, z=z);#
		#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
#			cat("Stem wins!\n");#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
#			cat("Node wins!\n");#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculate.model.fit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
#
#
#
#
#
#
#
## make.lik.medusa.part: generate a likelihood function for a single partition.#
make.lik.medusa.part <- function (partition, model)#
{#
# Handle internal and pendant edges separately#
	is.int <- is.na(partition[,"n.t"]);#
	is.pend <- !is.int;#
	#
	n.int <- sum(is.int);#
	n.pend <- sum(is.pend);#
	#
## Internal and pendant calculations differ; split'em up#
	int  <- partition[is.int,,drop=FALSE];#
	pend <- partition[is.pend,,drop=FALSE];#
	#
	sum.int.t.len <- sum(int[,"t.len"]);  # Simply sum all internal edges#
	int.t.0 <- int[,"t.0"];#
	#
# 'n.0' = Foote's 'a', initial diversity; 'n.t' = Foote's 'n', final diversity#
	pend.n.0 <- pend[,"n.0"]; # Foote's 'a': initial diversity#
	pend.n.t <- pend[,"n.t"]; # Foote's 'n': final diversity#
	pend.t.len <- pend[,"t.len"];#
	#
	if (n.int + n.pend != length(partition[,1])) stop("You messed up, yo.");#
	#
# User may pass in epsilon; don't change it, just estimate r#
	f <- function(pars)#
	{#
		if (model == "bd")#
		{#
			r <- pars[1];#
			epsilon <- pars[2];#
			#
			if (r <= 0 || epsilon <= 0 || epsilon >= 1) {return(-Inf);}#
		} else {#
			#
			r <- pars[1];#
			epsilon <- 0;#
			#
			if (r <= 0 || is.nan(r)) {return(-Inf);}#
		}#
		#
		l.int <- numeric();#
		l.pend <- numeric();#
		#
		if (n.int == 0) {l.int <- 0;} else {#
## Likelihood of internal edges from Rabosky et al. (2007) equation (2.3):#
			l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
		}#
		#
		if (n.pend == 0) {l.pend <- 0} else {#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
			#
			ert <- exp(r * pend.t.len);#
			B <- (ert - 1) / (ert - epsilon); # Equivalently: B <- (bert - b) / (bert - d)#
			#
			l.pend <- sum(log(1 - B) + (pend.n.t - 1)*log(B));#
		}#
		return(l.int + l.pend);#
	}#
}#
#
#
## 'fit' contains '$par' and '$lnlik'#
calculate.model.fit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	#
# Updated for more general models: check how many parameter values != NA#
#	k <- 2 + (3 * (num.models - 1))#
	k <- sum(!is.na(fit$par)) + (num.models - 1); # number of estimated parameters + number of breaks#
	#
	lnLik <- fit$lnLik;#
	#
	aic <- (-2 * lnLik) + (2*k);#
	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
get.b.d <- function (r, epsilon)#
{#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
## Print out tree with ape-style node-numbering#
## Possibly of interest for users to identify numbers of node(s) off interest#
 ## If this is the case, make sure to pass in pruned tree#
plotNN <- function (phy, time=TRUE, margin=TRUE, label.offset=0.5, cex=0.5, ...) #
{#
	phy$node.label <- (length(phy$tip.label) + 1):max(phy$edge);#
	plot.phylo(phy, show.node.label=TRUE, no.margin=!margin, label.offset=label.offset, cex=cex, ...);#
	if (time && !margin) {cat("Cannot plot time axis without a margin.\n");}#
	else if (time && margin) {axisPhylo(cex.axis=0.75)};#
}
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
## Only used for base model#
medusa.ml.initial <- function (z, initialR, initialE, model)#
{#
	rootnode <- min(z[,"anc"]);#
	obj <- medusa.ml.fit.partition(partition=1, z=z, sp=c(initialR, initialE), model=model);#
	#
	model.fit <- calculate.model.fit(fit=obj, z=z);#
	#
	return(list(par=matrix(obj$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=obj$lnLik, #
	   lnLik=obj$lnLik, split.at=rootnode, aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3], cut.at="node"));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted.#
## shiftCut can only be "stem" or "node" (not "both"), as both are evaluated separately#
medusa.ml.prefit <- function (node, z, desc, initialR, initialE, model, shiftCut, criterion)#
{#
	fitted.bd <- NULL;#
	fitted.yule <- NULL;#
#	fit <- NULL;#
	#
## if model is mixed, grab the optimally fitted one, drop the other; it is cutAtStem that matters, as it is the sum of 2 break likelihoods#
  ## optimal alone may be different than optimal in tandem#
	if (shiftCut == "stem")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.stem <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.stem, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "stem";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.stem <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.stem, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "stem";#
		}#
	} else if (shiftCut == "node")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.node <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.node, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "node";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.node <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.node, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "node";#
		}#
	}#
## Check which flavour of model fits best#
	if (is.null(fitted.bd) & !is.null(fitted.yule))#
	{#
		return(fitted.yule);#
	} else if (is.null(fitted.yule) & !is.null(fitted.bd)) {#
		return(fitted.bd);#
	} else {#
## Dealing with a 'mixed' model here; need to consider number of parameters.#
		bd.model.fit <- calculate.model.fit(fit=fitted.bd, z=z);#
		yule.model.fit <- calculate.model.fit(fit=fitted.yule, z=z);#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		if (is.nan(yule.model.fit[[element]]))#
		{#
			return(fitted.bd);#
		} else if (bd.model.fit[[element]] < yule.model.fit[[element]])#
		{#
			return(fitted.bd);#
		} else {#
			return(fitted.yule);#
		}#
	}#
}#
#
#
#
#
#
#
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
	new.part <- z[z[,"partition"] == partition,,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
	if (length(new.part) == 0)#
	{#
		cat("\nSaved time, bitches!\n")#
		par <- c(NA, NA);#
		return(list(par=par, lnLik=-Inf));#
	} else {#
# Construct likelihood function:#
		lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);#
		foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
		#
		if (model == "bd")#
		{#
			fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
			#
			if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
			#
			return(list(par=exp(fit$par), lnLik=-fit$value));#
		} else {#
			# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
			# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
			# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
			# best.guess2 <- log(node.richness) / #
			#
			# fit <- nlm(log(sp[1]), f=foo)#
			# par <- c(exp(fit$estimate), NA);#
			# return(list(par=par, lnLik=-fit$minimum));#
			#
			fit <- nlminb(log(sp[1]), objective=foo, upper=log(50), control=list(maxiter=1000))#
			par <- c(exp(fit$par), NA);#
			return(list(par=par, lnLik=-fit$objective));#
	#
			# fit <- optimize(f=foo, interval=c(-25, 1));#
			# par <- c(exp(fit$minimum), NA);#
			# return(list(par=par, lnLik=-fit$objective));#
		}#
	}#
}#
#
#
#
#
#
#
## Split the edge matrix 'z' by adding a partition rooted at node 'node'.#
##   Note: in original MEDUSA parlance, this is cutAtStem=T.#
## The list 'desc' is a list of descendants (see make.cache.medusa, above).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
## This is where 'shiftCut' matters#
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, or mixed models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
## fit1 model is already logged; only need to record fit2 model, and only non-prefitted nodes#
medusa.ml.update <- function (node, z, desc, fit, prefit, num.tips, root.node, model, criterion, shiftCut)#
{#
## various combinations possible#
	cat("Attempting to work with node: ", node, ". 'shiftCut' = ", shiftCut, "\n")#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" || shiftCut == "both" || node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		cat("In 'stem', attempting to work with node: ", node, "\n")#
		obj.stem <- medusa.split(node=node, z=z, desc=desc, shiftCut="stem");#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		cat("Made it through medusa.split.\n")#
		#
# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'stem', bitches! Working on node #", node)#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			cat("\ntrying to return fit...")#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="yule");#
			} else {#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="bd");#
			}#
		} else {#
			fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model=model);#
			fit1.stem$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else { # novel shift#
			fit2.stem.bd <- NULL;#
			fit2.stem.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.stem.yule <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="yule");#
				fit2.stem.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.stem.bd <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="bd");#
				fit2.stem.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.stem.bd))#
			{#
				fit2.stem <- fit2.stem.yule;#
			} else if (is.null(fit2.stem.yule)) {#
				fit2.stem <- fit2.stem.bd;#
			} else {#
## Considering both places for a shift#
				fit2.stem.bd.val <- calculate.model.fit(fit=fit2.stem.bd, z=z);#
				fit2.stem.yule.val <- calculate.model.fit(fit=fit2.stem.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.stem.bd.val[[element]] < fit2.stem.yule.val[[element]])#
				{#
					fit2.stem <- fit2.stem.bd;#
				} else {#
					fit2.stem <- fit2.stem.yule;#
				}#
			}#
		}#
	}#
	if ((shiftCut == "node" || shiftCut == "both") && !(node < root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		cat("In 'node', attempting to work with node: ", node, "\n")#
		obj.node <- medusa.split(node=node, z=z, desc=desc, shiftCut="node");#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		cat("Made it through medusa.split.\n")#
		#
		#
		# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'node', bitches! Working on node #", node)#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="yule");#
				fit1.node$model <- "yule";#
			} else {#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="bd");#
				fit1.node$model <- "bd";#
			}#
		} else {#
			fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model=model);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.node <- prefit$tips[[node]];#
		} else if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		}#
		else { # novel shift#
			fit2.node.bd <- NULL;#
			fit2.node.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.node.yule <- medusa.ml.fit.partition(aff[2], z.node, sp, model="yule");#
				fit2.node.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.node.bd <- medusa.ml.fit.partition(aff[2], z.node, sp, model="bd");#
				fit2.node.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.node.bd))#
			{#
				fit2.node <- fit2.node.yule;#
			} else if (is.null(fit2.node.yule)) {#
				fit2.node <- fit2.node.bd;#
			} else {#
## Considering both places for a shift#
				fit2.node.bd.val <- calculate.model.fit(fit=fit2.node.bd, z=z);#
				fit2.node.yule.val <- calculate.model.fit(fit=fit2.node.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.node.bd.val[[element]] < fit2.node.yule.val[[element]])#
				{#
					fit2.node <- fit2.node.bd;#
				} else {#
					fit2.node <- fit2.node.yule;#
				}#
			}	#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par);#
		stem.fit <- calculate.model.fit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par);#
		node.fit <- calculate.model.fit(fit=node.val, z=z);#
		#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
#			cat("Stem wins!\n");#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
#			cat("Node wins!\n");#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculate.model.fit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
#
#
#
#
#
#
#
## make.lik.medusa.part: generate a likelihood function for a single partition.#
make.lik.medusa.part <- function (partition, model)#
{#
# Handle internal and pendant edges separately#
	is.int <- is.na(partition[,"n.t"]);#
	is.pend <- !is.int;#
	#
	n.int <- sum(is.int);#
	n.pend <- sum(is.pend);#
	#
## Internal and pendant calculations differ; split'em up#
	int  <- partition[is.int,,drop=FALSE];#
	pend <- partition[is.pend,,drop=FALSE];#
	#
	sum.int.t.len <- sum(int[,"t.len"]);  # Simply sum all internal edges#
	int.t.0 <- int[,"t.0"];#
	#
# 'n.0' = Foote's 'a', initial diversity; 'n.t' = Foote's 'n', final diversity#
	pend.n.0 <- pend[,"n.0"]; # Foote's 'a': initial diversity#
	pend.n.t <- pend[,"n.t"]; # Foote's 'n': final diversity#
	pend.t.len <- pend[,"t.len"];#
	#
	if (n.int + n.pend != length(partition[,1])) stop("You messed up, yo.");#
	#
# User may pass in epsilon; don't change it, just estimate r#
	f <- function(pars)#
	{#
		if (model == "bd")#
		{#
			r <- pars[1];#
			epsilon <- pars[2];#
			#
			if (r <= 0 || epsilon <= 0 || epsilon >= 1) {return(-Inf);}#
		} else {#
			#
			r <- pars[1];#
			epsilon <- 0;#
			#
			if (r <= 0 || is.nan(r)) {return(-Inf);}#
		}#
		#
		l.int <- numeric();#
		l.pend <- numeric();#
		#
		if (n.int == 0) {l.int <- 0;} else {#
## Likelihood of internal edges from Rabosky et al. (2007) equation (2.3):#
			l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
		}#
		#
		if (n.pend == 0) {l.pend <- 0} else {#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
			#
			ert <- exp(r * pend.t.len);#
			B <- (ert - 1) / (ert - epsilon); # Equivalently: B <- (bert - b) / (bert - d)#
			#
			l.pend <- sum(log(1 - B) + (pend.n.t - 1)*log(B));#
		}#
		return(l.int + l.pend);#
	}#
}#
#
#
## 'fit' contains '$par' and '$lnlik'#
calculate.model.fit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	#
# Updated for more general models: check how many parameter values != NA#
#	k <- 2 + (3 * (num.models - 1))#
	k <- sum(!is.na(fit$par)) + (num.models - 1); # number of estimated parameters + number of breaks#
	#
	lnLik <- fit$lnLik;#
	#
	aic <- (-2 * lnLik) + (2*k);#
	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
get.b.d <- function (r, epsilon)#
{#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
## Print out tree with ape-style node-numbering#
## Possibly of interest for users to identify numbers of node(s) off interest#
 ## If this is the case, make sure to pass in pruned tree#
plotNN <- function (phy, time=TRUE, margin=TRUE, label.offset=0.5, cex=0.5, ...) #
{#
	phy$node.label <- (length(phy$tip.label) + 1):max(phy$edge);#
	plot.phylo(phy, show.node.label=TRUE, no.margin=!margin, label.offset=label.offset, cex=cex, ...);#
	if (time && !margin) {cat("Cannot plot time axis without a margin.\n");}#
	else if (time && margin) {axisPhylo(cex.axis=0.75)};#
}
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
## Only used for base model#
medusa.ml.initial <- function (z, initialR, initialE, model)#
{#
	rootnode <- min(z[,"anc"]);#
	obj <- medusa.ml.fit.partition(partition=1, z=z, sp=c(initialR, initialE), model=model);#
	#
	model.fit <- calculate.model.fit(fit=obj, z=z);#
	#
	return(list(par=matrix(obj$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=obj$lnLik, #
	   lnLik=obj$lnLik, split.at=rootnode, aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3], cut.at="node"));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted.#
## shiftCut can only be "stem" or "node" (not "both"), as both are evaluated separately#
medusa.ml.prefit <- function (node, z, desc, initialR, initialE, model, shiftCut, criterion)#
{#
	fitted.bd <- NULL;#
	fitted.yule <- NULL;#
#	fit <- NULL;#
	#
## if model is mixed, grab the optimally fitted one, drop the other; it is cutAtStem that matters, as it is the sum of 2 break likelihoods#
  ## optimal alone may be different than optimal in tandem#
	if (shiftCut == "stem")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.stem <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.stem, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "stem";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.stem <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.stem, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "stem";#
		}#
	} else if (shiftCut == "node")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.node <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.node, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "node";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.node <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.node, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "node";#
		}#
	}#
## Check which flavour of model fits best#
	if (is.null(fitted.bd) & !is.null(fitted.yule))#
	{#
		return(fitted.yule);#
	} else if (is.null(fitted.yule) & !is.null(fitted.bd)) {#
		return(fitted.bd);#
	} else {#
## Dealing with a 'mixed' model here; need to consider number of parameters.#
		bd.model.fit <- calculate.model.fit(fit=fitted.bd, z=z);#
		yule.model.fit <- calculate.model.fit(fit=fitted.yule, z=z);#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		if (is.nan(yule.model.fit[[element]]))#
		{#
			return(fitted.bd);#
		} else if (bd.model.fit[[element]] < yule.model.fit[[element]])#
		{#
			return(fitted.bd);#
		} else {#
			return(fitted.yule);#
		}#
	}#
}#
#
#
#
#
#
#
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
	new.part <- z[z[,"partition"] == partition,,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
	if (length(new.part) == 0)#
	{#
		cat("\nSaved time, bitches!\n")#
		par <- c(NA, NA);#
		return(list(par=par, lnLik=-Inf));#
	} else {#
# Construct likelihood function:#
		lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);#
		foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
		#
		if (model == "bd")#
		{#
			fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
			#
			if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
			#
			return(list(par=exp(fit$par), lnLik=-fit$value));#
		} else {#
			# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
			# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
			# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
			# best.guess2 <- log(node.richness) / #
			#
			# fit <- nlm(log(sp[1]), f=foo)#
			# par <- c(exp(fit$estimate), NA);#
			# return(list(par=par, lnLik=-fit$minimum));#
			#
			fit <- nlminb(log(sp[1]), objective=foo, upper=log(50), control=list(maxiter=1000))#
			par <- c(exp(fit$par), NA);#
			return(list(par=par, lnLik=-fit$objective));#
	#
			# fit <- optimize(f=foo, interval=c(-25, 1));#
			# par <- c(exp(fit$minimum), NA);#
			# return(list(par=par, lnLik=-fit$objective));#
		}#
	}#
}#
#
#
#
#
#
#
## Split the edge matrix 'z' by adding a partition rooted at node 'node'.#
##   Note: in original MEDUSA parlance, this is cutAtStem=T.#
## The list 'desc' is a list of descendants (see make.cache.medusa, above).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
## This is where 'shiftCut' matters#
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, or mixed models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
## fit1 model is already logged; only need to record fit2 model, and only non-prefitted nodes#
medusa.ml.update <- function (node, z, desc, fit, prefit, num.tips, root.node, model, criterion, shiftCut)#
{#
## various combinations possible#
	cat("Attempting to work with node: ", node, ". 'shiftCut' = ", shiftCut, "\n", sep="")#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" || shiftCut == "both" || node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		cat("In 'stem', attempting to work with node: ", node, "\n", sep="")#
		obj.stem <- medusa.split(node=node, z=z, desc=desc, shiftCut="stem");#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		cat("Made it through medusa.split.\n")#
		#
# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'stem', bitches! Working on node #", node, sep="")#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			cat("\ntrying to return fit...")#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="yule");#
			} else {#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="bd");#
			}#
		} else {#
			fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model=model);#
			fit1.stem$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else { # novel shift#
			fit2.stem.bd <- NULL;#
			fit2.stem.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.stem.yule <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="yule");#
				fit2.stem.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.stem.bd <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="bd");#
				fit2.stem.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.stem.bd))#
			{#
				fit2.stem <- fit2.stem.yule;#
			} else if (is.null(fit2.stem.yule)) {#
				fit2.stem <- fit2.stem.bd;#
			} else {#
## Considering both places for a shift#
				fit2.stem.bd.val <- calculate.model.fit(fit=fit2.stem.bd, z=z);#
				fit2.stem.yule.val <- calculate.model.fit(fit=fit2.stem.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.stem.bd.val[[element]] < fit2.stem.yule.val[[element]])#
				{#
					fit2.stem <- fit2.stem.bd;#
				} else {#
					fit2.stem <- fit2.stem.yule;#
				}#
			}#
		}#
	}#
	if ((shiftCut == "node" || shiftCut == "both") && !(node < root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		cat("In 'node', attempting to work with node: ", node, "\n", sep="")#
		obj.node <- medusa.split(node=node, z=z, desc=desc, shiftCut="node");#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		cat("Made it through medusa.split.\n")#
		#
		#
		# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'node', bitches! Working on node #", node, sep="")#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="yule");#
				fit1.node$model <- "yule";#
			} else {#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="bd");#
				fit1.node$model <- "bd";#
			}#
		} else {#
			fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model=model);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.node <- prefit$tips[[node]];#
		} else if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		}#
		else { # novel shift#
			fit2.node.bd <- NULL;#
			fit2.node.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.node.yule <- medusa.ml.fit.partition(aff[2], z.node, sp, model="yule");#
				fit2.node.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.node.bd <- medusa.ml.fit.partition(aff[2], z.node, sp, model="bd");#
				fit2.node.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.node.bd))#
			{#
				fit2.node <- fit2.node.yule;#
			} else if (is.null(fit2.node.yule)) {#
				fit2.node <- fit2.node.bd;#
			} else {#
## Considering both places for a shift#
				fit2.node.bd.val <- calculate.model.fit(fit=fit2.node.bd, z=z);#
				fit2.node.yule.val <- calculate.model.fit(fit=fit2.node.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.node.bd.val[[element]] < fit2.node.yule.val[[element]])#
				{#
					fit2.node <- fit2.node.bd;#
				} else {#
					fit2.node <- fit2.node.yule;#
				}#
			}	#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par);#
		stem.fit <- calculate.model.fit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par);#
		node.fit <- calculate.model.fit(fit=node.val, z=z);#
		#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
#			cat("Stem wins!\n");#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
#			cat("Node wins!\n");#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculate.model.fit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
#
#
#
#
#
#
#
## make.lik.medusa.part: generate a likelihood function for a single partition.#
make.lik.medusa.part <- function (partition, model)#
{#
# Handle internal and pendant edges separately#
	is.int <- is.na(partition[,"n.t"]);#
	is.pend <- !is.int;#
	#
	n.int <- sum(is.int);#
	n.pend <- sum(is.pend);#
	#
## Internal and pendant calculations differ; split'em up#
	int  <- partition[is.int,,drop=FALSE];#
	pend <- partition[is.pend,,drop=FALSE];#
	#
	sum.int.t.len <- sum(int[,"t.len"]);  # Simply sum all internal edges#
	int.t.0 <- int[,"t.0"];#
	#
# 'n.0' = Foote's 'a', initial diversity; 'n.t' = Foote's 'n', final diversity#
	pend.n.0 <- pend[,"n.0"]; # Foote's 'a': initial diversity#
	pend.n.t <- pend[,"n.t"]; # Foote's 'n': final diversity#
	pend.t.len <- pend[,"t.len"];#
	#
	if (n.int + n.pend != length(partition[,1])) stop("You messed up, yo.");#
	#
# User may pass in epsilon; don't change it, just estimate r#
	f <- function(pars)#
	{#
		if (model == "bd")#
		{#
			r <- pars[1];#
			epsilon <- pars[2];#
			#
			if (r <= 0 || epsilon <= 0 || epsilon >= 1) {return(-Inf);}#
		} else {#
			#
			r <- pars[1];#
			epsilon <- 0;#
			#
			if (r <= 0 || is.nan(r)) {return(-Inf);}#
		}#
		#
		l.int <- numeric();#
		l.pend <- numeric();#
		#
		if (n.int == 0) {l.int <- 0;} else {#
## Likelihood of internal edges from Rabosky et al. (2007) equation (2.3):#
			l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
		}#
		#
		if (n.pend == 0) {l.pend <- 0} else {#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
			#
			ert <- exp(r * pend.t.len);#
			B <- (ert - 1) / (ert - epsilon); # Equivalently: B <- (bert - b) / (bert - d)#
			#
			l.pend <- sum(log(1 - B) + (pend.n.t - 1)*log(B));#
		}#
		return(l.int + l.pend);#
	}#
}#
#
#
## 'fit' contains '$par' and '$lnlik'#
calculate.model.fit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	#
# Updated for more general models: check how many parameter values != NA#
#	k <- 2 + (3 * (num.models - 1))#
	k <- sum(!is.na(fit$par)) + (num.models - 1); # number of estimated parameters + number of breaks#
	#
	lnLik <- fit$lnLik;#
	#
	aic <- (-2 * lnLik) + (2*k);#
	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
get.b.d <- function (r, epsilon)#
{#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
## Print out tree with ape-style node-numbering#
## Possibly of interest for users to identify numbers of node(s) off interest#
 ## If this is the case, make sure to pass in pruned tree#
plotNN <- function (phy, time=TRUE, margin=TRUE, label.offset=0.5, cex=0.5, ...) #
{#
	phy$node.label <- (length(phy$tip.label) + 1):max(phy$edge);#
	plot.phylo(phy, show.node.label=TRUE, no.margin=!margin, label.offset=label.offset, cex=cex, ...);#
	if (time && !margin) {cat("Cannot plot time axis without a margin.\n");}#
	else if (time && margin) {axisPhylo(cex.axis=0.75)};#
}
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("base =", base, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
z
phy
richness
model.limit=37
	if (nexus) phy <- read.nexus(phy);#
	if (is.null(richness))  # Assume tree represents single species tips and is completely sampled#
	{#
		richness <- data.frame(taxon=phy$tip.label, n.taxa=1);#
	} else {#
## Before determining model.limit, prune tree as necessary (from 'taxon' information in 'richness')#
		phyData <- prune.tree.merge.data(phy=phy, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	}#
	#
## Limit on number of piecewise models fitted; based on tree size, aicc correction factor, #
## and flavour of model fitted (i.e. # parameters estimated; birth-death or pure-birth)#
	model.limit <- get.max.model.limit(richness=richness, model.limit=model.limit, model=model, stop=stop, verbose=verbose);#
	#
## Determine correct AICc threshold from tree size (based on simulations)#
 ## Should be used for interpreting model-fit#
	threshold <- get.threshold(length(phy$tip.label));#
	cat("Appropriate AICc threshold for tree of ", length(phy$tip.label), " tips is: ", threshold, ".\n\n", sep="");#
	#
## Store pertinent information: branch times, richness, descendants#
	cat("Preparing data for analysis... ");#
	#
## Keep track of all nodes, internal and pendant (for keeping track of breakpoints)#
	pend.nodes <- seq_len(length(phy$tip.label));   # Calculate pendant splits just once, keep track through various models#
	int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
	root.node <- length(phy$tip.label) + 1;#
	all.nodes <- c(pend.nodes, root.node, int.nodes);#
	#
## The important bits. Set up z, get descendants and number of tips per node#
	obj <- make.cache.medusa(phy=phy, richness=richness, all.nodes=all.nodes, mc=mc, num.cores=num.cores);#
	#
	desc <- list(desc.stem=obj$desc.stem, desc.node=obj$desc.node);#
	z <- obj$z;#
	z.orig <- z; # Save for summarizing models later#
	num.tips <- obj$num.tips;#
	#
	cat("done.\n");#
	#
## Pre-fit pendant edges so these values need not be re(re(re))calculated; amounts to ~25% of all calculations#
 ## Will show particular performance gain for edges with many fossil observations#
	cat("Optimizing parameters for pendant edges... ");#
	tips <- NULL;#
# Will always be shiftCut="stem"; if mixed model, keep only best fit and throw out other in medusa.ml.prefit#
	if (mc)#
	{#
		tips <- mclapply(pend.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion, mc.cores=num.cores);#
	} else {#
		tips <- lapply(pend.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion);#
	}#
	cat("done.\n");#
	#
## Pre-fit virgin internal nodes; should deliver performance gain for early models, and especially for large trees#
 ## Remain useful until a spilt is accepted within the clade#
 ## Need to incorporate cutAtStem here#
	cat("Pre-calculating parameters for virgin internal nodes... ");#
	virgin.stem <- list(); virgin.node <- list();#
	if (mc)#
	{#
		if (shiftCut == "stem" || shiftCut == "both")#
		{#
			virgin.stem <- mclapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion, mc.cores=num.cores);#
		}#
		if (shiftCut == "node" || shiftCut == "both")#
		{#
			virgin.node <- mclapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="node", criterion=criterion, mc.cores=num.cores);#
		}#
	} else {#
		if (shiftCut == "stem" || shiftCut == "both")#
		{#
			virgin.stem <- lapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion);#
		}#
		if (shiftCut == "node" || shiftCut == "both")#
		{#
			virgin.node <- lapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="node", criterion=criterion);#
		}#
	}#
	virgin.nodes <- list(stem=virgin.stem, node=virgin.node);#
	cat("done.\n\n");#
	#
	prefit <- list(tips=tips, virgin.nodes=virgin.nodes);#
	#
## Fit the base model#
## 'fit' holds current results; useful for initializing subsequent models#
	fit <- list();#
	if (model == "mixed")#
	{#
		fit.bd <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="bd");#
		fit.yule <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="yule");#
		if (fit.bd[[criterion]] < fit.yule[[criterion]]) {#
			fit <- fit.bd;#
			fit$model <- "bd";#
		} else {#
			fit <- fit.yule;#
			fit$model <- "yule";#
		}#
	} else if (model == "bd") {#
		fit <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="bd");#
		fit$model <- "bd";#
	} else {#
		fit <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="yule");#
		fit$model <- "yule";#
	}#
	models <- list(fit);#
	#
	if (stop == "model.limit")#
	{#
		cat("Step 1 (of ", model.limit, "): best likelihood = ", models[[1]]$lnLik, "; AICc = ", models[[1]]$aicc, "; model = ", models[[1]]$model, "\n", sep="");#
		for (i in seq_len(model.limit-1))#
		{#
			node.list <- all.nodes[-fit$split.at]; # this seems inefficient; create list and delete from there; will need -fit$split.at[i+1]#
			#
			#
			#
			if (mc)  # multicore (i.e. multithreaded) processing. No GUI, and not at all on Windows#
			{#
				res <- mclapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut, mc.cores=num.cores);#
			} else {#
				res <- lapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut);#
			}#
# Select model with best score according to the specific criterion employed (default aicc)#
			best <- which.min(unlist(lapply(res, "[[", criterion)));#
			models <- c(models, res[best]);#
			fit <- res[[best]];   # keep track of '$split.at' i.e. nodes already considered#
			#
			z <- medusa.split(node=node.list[best], z=z, desc=desc, shiftCut=fit$cut.at[i+1])$z;#
			#
			cat("Step ", i+1, " (of ", model.limit, "): best likelihood = ", round(models[[i+1]]$lnLik, digits=7), "; AICc = ", models[[i+1]]$aicc,#
				"; shift at node ", models[[i+1]]$split.at[i+1], "; model=", models[[i+1]]$model[i+1], "; cut=", models[[i+1]]$cut.at[i+1], "\n", sep="");#
		}#
	}
model.limit
richness
get.max.model.limit(richness=richness, model.limit=model.limit, model=model, stop=stop, verbose=verbose);
model.limit=37
get.max.model.limit(richness=richness, model.limit=model.limit, model=model, stop=stop, verbose=verbose);
model.limit
## Determine correct AICc threshold from tree size (based on simulations)#
 ## Should be used for interpreting model-fit#
	threshold <- get.threshold(length(phy$tip.label));#
	cat("Appropriate AICc threshold for tree of ", length(phy$tip.label), " tips is: ", threshold, ".\n\n", sep="");#
	#
## Store pertinent information: branch times, richness, descendants#
	cat("Preparing data for analysis... ");#
	#
## Keep track of all nodes, internal and pendant (for keeping track of breakpoints)#
	pend.nodes <- seq_len(length(phy$tip.label));   # Calculate pendant splits just once, keep track through various models#
	int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
	root.node <- length(phy$tip.label) + 1;#
	all.nodes <- c(pend.nodes, root.node, int.nodes);#
	#
## The important bits. Set up z, get descendants and number of tips per node#
	obj <- make.cache.medusa(phy=phy, richness=richness, all.nodes=all.nodes, mc=mc, num.cores=num.cores);#
	#
	desc <- list(desc.stem=obj$desc.stem, desc.node=obj$desc.node);#
	z <- obj$z;#
	z.orig <- z; # Save for summarizing models later#
	num.tips <- obj$num.tips;#
	#
	cat("done.\n");#
	#
## Pre-fit pendant edges so these values need not be re(re(re))calculated; amounts to ~25% of all calculations#
 ## Will show particular performance gain for edges with many fossil observations#
	cat("Optimizing parameters for pendant edges... ");#
	tips <- NULL;#
# Will always be shiftCut="stem"; if mixed model, keep only best fit and throw out other in medusa.ml.prefit#
	if (mc)#
	{#
		tips <- mclapply(pend.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion, mc.cores=num.cores);#
	} else {#
		tips <- lapply(pend.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion);#
	}#
	cat("done.\n");#
	#
## Pre-fit virgin internal nodes; should deliver performance gain for early models, and especially for large trees#
 ## Remain useful until a spilt is accepted within the clade#
 ## Need to incorporate cutAtStem here#
	cat("Pre-calculating parameters for virgin internal nodes... ");#
	virgin.stem <- list(); virgin.node <- list();#
	if (mc)#
	{#
		if (shiftCut == "stem" || shiftCut == "both")#
		{#
			virgin.stem <- mclapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion, mc.cores=num.cores);#
		}#
		if (shiftCut == "node" || shiftCut == "both")#
		{#
			virgin.node <- mclapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="node", criterion=criterion, mc.cores=num.cores);#
		}#
	} else {#
		if (shiftCut == "stem" || shiftCut == "both")#
		{#
			virgin.stem <- lapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion);#
		}#
		if (shiftCut == "node" || shiftCut == "both")#
		{#
			virgin.node <- lapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="node", criterion=criterion);#
		}#
	}#
	virgin.nodes <- list(stem=virgin.stem, node=virgin.node);#
	cat("done.\n\n");#
	#
	prefit <- list(tips=tips, virgin.nodes=virgin.nodes);#
	#
## Fit the base model#
## 'fit' holds current results; useful for initializing subsequent models#
	fit <- list();#
	if (model == "mixed")#
	{#
		fit.bd <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="bd");#
		fit.yule <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="yule");#
		if (fit.bd[[criterion]] < fit.yule[[criterion]]) {#
			fit <- fit.bd;#
			fit$model <- "bd";#
		} else {#
			fit <- fit.yule;#
			fit$model <- "yule";#
		}#
	} else if (model == "bd") {#
		fit <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="bd");#
		fit$model <- "bd";#
	} else {#
		fit <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="yule");#
		fit$model <- "yule";#
	}#
	models <- list(fit);#
	#
	if (stop == "model.limit")#
	{#
		cat("Step 1 (of ", model.limit, "): best likelihood = ", models[[1]]$lnLik, "; AICc = ", models[[1]]$aicc, "; model = ", models[[1]]$model, "\n", sep="");#
		for (i in seq_len(model.limit-1))#
		{#
			node.list <- all.nodes[-fit$split.at]; # this seems inefficient; create list and delete from there; will need -fit$split.at[i+1]#
			#
			#
			#
			if (mc)  # multicore (i.e. multithreaded) processing. No GUI, and not at all on Windows#
			{#
				res <- mclapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut, mc.cores=num.cores);#
			} else {#
				res <- lapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut);#
			}#
# Select model with best score according to the specific criterion employed (default aicc)#
			best <- which.min(unlist(lapply(res, "[[", criterion)));#
			models <- c(models, res[best]);#
			fit <- res[[best]];   # keep track of '$split.at' i.e. nodes already considered#
			#
			z <- medusa.split(node=node.list[best], z=z, desc=desc, shiftCut=fit$cut.at[i+1])$z;#
			#
			cat("Step ", i+1, " (of ", model.limit, "): best likelihood = ", round(models[[i+1]]$lnLik, digits=7), "; AICc = ", models[[i+1]]$aicc,#
				"; shift at node ", models[[i+1]]$split.at[i+1], "; model=", models[[i+1]]$model[i+1], "; cut=", models[[i+1]]$cut.at[i+1], "\n", sep="");#
		}#
	}
model.limit
## Split the edge matrix 'z' by adding a partition rooted at node 'node'.#
##   Note: in original MEDUSA parlance, this is cutAtStem=T.#
## The list 'desc' is a list of descendants (see make.cache.medusa, above).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
## This is where 'shiftCut' matters#
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}
model.limit
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	cat("Am I still alive here?!?\n")#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	affected <- c(unique(part[idx])#
	cat("Am I still alive here?!?\n")#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	affected <- c(unique(part[idx]))#
	cat("Am I still alive here?!?\n")#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	affected <- c(unique(part[idx]))#
	cat("Am I still alive here?!? affected = ", affected, "\n", sep="")#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	affected <- c(unique(part[idx]))#
	cat("Am I still alive here?!? affected = ", affected, "; z = ", z, "\n", sep="")#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	affected <- c(unique(part[idx]))#
	cat("Am I still alive here?!? affected = ", affected, "\n", sep="")#
	print(z)#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
z
max(z[,"partition"])
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	affected <- c(unique(part[idx]))#
	cat("Am I still alive here?!? affected = ", affected, "\n", sep="")#
	print(z)#
	foo <- list(z=z, affected=c(unique(part[idx]), tag))#
	cat("Howdy.\n")#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}
runTurboMEDUSA(whales$phy, whales$richness, shiftCut="node", model.limit=38, model="yule") -> res
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	affected <- c(unique(part[idx]))#
	cat("Am I still alive here?!? affected = ", affected, "\n", sep="")#
#	print(z)#
	foo <- list(z=z, affected=c(unique(part[idx]), tag))#
	cat("Howdy.\n")#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	affected <- c(unique(part[idx]))#
	cat("Am I still alive here?!? affected = ", affected, "\n", sep="")#
#	print(z)#
#	foo <- list(z=z, affected=c(unique(part[idx]), tag))#
#	cat("Howdy.\n")#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}
ls()
## Only used for base model#
medusa.ml.initial <- function (z, initialR, initialE, model)#
{#
	rootnode <- min(z[,"anc"]);#
	obj <- medusa.ml.fit.partition(partition=1, z=z, sp=c(initialR, initialE), model=model);#
	#
	model.fit <- calculate.model.fit(fit=obj, z=z);#
	#
	return(list(par=matrix(obj$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=obj$lnLik, #
	   lnLik=obj$lnLik, split.at=rootnode, aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3], cut.at="node"));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted.#
## shiftCut can only be "stem" or "node" (not "both"), as both are evaluated separately#
medusa.ml.prefit <- function (node, z, desc, initialR, initialE, model, shiftCut, criterion)#
{#
	fitted.bd <- NULL;#
	fitted.yule <- NULL;#
#	fit <- NULL;#
	#
## if model is mixed, grab the optimally fitted one, drop the other; it is cutAtStem that matters, as it is the sum of 2 break likelihoods#
  ## optimal alone may be different than optimal in tandem#
	if (shiftCut == "stem")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.stem <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.stem, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "stem";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.stem <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.stem, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "stem";#
		}#
	} else if (shiftCut == "node")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.node <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.node, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "node";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.node <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.node, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "node";#
		}#
	}#
## Check which flavour of model fits best#
	if (is.null(fitted.bd) & !is.null(fitted.yule))#
	{#
		return(fitted.yule);#
	} else if (is.null(fitted.yule) & !is.null(fitted.bd)) {#
		return(fitted.bd);#
	} else {#
## Dealing with a 'mixed' model here; need to consider number of parameters.#
		bd.model.fit <- calculate.model.fit(fit=fitted.bd, z=z);#
		yule.model.fit <- calculate.model.fit(fit=fitted.yule, z=z);#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		if (is.nan(yule.model.fit[[element]]))#
		{#
			return(fitted.bd);#
		} else if (bd.model.fit[[element]] < yule.model.fit[[element]])#
		{#
			return(fitted.bd);#
		} else {#
			return(fitted.yule);#
		}#
	}#
}#
#
#
#
#
#
#
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
	new.part <- z[z[,"partition"] == partition,,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
	if (length(new.part) == 0)#
	{#
		cat("\nSaved time, bitches!\n")#
		par <- c(NA, NA);#
		return(list(par=par, lnLik=-Inf));#
	} else {#
# Construct likelihood function:#
		lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);#
		foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
		#
		if (model == "bd")#
		{#
			fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
			#
			if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
			#
			return(list(par=exp(fit$par), lnLik=-fit$value));#
		} else {#
			# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
			# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
			# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
			# best.guess2 <- log(node.richness) / #
			#
			# fit <- nlm(log(sp[1]), f=foo)#
			# par <- c(exp(fit$estimate), NA);#
			# return(list(par=par, lnLik=-fit$minimum));#
			#
			fit <- nlminb(log(sp[1]), objective=foo, upper=log(50), control=list(maxiter=1000))#
			par <- c(exp(fit$par), NA);#
			return(list(par=par, lnLik=-fit$objective));#
	#
			# fit <- optimize(f=foo, interval=c(-25, 1));#
			# par <- c(exp(fit$minimum), NA);#
			# return(list(par=par, lnLik=-fit$objective));#
		}#
	}#
}#
#
#
#
#
#
#
## Split the edge matrix 'z' by adding a partition rooted at node 'node'.#
##   Note: in original MEDUSA parlance, this is cutAtStem=T.#
## The list 'desc' is a list of descendants (see make.cache.medusa, above).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
## This is where 'shiftCut' matters#
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	affected <- c(unique(part[idx]))#
	cat("Am I still alive here?!? affected = ", affected, "\n", sep="")#
#	print(z)#
#	foo <- list(z=z, affected=c(unique(part[idx]), tag))#
#	cat("Howdy.\n")#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, or mixed models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
## fit1 model is already logged; only need to record fit2 model, and only non-prefitted nodes#
medusa.ml.update <- function (node, z, desc, fit, prefit, num.tips, root.node, model, criterion, shiftCut)#
{#
## various combinations possible#
	cat("Attempting to work with node: ", node, ". 'shiftCut' = ", shiftCut, "\n", sep="")#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" || shiftCut == "both" || node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		cat("In 'stem', attempting to work with node: ", node, "\n", sep="")#
		obj.stem <- medusa.split(node=node, z=z, desc=desc, shiftCut="stem");#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		cat("Made it through medusa.split.\n")#
		#
# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'stem', bitches! Working on node #", node, sep="")#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			cat("\ntrying to return fit...")#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="yule");#
			} else {#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="bd");#
			}#
		} else {#
			fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model=model);#
			fit1.stem$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else { # novel shift#
			fit2.stem.bd <- NULL;#
			fit2.stem.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.stem.yule <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="yule");#
				fit2.stem.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.stem.bd <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="bd");#
				fit2.stem.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.stem.bd))#
			{#
				fit2.stem <- fit2.stem.yule;#
			} else if (is.null(fit2.stem.yule)) {#
				fit2.stem <- fit2.stem.bd;#
			} else {#
## Considering both places for a shift#
				fit2.stem.bd.val <- calculate.model.fit(fit=fit2.stem.bd, z=z);#
				fit2.stem.yule.val <- calculate.model.fit(fit=fit2.stem.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.stem.bd.val[[element]] < fit2.stem.yule.val[[element]])#
				{#
					fit2.stem <- fit2.stem.bd;#
				} else {#
					fit2.stem <- fit2.stem.yule;#
				}#
			}#
		}#
	}#
	if ((shiftCut == "node" || shiftCut == "both") && !(node < root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		cat("In 'node', attempting to work with node: ", node, "\n", sep="")#
		obj.node <- medusa.split(node=node, z=z, desc=desc, shiftCut="node");#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		cat("Made it through medusa.split.\n")#
		#
		#
		# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'node', bitches! Working on node #", node, sep="")#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="yule");#
				fit1.node$model <- "yule";#
			} else {#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="bd");#
				fit1.node$model <- "bd";#
			}#
		} else {#
			fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model=model);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.node <- prefit$tips[[node]];#
		} else if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		}#
		else { # novel shift#
			fit2.node.bd <- NULL;#
			fit2.node.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.node.yule <- medusa.ml.fit.partition(aff[2], z.node, sp, model="yule");#
				fit2.node.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.node.bd <- medusa.ml.fit.partition(aff[2], z.node, sp, model="bd");#
				fit2.node.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.node.bd))#
			{#
				fit2.node <- fit2.node.yule;#
			} else if (is.null(fit2.node.yule)) {#
				fit2.node <- fit2.node.bd;#
			} else {#
## Considering both places for a shift#
				fit2.node.bd.val <- calculate.model.fit(fit=fit2.node.bd, z=z);#
				fit2.node.yule.val <- calculate.model.fit(fit=fit2.node.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.node.bd.val[[element]] < fit2.node.yule.val[[element]])#
				{#
					fit2.node <- fit2.node.bd;#
				} else {#
					fit2.node <- fit2.node.yule;#
				}#
			}	#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par);#
		stem.fit <- calculate.model.fit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par);#
		node.fit <- calculate.model.fit(fit=node.val, z=z);#
		#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
#			cat("Stem wins!\n");#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
#			cat("Node wins!\n");#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculate.model.fit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
#
#
#
#
#
#
#
## make.lik.medusa.part: generate a likelihood function for a single partition.#
make.lik.medusa.part <- function (partition, model)#
{#
# Handle internal and pendant edges separately#
	is.int <- is.na(partition[,"n.t"]);#
	is.pend <- !is.int;#
	#
	n.int <- sum(is.int);#
	n.pend <- sum(is.pend);#
	#
## Internal and pendant calculations differ; split'em up#
	int  <- partition[is.int,,drop=FALSE];#
	pend <- partition[is.pend,,drop=FALSE];#
	#
	sum.int.t.len <- sum(int[,"t.len"]);  # Simply sum all internal edges#
	int.t.0 <- int[,"t.0"];#
	#
# 'n.0' = Foote's 'a', initial diversity; 'n.t' = Foote's 'n', final diversity#
	pend.n.0 <- pend[,"n.0"]; # Foote's 'a': initial diversity#
	pend.n.t <- pend[,"n.t"]; # Foote's 'n': final diversity#
	pend.t.len <- pend[,"t.len"];#
	#
	if (n.int + n.pend != length(partition[,1])) stop("You messed up, yo.");#
	#
# User may pass in epsilon; don't change it, just estimate r#
	f <- function(pars)#
	{#
		if (model == "bd")#
		{#
			r <- pars[1];#
			epsilon <- pars[2];#
			#
			if (r <= 0 || epsilon <= 0 || epsilon >= 1) {return(-Inf);}#
		} else {#
			#
			r <- pars[1];#
			epsilon <- 0;#
			#
			if (r <= 0 || is.nan(r)) {return(-Inf);}#
		}#
		#
		l.int <- numeric();#
		l.pend <- numeric();#
		#
		if (n.int == 0) {l.int <- 0;} else {#
## Likelihood of internal edges from Rabosky et al. (2007) equation (2.3):#
			l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
		}#
		#
		if (n.pend == 0) {l.pend <- 0} else {#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
			#
			ert <- exp(r * pend.t.len);#
			B <- (ert - 1) / (ert - epsilon); # Equivalently: B <- (bert - b) / (bert - d)#
			#
			l.pend <- sum(log(1 - B) + (pend.n.t - 1)*log(B));#
		}#
		return(l.int + l.pend);#
	}#
}#
#
#
## 'fit' contains '$par' and '$lnlik'#
calculate.model.fit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	#
# Updated for more general models: check how many parameter values != NA#
#	k <- 2 + (3 * (num.models - 1))#
	k <- sum(!is.na(fit$par)) + (num.models - 1); # number of estimated parameters + number of breaks#
	#
	lnLik <- fit$lnLik;#
	#
	aic <- (-2 * lnLik) + (2*k);#
	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
get.b.d <- function (r, epsilon)#
{#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
## Print out tree with ape-style node-numbering#
## Possibly of interest for users to identify numbers of node(s) off interest#
 ## If this is the case, make sure to pass in pruned tree#
plotNN <- function (phy, time=TRUE, margin=TRUE, label.offset=0.5, cex=0.5, ...) #
{#
	phy$node.label <- (length(phy$tip.label) + 1):max(phy$edge);#
	plot.phylo(phy, show.node.label=TRUE, no.margin=!margin, label.offset=label.offset, cex=cex, ...);#
	if (time && !margin) {cat("Cannot plot time axis without a margin.\n");}#
	else if (time && margin) {axisPhylo(cex.axis=0.75)};#
}
runTurboMEDUSA <-#
function(phy, richness=NULL, model.limit=20, stop="model.limit", model="mixed",#
	criterion="aicc", shiftCut="both", initialR=0.05, initialE=0.5, plotFig=FALSE, nexus=FALSE,#
	verbose=TRUE, mc=FALSE, num.cores=NULL, ...)#
{#
	if (nexus) phy <- read.nexus(phy);#
	if (is.null(richness))  # Assume tree represents single species tips and is completely sampled#
	{#
		richness <- data.frame(taxon=phy$tip.label, n.taxa=1);#
	} else {#
## Before determining model.limit, prune tree as necessary (from 'taxon' information in 'richness')#
		phyData <- prune.tree.merge.data(phy=phy, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	}#
	#
## Limit on number of piecewise models fitted; based on tree size, aicc correction factor, #
## and flavour of model fitted (i.e. # parameters estimated; birth-death or pure-birth)#
	model.limit <- get.max.model.limit(richness=richness, model.limit=model.limit, model=model, stop=stop, verbose=verbose);#
	#
## Determine correct AICc threshold from tree size (based on simulations)#
 ## Should be used for interpreting model-fit#
	threshold <- get.threshold(length(phy$tip.label));#
	cat("Appropriate AICc threshold for tree of ", length(phy$tip.label), " tips is: ", threshold, ".\n\n", sep="");#
	#
## Store pertinent information: branch times, richness, descendants#
	cat("Preparing data for analysis... ");#
	#
## Keep track of all nodes, internal and pendant (for keeping track of breakpoints)#
	pend.nodes <- seq_len(length(phy$tip.label));   # Calculate pendant splits just once, keep track through various models#
	int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
	root.node <- length(phy$tip.label) + 1;#
	all.nodes <- c(pend.nodes, root.node, int.nodes);#
	#
## The important bits. Set up z, get descendants and number of tips per node#
	obj <- make.cache.medusa(phy=phy, richness=richness, all.nodes=all.nodes, mc=mc, num.cores=num.cores);#
	#
	desc <- list(desc.stem=obj$desc.stem, desc.node=obj$desc.node);#
	z <- obj$z;#
	z.orig <- z; # Save for summarizing models later#
	num.tips <- obj$num.tips;#
	#
	cat("done.\n");#
	#
## Pre-fit pendant edges so these values need not be re(re(re))calculated; amounts to ~25% of all calculations#
 ## Will show particular performance gain for edges with many fossil observations#
	cat("Optimizing parameters for pendant edges... ");#
	tips <- NULL;#
# Will always be shiftCut="stem"; if mixed model, keep only best fit and throw out other in medusa.ml.prefit#
	if (mc)#
	{#
		tips <- mclapply(pend.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion, mc.cores=num.cores);#
	} else {#
		tips <- lapply(pend.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion);#
	}#
	cat("done.\n");#
	#
## Pre-fit virgin internal nodes; should deliver performance gain for early models, and especially for large trees#
 ## Remain useful until a spilt is accepted within the clade#
 ## Need to incorporate cutAtStem here#
	cat("Pre-calculating parameters for virgin internal nodes... ");#
	virgin.stem <- list(); virgin.node <- list();#
	if (mc)#
	{#
		if (shiftCut == "stem" || shiftCut == "both")#
		{#
			virgin.stem <- mclapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion, mc.cores=num.cores);#
		}#
		if (shiftCut == "node" || shiftCut == "both")#
		{#
			virgin.node <- mclapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="node", criterion=criterion, mc.cores=num.cores);#
		}#
	} else {#
		if (shiftCut == "stem" || shiftCut == "both")#
		{#
			virgin.stem <- lapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="stem", criterion=criterion);#
		}#
		if (shiftCut == "node" || shiftCut == "both")#
		{#
			virgin.node <- lapply(int.nodes, medusa.ml.prefit, z=z, desc=desc, initialR=initialR, initialE=initialE, model=model, shiftCut="node", criterion=criterion);#
		}#
	}#
	virgin.nodes <- list(stem=virgin.stem, node=virgin.node);#
	cat("done.\n\n");#
	#
	prefit <- list(tips=tips, virgin.nodes=virgin.nodes);#
	#
## Fit the base model#
## 'fit' holds current results; useful for initializing subsequent models#
	fit <- list();#
	if (model == "mixed")#
	{#
		fit.bd <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="bd");#
		fit.yule <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="yule");#
		if (fit.bd[[criterion]] < fit.yule[[criterion]]) {#
			fit <- fit.bd;#
			fit$model <- "bd";#
		} else {#
			fit <- fit.yule;#
			fit$model <- "yule";#
		}#
	} else if (model == "bd") {#
		fit <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="bd");#
		fit$model <- "bd";#
	} else {#
		fit <- medusa.ml.initial(z=z, initialR=initialR, initialE=initialE, model="yule");#
		fit$model <- "yule";#
	}#
	models <- list(fit);#
	#
	if (stop == "model.limit")#
	{#
		cat("Step 1 (of ", model.limit, "): best likelihood = ", models[[1]]$lnLik, "; AICc = ", models[[1]]$aicc, "; model = ", models[[1]]$model, "\n", sep="");#
		for (i in seq_len(model.limit-1))#
		{#
			node.list <- all.nodes[-fit$split.at]; # this seems inefficient; create list and delete from there; will need -fit$split.at[i+1]#
			#
			#
			#
			if (mc)  # multicore (i.e. multithreaded) processing. No GUI, and not at all on Windows#
			{#
				res <- mclapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut, mc.cores=num.cores);#
			} else {#
				res <- lapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut);#
			}#
# Select model with best score according to the specific criterion employed (default aicc)#
			best <- which.min(unlist(lapply(res, "[[", criterion)));#
			models <- c(models, res[best]);#
			fit <- res[[best]];   # keep track of '$split.at' i.e. nodes already considered#
			#
			z <- medusa.split(node=node.list[best], z=z, desc=desc, shiftCut=fit$cut.at[i+1])$z;#
			#
			cat("Step ", i+1, " (of ", model.limit, "): best likelihood = ", round(models[[i+1]]$lnLik, digits=7), "; AICc = ", models[[i+1]]$aicc,#
				"; shift at node ", models[[i+1]]$split.at[i+1], "; model=", models[[i+1]]$model[i+1], "; cut=", models[[i+1]]$cut.at[i+1], "\n", sep="");#
		}#
	} else if (stop == "threshold") {#
		i <- 1;#
		done <- FALSE;#
		cat("Step 1: best likelihood = ", round(models[[i+1]]$lnLik, digits=7), "; AICc = ", round(models[[i+1]]$aicc, digits=7), "; model = ", models[[1]]$model[i+1], "\n", sep="");#
		while (!done & i < model.limit)#
		{#
			node.list <- all.nodes[-fit$split.at]; # this seems inefficient; create list and delete from there; will need -fit$split.at[i+1]#
			#
			#
			#
			if (mc)  # multicore (i.e. multithreaded) processing. No GUI, and not at all on Windows#
			{#
				res <- mclapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut, mc.cores=num.cores);#
			} else {#
				res <- lapply(node.list, medusa.ml.update, z=z, desc=desc, fit=fit, prefit=prefit, num.tips=num.tips, root.node=root.node, model=model, criterion=criterion, shiftCut=shiftCut);#
			}#
# Select model with best score according to the specific criterion employed (default aicc)#
			best <- which.min(unlist(lapply(res, "[[", criterion)));#
	# Compare last accepted model to current best model#
			if (as.numeric(models[[length(models)]][criterion]) - as.numeric(res[[best]][criterion]) < threshold)#
			{#
				cat("\nNo significant increase in ", criterion, " score. Disregarding subsequent piecewise models.\n", sep="");#
				done <- TRUE;#
				break;#
			}#
			models <- c(models, res[best]);#
			fit <- res[[best]];   # keep track of '$split.at' i.e. nodes already considered#
			#
			z <- medusa.split(node=node.list[best], z=z, desc=desc, shiftCut=fit$cut.at[i+1])$z;#
			#
			cat("Step ", i+1, ": best likelihood = ", round(models[[i+1]]$lnLik, digits=7), "; AICc = ", round(models[[i+1]]$aicc, digits=7),#
				"; shift at node ", models[[i+1]]$split.at[i+1], "; model=", models[[i+1]]$model[i+1], "; cut=", models[[i+1]]$cut.at[i+1], "\n", sep="");#
			i <- i+1;#
		}#
	}#
	#
	modelSummary <- calculate.model.fit.summary(models=models, phy=phy, plotFig=ifelse(length(models) > 1 & plotFig & !mc, TRUE, FALSE), threshold=threshold);#
	if (verbose)#
	{#
		cat("\n", "Model fit summary:", "\n\n", sep="");#
		print(modelSummary);#
		if (threshold > 0)#
		{#
			cat("\nAIC weights are not reported, as they are meaningless when using a threshold criterion.\n")#
		}#
	}#
	results <- list(z=z.orig, desc=desc, models=models, phy=phy, threshold=threshold, modelSummary=modelSummary);#
	#
#	return(results);#
}
load("/Users/josephwb/Projects/R_working/turboMEDUSA/turboMEDUSA/data/whales.RData")
phy <- whales$phy
richness <- whales$richness
require(geiger)
runTurboMEDUSA(phy, richness, model.limit=37)
## Function to prune tree using 'richness' information, assumed to have minimally two columns, "taxon" and "n.taxa"#
##   Perhaps relax on these column names, may cause too many problems#
## May also include 'exemplar' column; in that case, rename relevant tip.label before pruning.#
prune.tree.merge.data <- function (phy, richness, verbose)#
{#
# Rename exemplar taxa with taxon name in richness file#
	if (!is.null(richness$exemplar))#
	{#
# Change relevant tip.labels in phy; individual 'exemplar' may be NA, use original tip.label.#
# Ordering in richness file should NOT be assumed to match order of tip.labels#
		i.na <- is.na(richness$exemplar);#
		phy$tip.label[match(richness$exemplar[!i.na], phy$tip.label)] <- as.character(richness$taxon[!i.na]);#
	}#
	#
# make sure things are in the correct order and of correct format#
	if (length(richness[1,]) == 2)#
	{#
		if (colnames(richness)[1] != "taxon" || colnames(richness)[2] != "n.taxa")#
		{#
			if (class(richness[,1]) == "factor" & class(richness[,2]) == "integer")#
			{#
				colnames(richness) = c("taxon", "n.taxa");#
			} else if (class(richness[,1]) == "integer" & class(richness[,2]) == "factor")#
			{#
				colnames(richness) = c("n.taxa", "taxon");#
			} else {#
				cat("turboMEDUSA thinks your richness data is in an incorrect format. See ?runTurboMEDUSA.\n")#
				stop;#
			}#
		}#
	}#
	#
# Prune tree down to lineages with assigned richnesses#
	temp <- richness[, "n.taxa"];#
	names(temp) <- richness[, "taxon"];#
	pruned <- treedata(phy, temp, warnings=verbose)  # geiger function calling ape (namecheck)#
	#
# checking for typos#
	if (length(pruned$phy$tip.label) == 0) {#
		cat("\n\nWARNING: turboMEDUSA encountered a serious error. Tree has no tips after processing richness information! \nIt is likely that an incorrect richness file is being used. \nAnalysis cannot proceed. Please examine the information below to identify the error.\\nn");#
		cat("\nTree tip labels:\n");#
		print(phy$tip.label);#
		cat("\nRichness taxon labels:\n");#
		print(as.character(richness[, "taxon"]));#
		stop;#
	} else if (length(phy$tip.label) != length(pruned$phy$tip.label)) {#
		cat("turboMEDUSA thinks there is a typo in either the tree or richness files, as one or more tips were dropped from the tree.\n");#
		stop;#
	}#
#
	phy <- pruned$phy;#
# Check the tree#
	#	plotNN(phy)					# Node numbers (ape-style) plotted#
	#
	return(list(phy=phy, richness=richness));#
}#
#
#
## Original default was to fit 20 models (or less if the tree was small).#
## Changing to a stop-criterion (stop="model.limit") e.g. when k = n-1 (i.e. when denominator of aicc correction is undefined).#
## k <- (3*i-1) # when both birth and death are estimated, where i is the number of piecewise models#
  ## This occurs when i = n/3#
  ## If Yule, max i = n/2#
## n <- (2*num.taxa - 1) == (2*length(richness[,1]) - 1) # i.e. total number of nodes in tree (internal + pendant)#
## Alternatively use aicc threshold itself as a stopping criterion (stop="threshold").#
# AICc = AIC + 2*k*(k+1)/(n-k-1);#
get.max.model.limit <- function (richness, model.limit, model, stop, verbose)#
{#
	samp.size <- (2*length(richness[,1]) - 1)#
	if (model == "bd" || model == "mixed")#
	{#
		max.model.limit <- as.integer(samp.size/3) - ((!(samp.size %% 3)) * 1);#
	} else {#
		max.model.limit <- as.integer(samp.size/2) - ((!(samp.size %% 2)) * 1);#
	}#
	#
	if (stop == "model.limit")#
	{#
		if (model.limit > max.model.limit) {model.limit <- max.model.limit;}#
	} else {#
		model.limit <- max.model.limit;#
	}#
	#
	if (verbose)#
	{#
		cat("\nLimiting consideration to a maximum of ", model.limit, " piecewise", sep="");#
		if (model == "bd")#
		{#
			cat(" birth-death models")#
		} else if (model == "mixed")#
		{#
			cat(" mixed models")#
		} else {#
			cat(" pure-birth (Yule) models");#
		}#
		if (stop == "threshold") {cat(" (or until threshold is not satisfied)");}#
		cat(".\n\n")#
	}#
	#
	return(model.limit);#
}#
#
#
## Fitted curve from random b-d simulations#
## Value corresponds to 95th percentile of AICc(split) - AICc(no-split) for no-split simulations#
## x-shifted power function#
get.threshold <- function (x)#
{#
	a = -3.5941052380332650E+01;#
	b =  6.7372587299747000E+00;#
	c = -1.0061508340754866E-01;#
	Offset =  2.7516678664333408E+01;#
	y <- a * (x-b)^c + Offset;#
	if (y < 0) y <- 0;#
	return(y);#
}#
#
#
## The make.cache.medusa function is like the first half of the original splitEdgeMatrix().#
## It works through and reorders the edges, then works out start and end times of these#
## based on the phylogeny's branching times.#
###
## In addition, every node's descendants are also calculated.  The element 'desc' is a list.#
## $desc[i] contains the indices within $edge, $t.start, etc., of all descendants of node 'i'#
## (in ape node numbering format).#
make.cache.medusa <- function (phy, richness, all.nodes, mc, num.cores)#
{#
	n.tips <- length(phy$tip.label);#
	n.int <- nrow(phy$edge) - n.tips;#
	#
## Ape numbers the tips first#
	i.int <- seq_len(n.int);#
	interior <- phy$edge[,2] %in% phy$edge[,1];#
	bt <- branching.times(phy);#
	#
# Consider only internal edges first#
	edges.int <- phy$edge[interior,];#
	colnames(edges.int) <- c("anc", "dec");#
	#
	t.0 <- bt[match(edges.int[,1], (n.tips+1):max(edges.int))];#
	t.1 <- c(t.0[i.int] - phy$edge.length[interior]);#
	#
	z.internal <- cbind(edges.int, t.0, t.1, t.len=t.0 - t.1,#
		n.0=rep(1, n.int), n.t=rep(NA, n.int));#
	#
# Now, pendant edges; #
	edges.pendant <- phy$edge[match(seq_len(n.tips), phy$edge[,2]),];#
	colnames(edges.pendant) <- c("anc", "dec");#
	#
	t.0 <- bt[match(edges.pendant[,1], (n.tips+1):max(edges.pendant))];#
	t.1 <- rep(0, n.tips);#
# cannot assume richness ordering necessarily matches that of tip labels#
	ext.richness <- richness$n.taxa[match(phy$tip.label, richness$taxon)];#
	#
	z.pendant <- cbind(edges.pendant, t.0, t.1, t.len=t.0 - t.1,#
		n.0=rep(1, n.tips), n.t=ext.richness);#
	#
	z <- rbind(z.internal, z.pendant);#
	z <- cbind(z,partition=rep(1, length(z[,1]))); # Stores piecewise model structure#
	rownames(z) <- NULL;#
	#
# Used for identifying descendant nodes below i.e. tracking breakpoints#
	all.edges <- as.matrix(z[,c("anc","dec")]);#
	desc.stem <- list();#
	desc.node <- list();#
	#
	if (mc)#
	{#
		desc.stem <- mclapply(seq_len(max(all.edges)), descendants.cutAtStem.idx, all.edges=all.edges, mc.cores=num.cores);#
		desc.node <- mclapply(seq_len(max(all.edges)), descendants.cutAtNode.idx, all.edges=all.edges, mc.cores=num.cores);#
	} else {#
		desc.stem <- lapply(seq_len(max(all.edges)), descendants.cutAtStem.idx, all.edges=all.edges);#
		desc.node <- lapply(seq_len(max(all.edges)), descendants.cutAtNode.idx, all.edges=all.edges);#
	}#
	#
	for (i in 1:length(desc.node))#
	{#
		if (length(desc.node[[i]]) == 0) # tips#
		{#
			desc.node[[i]] = descendants.cutAtStem.idx(node.list=i, all.edges=all.edges)#
		}#
	}#
	#
## Needed downstream; don't recalculate#
 ## Gives the number of tips associated with an internal node; determines whether a node is 'virgin' or not#
	num.tips <- list()#
	if (mc)#
	{#
		num.tips <- mclapply(all.nodes, get.num.tips, phy=phy, mc.cores=num.cores);#
	} else {#
		num.tips <- lapply(all.nodes, get.num.tips, phy=phy);#
	}#
	#
	res <- list(z=z, desc.stem=desc.stem, desc.node=desc.node, num.tips=num.tips);#
	return(res);#
}#
#
#
## Needed for determining whther nodes are virgin nodes#
get.num.tips <- function (node, phy)#
{#
	n <- length(node.leaves(phy,node));#
	return(n);#
}#
#
#
## This generates the indices of all descendants of a node, using ape's edge matrix.#
## Deals with row numbers of the edge matrix rather than node numbers of the tree.#
descendants.cutAtStem <- function (node, all.edges)#
{#
	ans <- numeric();#
	ans <- node;#
	repeat {#
		node <- all.edges[all.edges[,1] %in% node,2];#
		if (length(node) > 0)#
		{#
			ans <- c(ans, node);#
		} else {break;}#
	}#
	return(unlist(ans));#
}#
#
#
## The function 'descendants' returns the indices of all descendants within the edge matrix.#
descendants.cutAtStem.idx <- function (node.list, all.edges)#
{#
	which(all.edges[,1] == node.list | all.edges[,2] %in% descendants.cutAtStem(node.list, all.edges));#
}#
#
#
## This generates the indices of all descendants of a node, using ape's edge matrix.#
## Deals with row numbers of the edge matrix rather than node numbers of the tree.#
descendants.cutAtNode <- function (node, all.edges)#
{#
	ans <- numeric();#
	repeat {#
		node <- all.edges[all.edges[,1] %in% node,2];#
		if (length(node) > 0)#
		{#
			ans <- c(ans, node);#
		} else {break;}#
	}#
	return(unlist(ans));#
}#
#
#
## The function 'descendants' returns the indices of all descendants within the edge matrix.#
descendants.cutAtNode.idx <- function (node.list, all.edges)#
{#
	which(all.edges[,1] == node.list | all.edges[,2] %in% descendants.cutAtNode(node.list, all.edges));#
}
runTurboMEDUSA(phy, richness, model.limit=37)
summarizeTurboMEDUSA <-#
function(results, modelNum=NULL, cutoff="threshold", criterion="aicc", plotTree=TRUE, time=TRUE, node.labels=TRUE, cex=0.5,#
	plotSurface=FALSE, printTitle=TRUE, n.points=100, ...)#
{#
# Desirables:#
#  1. table listing parameter values of selected model#
#  2. list parameters of base model#
#  3. tree printed with colour-coded edges, node labels to indicate split position(s)#
#  4. plot likelihood surface#
	#
# Extract constituent components from results#
	fit <- results$models;#
	phy <- results$phy;#
	z <- results$z;#
	desc <- results$desc;#
	modelSummary <- results$modelSummary;#
	threshold <- results$threshold;#
	cutAt <- as.character(modelSummary$Cut.at);#
	cutAt[1] <- "NA";#
	#
# First, determine which model is desired#
	model.id <- 0;#
	if (!is.null(modelNum))#
	{#
		model.id <- modelNum;#
	} else {   # Find best model using some criterion (threshold or user-defined)#
		if (cutoff != "threshold") {threshold <- cutoff}#
		else {cat("\nSelecting model based on corrected threshold (improvement in information theoretic score of ", threshold, " units).\n", sep="");}#
		model.id <- 1;#
		while (1)#
		{#
			if ((model.id + 1) > length(fit)) break;#
			if ((unlist(fit[[model.id]][criterion]) - unlist(fit[[model.id+1]][criterion])) < threshold) break;#
			model.id <- model.id + 1;#
		}#
	}#
	#
	break.pts <- fit[[model.id]]$split.at;#
	cuts <- cutAt[1: model.id];#
		#
	opt.model <- cbind(N.Models=seq(1:length(fit[[model.id]]$split.at)), Shift.Node=fit[[model.id]]$split.at, fit[[model.id]]$par, LnLik.part=fit[[model.id]]$lnLik.part)#
	opt.model <- as.data.frame(opt.model);#
	opt.model <- cbind(opt.model[,c(1:2)], Cut.at=cuts, opt.model[,c(3:5)])#
	opt.model[1,2] <- NA # root node for base model#
	#
	base.model <- as.data.frame(fit[[1]]$par);#
	#
	cat("\nEstimated parameter values for model #", model.id, ":\n\n", sep="");#
	print.data.frame(opt.model, digits=5);#
	#
	opt.fit <- 0;#
	base.fit <- 0;#
	if (criterion == "aicc")#
	{#
		opt.fit <- modelSummary$aicc[model.id];#
		base.fit <- modelSummary$aicc[1];#
	} else { # aic used#
		opt.fit <- modelSummary$aic[model.id];#
		base.fit <- modelSummary$aic[1];#
	}#
	cat("\nModel fit summary for model #", model.id, ":\n\n", sep="");#
	cat("\tLog-likelihood = ", as.numeric(results$models[[model.id]]["lnLik"]), "\n", sep="");#
	cat("\t", criterion, " = ", opt.fit, "\n", sep="");#
	#
	if (model.id != 1)#
	{#
		if (modelSummary$N.Param[1] == 1) {model <- "Yule";} else {model <- "BD";}#
		cat("\nFor comparison, estimated values for the base (single homogeneous-", model, ") model are:\n\n", sep="");#
		print.data.frame(base.model, digits=5, row.names=FALSE);#
		cat("\nModel fit summary for base model:\n\n", sep="");#
		cat("\tLog-likelihood = ", as.numeric(results$models[[1]]["lnLik"]), "\n", sep="");#
		cat("\t", criterion, " = ", base.fit, "\n", sep="");#
	}#
	#
# Get desired tree-model conformation#
# Check on cutAtStem option to accurately recover model and paint tree#
	labels <- break.pts;#
	if (length(break.pts) > 1)#
	{#
		labels[1] <- break.pts[1];#
		for (i in 2:length(break.pts))#
		{#
			tmp <- medusa.split(node=break.pts[i], z=z, desc=desc, shiftCut=cutAt[i]);#
			if (cutAt[i] == "stem")#
			{#
				labels[i] <- z[which(z[,"dec"] == break.pts[i]),"anc"]#
			}#
			z <- tmp$z;#
		}#
	}#
	#
	mm <- match(phy$edge[,2], z[,"dec"]);#
# Plot tree with purdy colours and labelled nodes (to better map between tree and table)#
	if (plotTree)#
	{#
		dev.new();#
		margin <- FALSE;#
		#
		if (time) {margin=TRUE;}#
		plot.phylo(phy, edge.color=z[mm,"partition"], no.margin=!margin, cex=cex, ...);#
		if (time)#
		{#
			axisPhylo(cex.axis=0.75);#
			mtext("Divergence Time (MYA)", at=(max(get("last_plot.phylo", envir = .PlotPhyloEnv)$xx)*0.5), side = 1, line = 2, cex=0.75);#
		}#
		if (node.labels) # label with stem/node breaks in mind#
		{#
			for (i in  1:length(break.pts))#
			{#
				nodelabels(i, node=labels[i], frame = "c", font = 1, cex=0.5);#
			}#
		}#
	}#
	#
## Due to my current ineptitude in plotting in R, plotting surface is currently [0,1] for#
#  both r and epsilon, even if values of interest are clustered in some subregion.#
	if (plotSurface)#
	{#
		n.pieces <- length(opt.model[,1]);#
		for (k in 1: n.pieces)#
		{	#
	## *** NEED TO MAKE CHECKS IF CURRENT MODEL IS YULE, AND THEN FIGURE HOW TO PLOT IT ***#
		#	if Yule, need different plot type#
			if (fit[[model.id]]$model[k] == "bd")#
			{#
				lik <- make.lik.medusa.part(z[z[,"partition"] == k,,drop=FALSE], model="bd");#
				#
## center these around the MLEs#
				opt.r <- as.numeric(opt.model[k,"r"]);#
				opt.epsilon <- as.numeric(opt.model[k,"epsilon"]);#
				#
				lik.vals <- matrix(nrow=n.points, ncol=n.points);#
				r.vals <- seq(from=(opt.r/10), to=(opt.r*2), length.out=n.points);#
				eps.vals <- seq(from=1e-10, to=1.0, length.out=n.points);#
				#
				for (i in 1:length(r.vals))#
				{#
					for (j in 1:(length(eps.vals))) {lik.vals[i,j] <- lik(pars=c(r.vals[i], eps.vals[j]));}#
				}#
				if (n.pieces > 1) {cat("Completed computing surface for piecewise model #", k, "\n", sep="");}#
				#
# Contour plot#
				plot.new()#
				#
				max.lik <- as.numeric(opt.model[k,"LnLik.part"])  # MLE#
				#
				lines <- c(max.lik-0.5, max.lik-1, max.lik-2, max.lik-3, max.lik-4, max.lik-5, max.lik-10, max.lik-50, max.lik-100)#
				contour(lik.vals, levels=lines, labels=c(0.5, 1, 2, 3, 4, 5, 10, 50, 100), axes=FALSE, xlab="r (b-d)", ylab="epsilon (d/b)", method="flattest")#
				tics<-floor(c(1, n.points/4, n.points/2, n.points*3/4, n.points));#
				axis(1, at=c(0, 0.25, 0.5, 0.75, 1), labels=round(r.vals[tics], 3));#
				axis(2, at=c(0, 0.25, 0.5, 0.75, 1), labels=round(eps.vals[tics], 3));#
				points(x=opt.r*(1/(min(r.vals)+max(r.vals))), y=opt.epsilon*(1/(min(eps.vals)+max(eps.vals))), pch=16, col="black"); # inferred ML values#
				if (n.pieces > 1 && printTitle) {title(main=paste("Piecewise Birth-Death Model #", k, sep=""));}#
			} else {#
				lik <- make.lik.medusa.part(z[z[,"partition"] == k,,drop=FALSE], model="yule");#
				#
				opt.r <- as.numeric(opt.model[k,"r"]);#
				lik.vals <- numeric(n.points);#
				r.vals <- seq(from=0, to=0.05, length.out=n.points);#
#				r.vals <- seq(from=(opt.r/10), to=(opt.r*2), length.out=n.points);#
				#
				for (i in 1:length(r.vals))#
				{#
					lik.vals[i] <- lik(pars=r.vals[i]);#
				}#
				if (n.pieces > 1) {cat("Completed computing surface for piecewise model #", k, "\n", sep="");}#
				#
				max.lik <- as.numeric(opt.model[k,"LnLik.part"]);  # MLE#
				#
				plot(r.vals, lik.vals, xlab="r (b-d)", ylab="Log-Likelihood", type="l");#
				points(x=opt.r, y=max.lik, pch=16, col="black");#
				if (n.pieces > 1 && printTitle) {title(main=paste("Piecewise Yule Model #", k, sep=""));}#
			}#
		}#
	}#
	treeParameters <- list(z=z, edge.colour=mm, break.pts=break.pts, phy=phy, labels=labels);#
}#
#
#
## Prints out a table of likelihoods, parameters, and aic scores#
calculate.model.fit.summary <- function (models, phy, plotFig, fig.title=NULL, threshold, ...)#
{#
	tmp <- matrix(nrow=(length(models)), ncol=6);#
	colnames(tmp) <- c("N.Models", "Shift.Node", "N.Param", "Ln.Lik", "aic", "aicc");#
	#
	w.aic <- numeric(length(models));#
	w.aicc <- numeric(length(models));#
	cut.at <- character(length(models));#
	model <- character(length(models));#
	#
	for (i in 1:length(tmp[,1]))#
	{#
		tmp[i,] <- c(i, as.integer(models[[i]]$split.at[i]), models[[i]]$num.par, models[[i]]$lnLik, models[[i]]$aic, models[[i]]$aicc);#
		cut.at[i] <- models[[i]]$cut.at[i];#
		model[i] <- models[[i]]$model[i];#
	}#
	cut.at[1] <- "NA";#
	#
	all.res <- as.data.frame(tmp);#
	#
	if (threshold == 0)#
	{#
		w.aic <- round(calculate.model.weights(all.res$aic), digits=5);#
		w.aicc <- round(calculate.model.weights(all.res$aicc), digits=5);#
		all.res <- cbind(all.res[,c(1:2)], Cut.at=cut.at, Model=model, all.res[,c(3:5)], w.aic=w.aic$w, aicc=all.res$aicc, w.aicc=w.aicc$w);#
	} else {#
		all.res <- cbind(all.res[,c(1:2)], Cut.at=cut.at, Model=model, all.res[,c(3:6)]);#
	}#
	#
	all.res[1,2] <- NA # root node for base model#
	#
	if (plotFig)#
	{#
		dev.new();#
		plotModelFit(all.res);#
		if (!is.null(fig.title)) {title(main=fig.title, cex.main=0.75);}#
	}#
	return(all.res);#
}#
#
#
## Self explanatory#
## These are meaningless when using a threshold criterion#
calculate.model.weights <- function (fit)#
{#
	best <- min(fit);#
	delta <- fit-best;#
	sumDelta <- sum(exp(-0.5 * delta));#
	w <- (exp(-0.5 * delta)/sumDelta);#
	#
	results <- data.frame(fit=fit,delta=delta,w=w);#
	#
	return(results);#
}#
#
#
## Create a plot of model-fit vs. model-size#
plotModelFit <- function (all.res)#
{#
	ylim <- c(min(all.res[,"aic"],all.res[,"aicc"]), max(all.res[,"aic"],all.res[,"aicc"]));#
	plot(all.res[,"N.Models"],all.res[,"aicc"], xlab="Number of Piecewise Models", ylab="Model Fit", ylim=ylim, type="l", col="blue");#
	points(all.res[,"N.Models"],all.res[,"aicc"], col="blue", pch=21, bg="white");#
	points(all.res[,"N.Models"],all.res[,"aic"], col="black", type="l");#
	points(all.res[,"N.Models"],all.res[,"aic"], col="black", pch=21, bg="white");#
	#
	legend("topleft", c("aicc","aic"), pch=21, pt.bg="white", lty=1, col=c("blue", "black"), inset = .05, cex=0.75, bty="n"); # 'bottomright' also works#
}
runTurboMEDUSA(phy, richness, model.limit=37)
runTurboMEDUSA(phy, richness, model.limit=38) -> res
runTurboMEDUSA(phy, richness, model.limit=38, model="yule") -> res
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	affected <- c(unique(part[idx]))#
	cat("Am I still alive here?!? affected = ", affected, "\n", sep="")#
#	print(z)#
	foo <- list(z=z, affected=c(unique(part[idx]), tag))#
	cat("Howdy.\n")#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}
runTurboMEDUSA(phy, richness, model.limit=38, model="yule") -> res
## Only used for base model#
medusa.ml.initial <- function (z, initialR, initialE, model)#
{#
	rootnode <- min(z[,"anc"]);#
	obj <- medusa.ml.fit.partition(partition=1, z=z, sp=c(initialR, initialE), model=model);#
	#
	model.fit <- calculate.model.fit(fit=obj, z=z);#
	#
	return(list(par=matrix(obj$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=obj$lnLik, #
	   lnLik=obj$lnLik, split.at=rootnode, aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3], cut.at="node"));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted.#
## shiftCut can only be "stem" or "node" (not "both"), as both are evaluated separately#
medusa.ml.prefit <- function (node, z, desc, initialR, initialE, model, shiftCut, criterion)#
{#
	fitted.bd <- NULL;#
	fitted.yule <- NULL;#
#	fit <- NULL;#
	#
## if model is mixed, grab the optimally fitted one, drop the other; it is cutAtStem that matters, as it is the sum of 2 break likelihoods#
  ## optimal alone may be different than optimal in tandem#
	if (shiftCut == "stem")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.stem <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.stem, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "stem";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.stem <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.stem, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "stem";#
		}#
	} else if (shiftCut == "node")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.node <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.node, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "node";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.node <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.node, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "node";#
		}#
	}#
## Check which flavour of model fits best#
	if (is.null(fitted.bd) & !is.null(fitted.yule))#
	{#
		return(fitted.yule);#
	} else if (is.null(fitted.yule) & !is.null(fitted.bd)) {#
		return(fitted.bd);#
	} else {#
## Dealing with a 'mixed' model here; need to consider number of parameters.#
		bd.model.fit <- calculate.model.fit(fit=fitted.bd, z=z);#
		yule.model.fit <- calculate.model.fit(fit=fitted.yule, z=z);#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		if (is.nan(yule.model.fit[[element]]))#
		{#
			return(fitted.bd);#
		} else if (bd.model.fit[[element]] < yule.model.fit[[element]])#
		{#
			return(fitted.bd);#
		} else {#
			return(fitted.yule);#
		}#
	}#
}#
#
#
#
#
#
#
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
	new.part <- z[z[,"partition"] == partition,,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
	if (length(new.part) == 0)#
	{#
		cat("\nSaved time, bitches!\n")#
		par <- c(NA, NA);#
		return(list(par=par, lnLik=-Inf));#
	} else {#
# Construct likelihood function:#
		lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);#
		foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
		#
		if (model == "bd")#
		{#
			fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
			#
			if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
			#
			return(list(par=exp(fit$par), lnLik=-fit$value));#
		} else {#
			# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
			# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
			# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
			# best.guess2 <- log(node.richness) / #
			#
			# fit <- nlm(log(sp[1]), f=foo)#
			# par <- c(exp(fit$estimate), NA);#
			# return(list(par=par, lnLik=-fit$minimum));#
			#
			fit <- nlminb(log(sp[1]), objective=foo, upper=log(50), control=list(maxiter=1000))#
			par <- c(exp(fit$par), NA);#
			return(list(par=par, lnLik=-fit$objective));#
	#
			# fit <- optimize(f=foo, interval=c(-25, 1));#
			# par <- c(exp(fit$minimum), NA);#
			# return(list(par=par, lnLik=-fit$objective));#
		}#
	}#
}#
#
#
#
#
#
#
## Split the edge matrix 'z' by adding a partition rooted at node 'node'.#
##   Note: in original MEDUSA parlance, this is cutAtStem=T.#
## The list 'desc' is a list of descendants (see make.cache.medusa, above).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
## This is where 'shiftCut' matters#
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	affected <- c(unique(part[idx]))#
	cat("Am I still alive here?!? affected = ", affected, "\n", sep="")#
#	print(z)#
	foo <- list(z=z, affected=c(unique(part[idx]), tag))#
	cat("Howdy.\n")#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, or mixed models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
## fit1 model is already logged; only need to record fit2 model, and only non-prefitted nodes#
medusa.ml.update <- function (node, z, desc, fit, prefit, num.tips, root.node, model, criterion, shiftCut)#
{#
## various combinations possible#
	cat("Attempting to work with node: ", node, ". 'shiftCut' = ", shiftCut, "\n", sep="")#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" || shiftCut == "both" || node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		cat("In 'stem', attempting to work with node: ", node, "\n", sep="")#
		obj.stem <- medusa.split(node=node, z=z, desc=desc, shiftCut="stem");#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		cat("Made it through medusa.split.\n")#
		#
# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'stem', bitches! Working on node #", node, sep="")#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			cat("\ntrying to return fit...")#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="yule");#
			} else {#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="bd");#
			}#
		} else {#
			fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model=model);#
			fit1.stem$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else { # novel shift#
			fit2.stem.bd <- NULL;#
			fit2.stem.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.stem.yule <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="yule");#
				fit2.stem.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.stem.bd <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="bd");#
				fit2.stem.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.stem.bd))#
			{#
				fit2.stem <- fit2.stem.yule;#
			} else if (is.null(fit2.stem.yule)) {#
				fit2.stem <- fit2.stem.bd;#
			} else {#
## Considering both places for a shift#
				fit2.stem.bd.val <- calculate.model.fit(fit=fit2.stem.bd, z=z);#
				fit2.stem.yule.val <- calculate.model.fit(fit=fit2.stem.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.stem.bd.val[[element]] < fit2.stem.yule.val[[element]])#
				{#
					fit2.stem <- fit2.stem.bd;#
				} else {#
					fit2.stem <- fit2.stem.yule;#
				}#
			}#
		}#
	}#
	if ((shiftCut == "node" || shiftCut == "both") && !(node < root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		cat("In 'node', attempting to work with node: ", node, "\n", sep="")#
		obj.node <- medusa.split(node=node, z=z, desc=desc, shiftCut="node");#
		cat("Apparently made is though medusa.split\n")#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		cat("Made it through medusa.split.\n")#
		#
		#
		# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'node', bitches! Working on node #", node, sep="")#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="yule");#
				fit1.node$model <- "yule";#
			} else {#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="bd");#
				fit1.node$model <- "bd";#
			}#
		} else {#
			fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model=model);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.node <- prefit$tips[[node]];#
		} else if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		}#
		else { # novel shift#
			fit2.node.bd <- NULL;#
			fit2.node.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.node.yule <- medusa.ml.fit.partition(aff[2], z.node, sp, model="yule");#
				fit2.node.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.node.bd <- medusa.ml.fit.partition(aff[2], z.node, sp, model="bd");#
				fit2.node.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.node.bd))#
			{#
				fit2.node <- fit2.node.yule;#
			} else if (is.null(fit2.node.yule)) {#
				fit2.node <- fit2.node.bd;#
			} else {#
## Considering both places for a shift#
				fit2.node.bd.val <- calculate.model.fit(fit=fit2.node.bd, z=z);#
				fit2.node.yule.val <- calculate.model.fit(fit=fit2.node.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.node.bd.val[[element]] < fit2.node.yule.val[[element]])#
				{#
					fit2.node <- fit2.node.bd;#
				} else {#
					fit2.node <- fit2.node.yule;#
				}#
			}	#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par);#
		stem.fit <- calculate.model.fit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par);#
		node.fit <- calculate.model.fit(fit=node.val, z=z);#
		#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
#			cat("Stem wins!\n");#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
#			cat("Node wins!\n");#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculate.model.fit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
#
#
#
#
#
#
#
## make.lik.medusa.part: generate a likelihood function for a single partition.#
make.lik.medusa.part <- function (partition, model)#
{#
# Handle internal and pendant edges separately#
	is.int <- is.na(partition[,"n.t"]);#
	is.pend <- !is.int;#
	#
	n.int <- sum(is.int);#
	n.pend <- sum(is.pend);#
	#
## Internal and pendant calculations differ; split'em up#
	int  <- partition[is.int,,drop=FALSE];#
	pend <- partition[is.pend,,drop=FALSE];#
	#
	sum.int.t.len <- sum(int[,"t.len"]);  # Simply sum all internal edges#
	int.t.0 <- int[,"t.0"];#
	#
# 'n.0' = Foote's 'a', initial diversity; 'n.t' = Foote's 'n', final diversity#
	pend.n.0 <- pend[,"n.0"]; # Foote's 'a': initial diversity#
	pend.n.t <- pend[,"n.t"]; # Foote's 'n': final diversity#
	pend.t.len <- pend[,"t.len"];#
	#
	if (n.int + n.pend != length(partition[,1])) stop("You messed up, yo.");#
	#
# User may pass in epsilon; don't change it, just estimate r#
	f <- function(pars)#
	{#
		if (model == "bd")#
		{#
			r <- pars[1];#
			epsilon <- pars[2];#
			#
			if (r <= 0 || epsilon <= 0 || epsilon >= 1) {return(-Inf);}#
		} else {#
			#
			r <- pars[1];#
			epsilon <- 0;#
			#
			if (r <= 0 || is.nan(r)) {return(-Inf);}#
		}#
		#
		l.int <- numeric();#
		l.pend <- numeric();#
		#
		if (n.int == 0) {l.int <- 0;} else {#
## Likelihood of internal edges from Rabosky et al. (2007) equation (2.3):#
			l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
		}#
		#
		if (n.pend == 0) {l.pend <- 0} else {#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
			#
			ert <- exp(r * pend.t.len);#
			B <- (ert - 1) / (ert - epsilon); # Equivalently: B <- (bert - b) / (bert - d)#
			#
			l.pend <- sum(log(1 - B) + (pend.n.t - 1)*log(B));#
		}#
		return(l.int + l.pend);#
	}#
}#
#
#
## 'fit' contains '$par' and '$lnlik'#
calculate.model.fit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	#
# Updated for more general models: check how many parameter values != NA#
#	k <- 2 + (3 * (num.models - 1))#
	k <- sum(!is.na(fit$par)) + (num.models - 1); # number of estimated parameters + number of breaks#
	#
	lnLik <- fit$lnLik;#
	#
	aic <- (-2 * lnLik) + (2*k);#
	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
get.b.d <- function (r, epsilon)#
{#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
## Print out tree with ape-style node-numbering#
## Possibly of interest for users to identify numbers of node(s) off interest#
 ## If this is the case, make sure to pass in pruned tree#
plotNN <- function (phy, time=TRUE, margin=TRUE, label.offset=0.5, cex=0.5, ...) #
{#
	phy$node.label <- (length(phy$tip.label) + 1):max(phy$edge);#
	plot.phylo(phy, show.node.label=TRUE, no.margin=!margin, label.offset=label.offset, cex=cex, ...);#
	if (time && !margin) {cat("Cannot plot time axis without a margin.\n");}#
	else if (time && margin) {axisPhylo(cex.axis=0.75)};#
}
runTurboMEDUSA(phy, richness, model.limit=38, model="yule") -> res
## Only used for base model#
medusa.ml.initial <- function (z, initialR, initialE, model)#
{#
	rootnode <- min(z[,"anc"]);#
	obj <- medusa.ml.fit.partition(partition=1, z=z, sp=c(initialR, initialE), model=model);#
	#
	model.fit <- calculate.model.fit(fit=obj, z=z);#
	#
	return(list(par=matrix(obj$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=obj$lnLik, #
	   lnLik=obj$lnLik, split.at=rootnode, aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3], cut.at="node"));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted.#
## shiftCut can only be "stem" or "node" (not "both"), as both are evaluated separately#
medusa.ml.prefit <- function (node, z, desc, initialR, initialE, model, shiftCut, criterion)#
{#
	fitted.bd <- NULL;#
	fitted.yule <- NULL;#
#	fit <- NULL;#
	#
## if model is mixed, grab the optimally fitted one, drop the other; it is cutAtStem that matters, as it is the sum of 2 break likelihoods#
  ## optimal alone may be different than optimal in tandem#
	if (shiftCut == "stem")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.stem <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.stem, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "stem";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.stem <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.stem, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "stem";#
		}#
	} else if (shiftCut == "node")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.node <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.node, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "node";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.node <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.node, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "node";#
		}#
	}#
## Check which flavour of model fits best#
	if (is.null(fitted.bd) & !is.null(fitted.yule))#
	{#
		return(fitted.yule);#
	} else if (is.null(fitted.yule) & !is.null(fitted.bd)) {#
		return(fitted.bd);#
	} else {#
## Dealing with a 'mixed' model here; need to consider number of parameters.#
		bd.model.fit <- calculate.model.fit(fit=fitted.bd, z=z);#
		yule.model.fit <- calculate.model.fit(fit=fitted.yule, z=z);#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		if (is.nan(yule.model.fit[[element]]))#
		{#
			return(fitted.bd);#
		} else if (bd.model.fit[[element]] < yule.model.fit[[element]])#
		{#
			return(fitted.bd);#
		} else {#
			return(fitted.yule);#
		}#
	}#
}#
#
#
#
#
#
#
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
	new.part <- z[z[,"partition"] == partition,,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
	if (length(new.part) == 0)#
	{#
		cat("\nSaved time, bitches!\n")#
		par <- c(NA, NA);#
		return(list(par=par, lnLik=-Inf));#
	} else {#
# Construct likelihood function:#
		lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);#
		foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
		#
		if (model == "bd")#
		{#
			fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
			#
			if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
			#
			return(list(par=exp(fit$par), lnLik=-fit$value));#
		} else {#
			# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
			# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
			# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
			# best.guess2 <- log(node.richness) / #
			#
			# fit <- nlm(log(sp[1]), f=foo)#
			# par <- c(exp(fit$estimate), NA);#
			# return(list(par=par, lnLik=-fit$minimum));#
			#
			fit <- nlminb(log(sp[1]), objective=foo, upper=log(50), control=list(maxiter=1000))#
			par <- c(exp(fit$par), NA);#
			return(list(par=par, lnLik=-fit$objective));#
	#
			# fit <- optimize(f=foo, interval=c(-25, 1));#
			# par <- c(exp(fit$minimum), NA);#
			# return(list(par=par, lnLik=-fit$objective));#
		}#
	}#
}#
#
#
#
#
#
#
## Split the edge matrix 'z' by adding a partition rooted at node 'node'.#
##   Note: in original MEDUSA parlance, this is cutAtStem=T.#
## The list 'desc' is a list of descendants (see make.cache.medusa, above).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
## This is where 'shiftCut' matters#
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	affected <- c(unique(part[idx]))#
	cat("Am I still alive here?!? affected = ", affected, "\n", sep="")#
#	print(z)#
	foo <- list(z=z, affected=c(unique(part[idx]), tag))#
	cat("Howdy.\n")#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, or mixed models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
## fit1 model is already logged; only need to record fit2 model, and only non-prefitted nodes#
medusa.ml.update <- function (node, z, desc, fit, prefit, num.tips, root.node, model, criterion, shiftCut)#
{#
## various combinations possible#
	cat("Attempting to work with node: ", node, ". 'shiftCut' = ", shiftCut, "\n", sep="")#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" || shiftCut == "both" || node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		cat("In 'stem', attempting to work with node: ", node, "\n", sep="")#
		obj.stem <- medusa.split(node=node, z=z, desc=desc, shiftCut="stem");#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		cat("Made it through medusa.split.\n")#
		#
# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'stem', bitches! Working on node #", node, sep="")#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			cat("\ntrying to return fit...")#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="yule");#
			} else {#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="bd");#
			}#
		} else {#
			fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model=model);#
			fit1.stem$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else { # novel shift#
			fit2.stem.bd <- NULL;#
			fit2.stem.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.stem.yule <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="yule");#
				fit2.stem.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.stem.bd <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="bd");#
				fit2.stem.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.stem.bd))#
			{#
				fit2.stem <- fit2.stem.yule;#
			} else if (is.null(fit2.stem.yule)) {#
				fit2.stem <- fit2.stem.bd;#
			} else {#
## Considering both places for a shift#
				fit2.stem.bd.val <- calculate.model.fit(fit=fit2.stem.bd, z=z);#
				fit2.stem.yule.val <- calculate.model.fit(fit=fit2.stem.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.stem.bd.val[[element]] < fit2.stem.yule.val[[element]])#
				{#
					fit2.stem <- fit2.stem.bd;#
				} else {#
					fit2.stem <- fit2.stem.yule;#
				}#
			}#
		}#
	}#
	if ((shiftCut == "node" || shiftCut == "both") && !(node < root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		cat("In 'node', attempting to work with node: ", node, "\n", sep="")#
		obj.node <- medusa.split(node=node, z=z, desc=desc, shiftCut="node");#
		cat("Apparently made is though medusa.split\n")#
		#
		if (is.null(aff[1])) {cat("Found you, asshole.\n")}#
		#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		cat("Made it through medusa.split.\n")#
		#
		#
		# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'node', bitches! Working on node #", node, sep="")#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="yule");#
				fit1.node$model <- "yule";#
			} else {#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="bd");#
				fit1.node$model <- "bd";#
			}#
		} else {#
			fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model=model);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.node <- prefit$tips[[node]];#
		} else if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		}#
		else { # novel shift#
			fit2.node.bd <- NULL;#
			fit2.node.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.node.yule <- medusa.ml.fit.partition(aff[2], z.node, sp, model="yule");#
				fit2.node.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.node.bd <- medusa.ml.fit.partition(aff[2], z.node, sp, model="bd");#
				fit2.node.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.node.bd))#
			{#
				fit2.node <- fit2.node.yule;#
			} else if (is.null(fit2.node.yule)) {#
				fit2.node <- fit2.node.bd;#
			} else {#
## Considering both places for a shift#
				fit2.node.bd.val <- calculate.model.fit(fit=fit2.node.bd, z=z);#
				fit2.node.yule.val <- calculate.model.fit(fit=fit2.node.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.node.bd.val[[element]] < fit2.node.yule.val[[element]])#
				{#
					fit2.node <- fit2.node.bd;#
				} else {#
					fit2.node <- fit2.node.yule;#
				}#
			}	#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par);#
		stem.fit <- calculate.model.fit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par);#
		node.fit <- calculate.model.fit(fit=node.val, z=z);#
		#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
#			cat("Stem wins!\n");#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
#			cat("Node wins!\n");#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculate.model.fit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
#
#
#
#
#
#
#
## make.lik.medusa.part: generate a likelihood function for a single partition.#
make.lik.medusa.part <- function (partition, model)#
{#
# Handle internal and pendant edges separately#
	is.int <- is.na(partition[,"n.t"]);#
	is.pend <- !is.int;#
	#
	n.int <- sum(is.int);#
	n.pend <- sum(is.pend);#
	#
## Internal and pendant calculations differ; split'em up#
	int  <- partition[is.int,,drop=FALSE];#
	pend <- partition[is.pend,,drop=FALSE];#
	#
	sum.int.t.len <- sum(int[,"t.len"]);  # Simply sum all internal edges#
	int.t.0 <- int[,"t.0"];#
	#
# 'n.0' = Foote's 'a', initial diversity; 'n.t' = Foote's 'n', final diversity#
	pend.n.0 <- pend[,"n.0"]; # Foote's 'a': initial diversity#
	pend.n.t <- pend[,"n.t"]; # Foote's 'n': final diversity#
	pend.t.len <- pend[,"t.len"];#
	#
	if (n.int + n.pend != length(partition[,1])) stop("You messed up, yo.");#
	#
# User may pass in epsilon; don't change it, just estimate r#
	f <- function(pars)#
	{#
		if (model == "bd")#
		{#
			r <- pars[1];#
			epsilon <- pars[2];#
			#
			if (r <= 0 || epsilon <= 0 || epsilon >= 1) {return(-Inf);}#
		} else {#
			#
			r <- pars[1];#
			epsilon <- 0;#
			#
			if (r <= 0 || is.nan(r)) {return(-Inf);}#
		}#
		#
		l.int <- numeric();#
		l.pend <- numeric();#
		#
		if (n.int == 0) {l.int <- 0;} else {#
## Likelihood of internal edges from Rabosky et al. (2007) equation (2.3):#
			l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
		}#
		#
		if (n.pend == 0) {l.pend <- 0} else {#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
			#
			ert <- exp(r * pend.t.len);#
			B <- (ert - 1) / (ert - epsilon); # Equivalently: B <- (bert - b) / (bert - d)#
			#
			l.pend <- sum(log(1 - B) + (pend.n.t - 1)*log(B));#
		}#
		return(l.int + l.pend);#
	}#
}#
#
#
## 'fit' contains '$par' and '$lnlik'#
calculate.model.fit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	#
# Updated for more general models: check how many parameter values != NA#
#	k <- 2 + (3 * (num.models - 1))#
	k <- sum(!is.na(fit$par)) + (num.models - 1); # number of estimated parameters + number of breaks#
	#
	lnLik <- fit$lnLik;#
	#
	aic <- (-2 * lnLik) + (2*k);#
	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
get.b.d <- function (r, epsilon)#
{#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
## Print out tree with ape-style node-numbering#
## Possibly of interest for users to identify numbers of node(s) off interest#
 ## If this is the case, make sure to pass in pruned tree#
plotNN <- function (phy, time=TRUE, margin=TRUE, label.offset=0.5, cex=0.5, ...) #
{#
	phy$node.label <- (length(phy$tip.label) + 1):max(phy$edge);#
	plot.phylo(phy, show.node.label=TRUE, no.margin=!margin, label.offset=label.offset, cex=cex, ...);#
	if (time && !margin) {cat("Cannot plot time axis without a margin.\n");}#
	else if (time && margin) {axisPhylo(cex.axis=0.75)};#
}
runTurboMEDUSA(phy, richness, model.limit=38, model="yule") -> res
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	affected <- c(unique(part[idx]))#
	cat("Am I still alive here?!? affected = ", affected, "\n", sep="")#
#	print(z)#
	foo <- list(z=z, affected=c(unique(part[idx]), tag))#
	print(foo)#
	cat("Howdy.\n")#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}
runTurboMEDUSA(phy, richness, model.limit=38, model="yule") -> res
## Only used for base model#
medusa.ml.initial <- function (z, initialR, initialE, model)#
{#
	rootnode <- min(z[,"anc"]);#
	obj <- medusa.ml.fit.partition(partition=1, z=z, sp=c(initialR, initialE), model=model);#
	#
	model.fit <- calculate.model.fit(fit=obj, z=z);#
	#
	return(list(par=matrix(obj$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=obj$lnLik, #
	   lnLik=obj$lnLik, split.at=rootnode, aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3], cut.at="node"));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted.#
## shiftCut can only be "stem" or "node" (not "both"), as both are evaluated separately#
medusa.ml.prefit <- function (node, z, desc, initialR, initialE, model, shiftCut, criterion)#
{#
	fitted.bd <- NULL;#
	fitted.yule <- NULL;#
#	fit <- NULL;#
	#
## if model is mixed, grab the optimally fitted one, drop the other; it is cutAtStem that matters, as it is the sum of 2 break likelihoods#
  ## optimal alone may be different than optimal in tandem#
	if (shiftCut == "stem")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.stem <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.stem, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "stem";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.stem <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.stem, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "stem";#
		}#
	} else if (shiftCut == "node")#
	{#
		obj <- medusa.split(node=node, z=z, desc=desc, shiftCut=shiftCut);#
		if (model == "bd" || model == "mixed")#
		{#
			z.bd.node <- obj$z;#
			fitted.bd <- medusa.ml.fit.partition(partition=2, z=z.bd.node, sp=c(initialR, initialE), model="bd");#
			fitted.bd$model <- "bd";#
			fitted.bd$cut.at <- "node";#
		}#
		if (model == "yule" || model == "mixed")#
		{#
			z.yule.node <- obj$z;#
			fitted.yule <- medusa.ml.fit.partition(partition=2, z=z.yule.node, sp=c(initialR, initialE), model="yule");#
			fitted.yule$model <- "yule";#
			fitted.yule$cut.at <- "node";#
		}#
	}#
## Check which flavour of model fits best#
	if (is.null(fitted.bd) & !is.null(fitted.yule))#
	{#
		return(fitted.yule);#
	} else if (is.null(fitted.yule) & !is.null(fitted.bd)) {#
		return(fitted.bd);#
	} else {#
## Dealing with a 'mixed' model here; need to consider number of parameters.#
		bd.model.fit <- calculate.model.fit(fit=fitted.bd, z=z);#
		yule.model.fit <- calculate.model.fit(fit=fitted.yule, z=z);#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		if (is.nan(yule.model.fit[[element]]))#
		{#
			return(fitted.bd);#
		} else if (bd.model.fit[[element]] < yule.model.fit[[element]])#
		{#
			return(fitted.bd);#
		} else {#
			return(fitted.yule);#
		}#
	}#
}#
#
#
#
#
#
#
## sp = initializing values for r & epsilon#
## Default values should never be used (except for first model), as the values from the previous model are passed in#
medusa.ml.fit.partition <- function (partition, z, sp=c(0.05, 0.5), model)#
{#
	new.part <- z[z[,"partition"] == partition,,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
	if (length(new.part) == 0)#
	{#
		cat("\nSaved time, bitches!\n")#
		par <- c(NA, NA);#
		return(list(par=par, lnLik=-Inf));#
	} else {#
# Construct likelihood function:#
		lik <- make.lik.medusa.part(partition=(z[z[,"partition"] == partition,,drop=FALSE]), model=model);#
		foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
		#
		if (model == "bd")#
		{#
			fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=1000)); # last argument connotes maximization#
			#
			if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
			#
			return(list(par=exp(fit$par), lnLik=-fit$value));#
		} else {#
			# node.richness <- sum(z[z[,"partition"] == partition,"n.t"], na.rm=TRUE);#
			# sum.time <- sum(z[z[,"partition"] == partition,"t.len"], na.rm=TRUE);#
			# best.guess <- (node.richness - 2 + (1 + 2^-50)) / (sum.time + (1 + 2^-50));#
			# best.guess2 <- log(node.richness) / #
			#
			# fit <- nlm(log(sp[1]), f=foo)#
			# par <- c(exp(fit$estimate), NA);#
			# return(list(par=par, lnLik=-fit$minimum));#
			#
			fit <- nlminb(log(sp[1]), objective=foo, upper=log(50), control=list(maxiter=1000))#
			par <- c(exp(fit$par), NA);#
			return(list(par=par, lnLik=-fit$objective));#
	#
			# fit <- optimize(f=foo, interval=c(-25, 1));#
			# par <- c(exp(fit$minimum), NA);#
			# return(list(par=par, lnLik=-fit$objective));#
		}#
	}#
}#
#
#
#
#
#
#
## Split the edge matrix 'z' by adding a partition rooted at node 'node'.#
##   Note: in original MEDUSA parlance, this is cutAtStem=T.#
## The list 'desc' is a list of descendants (see make.cache.medusa, above).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
## This is where 'shiftCut' matters#
medusa.split <- function (node, z, desc, shiftCut)#
{#
	descendants <- NULL;#
	base <- NULL;#
	part <- z[,"partition"];#
	#
	if (shiftCut == "stem")#
	{#
		descendants <- desc$desc.stem;#
	} else {#
		descendants <- desc$desc.node;#
	}#
	#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	cat("base =", base, "\n")#
	tag <- max(part) + 1;#
	cat("tag =", tag, "\n")#
	i <- descendants[[node]];#
	cat("i =", i, "\n")#
	idx <- i[part[i] == base];#
	cat("idx =", idx, "\n")#
	z[idx,"partition"] <- tag;#
	cat("Am I still alive?\n")#
	z[which(z["dec"] == node),"partition"] <- tag; # Possible to have several edges to consider#
	affected <- c(unique(part[idx]))#
	cat("Am I still alive here?!? affected = ", affected, "\n", sep="")#
#	print(z)#
	foo <- list(z=z, affected=c(unique(part[idx]), tag))#
	print(foo)#
	cat("Howdy.\n")#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, or mixed models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
## fit1 model is already logged; only need to record fit2 model, and only non-prefitted nodes#
medusa.ml.update <- function (node, z, desc, fit, prefit, num.tips, root.node, model, criterion, shiftCut)#
{#
## various combinations possible#
	cat("Attempting to work with node: ", node, ". 'shiftCut' = ", shiftCut, "\n", sep="")#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" || shiftCut == "both" || node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		cat("In 'stem', attempting to work with node: ", node, "\n", sep="")#
		obj.stem <- medusa.split(node=node, z=z, desc=desc, shiftCut="stem");#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		cat("Made it through medusa.split.\n")#
		#
# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'stem', bitches! Working on node #", node, sep="")#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			cat("\ntrying to return fit...")#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="yule");#
			} else {#
				fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model="bd");#
			}#
		} else {#
			fit1.stem <- medusa.ml.fit.partition(partition=aff[1], z=z.stem, sp=sp, model=model);#
			fit1.stem$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else { # novel shift#
			fit2.stem.bd <- NULL;#
			fit2.stem.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.stem.yule <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="yule");#
				fit2.stem.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.stem.bd <- medusa.ml.fit.partition(aff[2], z.stem, sp=sp, model="bd");#
				fit2.stem.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.stem.bd))#
			{#
				fit2.stem <- fit2.stem.yule;#
			} else if (is.null(fit2.stem.yule)) {#
				fit2.stem <- fit2.stem.bd;#
			} else {#
## Considering both places for a shift#
				fit2.stem.bd.val <- calculate.model.fit(fit=fit2.stem.bd, z=z);#
				fit2.stem.yule.val <- calculate.model.fit(fit=fit2.stem.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.stem.bd.val[[element]] < fit2.stem.yule.val[[element]])#
				{#
					fit2.stem <- fit2.stem.bd;#
				} else {#
					fit2.stem <- fit2.stem.yule;#
				}#
			}#
		}#
	}#
	if ((shiftCut == "node" || shiftCut == "both") && !(node < root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		cat("In 'node', attempting to work with node: ", node, "\n", sep="")#
		obj.node <- medusa.split(node=node, z=z, desc=desc, shiftCut="node");#
		cat("Apparently made is though medusa.split\n")#
		#
		if (is.null(aff[1])) {cat("Found you, aff[1], asshole.\n")}#
		if (is.null(aff[2])) {cat("Found you, aff[1], asshole.\n")}#
		#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		cat("Made it through medusa.split.\n")#
		#
		#
		# Check to see if aff[1] is missing from z. If so, kill it. Won't be aff[2]#
		#
		new.part.1 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		new.part.2 <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
# Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (length(new.part.1) == 0 || length(new.part.2) == 0)#
		{#
			cat("\nHere I am, in 'node', bitches! Working on node #", node, sep="")#
			#
#			op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
			#
			lnLik <- -Inf;#
			#
			fit$par <- rbind(op, c(NA, NA));#
			fit$lnLik.part[aff] <- c(lnLik, lnLik);#
			fit$split.at <- c(fit$split.at, node);#
			fit$lnLik <- sum(fit$lnLik.part);#
			#
			model.fit <- calculate.model.fit(fit=fit, z=z);#
			#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			fit$num.par <- Inf;#
			fit$cut.at <- c(fit$cut.at, "stem");#
			fit$model <- c(fit$model, model);#
			#
			return(fit);#
		}#
		#
		#
		#
		#
		#
		#
		#
		#
		#
		if (model == "mixed") ## In mixed models, want to conserve flavour of previously fit model (right?)#
		{#
			if (sum(!is.na(sp)) < 2) # yule#
			{#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="yule");#
				fit1.node$model <- "yule";#
			} else {#
				fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model="bd");#
				fit1.node$model <- "bd";#
			}#
		} else {#
			fit1.node <- medusa.ml.fit.partition(partition=aff[1], z=z.node, sp=sp, model=model);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.node <- prefit$tips[[node]];#
		} else if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		}#
		else { # novel shift#
			fit2.node.bd <- NULL;#
			fit2.node.yule <- NULL;#
			#
			if (model == "yule" || model == "mixed")#
			{#
				fit2.node.yule <- medusa.ml.fit.partition(aff[2], z.node, sp, model="yule");#
				fit2.node.yule$model <- "yule";#
			}#
			if (model == "bd" || model == "mixed")#
			{#
				if (is.na(sp[2])) {sp[2] <- 0.5;}#
				fit2.node.bd <- medusa.ml.fit.partition(aff[2], z.node, sp, model="bd");#
				fit2.node.bd$model <- "bd";#
			}#
## Figure out which model fits best#
			if (is.null(fit2.node.bd))#
			{#
				fit2.node <- fit2.node.yule;#
			} else if (is.null(fit2.node.yule)) {#
				fit2.node <- fit2.node.bd;#
			} else {#
## Considering both places for a shift#
				fit2.node.bd.val <- calculate.model.fit(fit=fit2.node.bd, z=z);#
				fit2.node.yule.val <- calculate.model.fit(fit=fit2.node.yule, z=z);#
				#
				if (criterion == "aic") {element <- 1;} else {element <- 2;}#
				#
				if (fit2.node.bd.val[[element]] < fit2.node.yule.val[[element]])#
				{#
					fit2.node <- fit2.node.bd;#
				} else {#
					fit2.node <- fit2.node.yule;#
				}#
			}	#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par);#
		stem.fit <- calculate.model.fit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par);#
		node.fit <- calculate.model.fit(fit=node.val, z=z);#
		#
		element <- NULL;#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
#			cat("Stem wins!\n");#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
#			cat("Node wins!\n");#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculate.model.fit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
#
#
#
#
#
#
#
## make.lik.medusa.part: generate a likelihood function for a single partition.#
make.lik.medusa.part <- function (partition, model)#
{#
# Handle internal and pendant edges separately#
	is.int <- is.na(partition[,"n.t"]);#
	is.pend <- !is.int;#
	#
	n.int <- sum(is.int);#
	n.pend <- sum(is.pend);#
	#
## Internal and pendant calculations differ; split'em up#
	int  <- partition[is.int,,drop=FALSE];#
	pend <- partition[is.pend,,drop=FALSE];#
	#
	sum.int.t.len <- sum(int[,"t.len"]);  # Simply sum all internal edges#
	int.t.0 <- int[,"t.0"];#
	#
# 'n.0' = Foote's 'a', initial diversity; 'n.t' = Foote's 'n', final diversity#
	pend.n.0 <- pend[,"n.0"]; # Foote's 'a': initial diversity#
	pend.n.t <- pend[,"n.t"]; # Foote's 'n': final diversity#
	pend.t.len <- pend[,"t.len"];#
	#
	if (n.int + n.pend != length(partition[,1])) stop("You messed up, yo.");#
	#
# User may pass in epsilon; don't change it, just estimate r#
	f <- function(pars)#
	{#
		if (model == "bd")#
		{#
			r <- pars[1];#
			epsilon <- pars[2];#
			#
			if (r <= 0 || epsilon <= 0 || epsilon >= 1) {return(-Inf);}#
		} else {#
			#
			r <- pars[1];#
			epsilon <- 0;#
			#
			if (r <= 0 || is.nan(r)) {return(-Inf);}#
		}#
		#
		l.int <- numeric();#
		l.pend <- numeric();#
		#
		if (n.int == 0) {l.int <- 0;} else {#
## Likelihood of internal edges from Rabosky et al. (2007) equation (2.3):#
			l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
		}#
		#
		if (n.pend == 0) {l.pend <- 0} else {#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
			#
			ert <- exp(r * pend.t.len);#
			B <- (ert - 1) / (ert - epsilon); # Equivalently: B <- (bert - b) / (bert - d)#
			#
			l.pend <- sum(log(1 - B) + (pend.n.t - 1)*log(B));#
		}#
		return(l.int + l.pend);#
	}#
}#
#
#
## 'fit' contains '$par' and '$lnlik'#
calculate.model.fit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	#
# Updated for more general models: check how many parameter values != NA#
#	k <- 2 + (3 * (num.models - 1))#
	k <- sum(!is.na(fit$par)) + (num.models - 1); # number of estimated parameters + number of breaks#
	#
	lnLik <- fit$lnLik;#
	#
	aic <- (-2 * lnLik) + (2*k);#
	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
get.b.d <- function (r, epsilon)#
{#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
## Print out tree with ape-style node-numbering#
## Possibly of interest for users to identify numbers of node(s) off interest#
 ## If this is the case, make sure to pass in pruned tree#
plotNN <- function (phy, time=TRUE, margin=TRUE, label.offset=0.5, cex=0.5, ...) #
{#
	phy$node.label <- (length(phy$tip.label) + 1):max(phy$edge);#
	plot.phylo(phy, show.node.label=TRUE, no.margin=!margin, label.offset=label.offset, cex=cex, ...);#
	if (time && !margin) {cat("Cannot plot time axis without a margin.\n");}#
	else if (time && margin) {axisPhylo(cex.axis=0.75)};#
}
runTurboMEDUSA(phy, richness, model.limit=38, model="yule") -> res

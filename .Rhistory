## Only used for base model#
medusaMLFitBase <- function (z, sp, model, fixPar, criterion)#
{#
	fit <- getOptimalModelFlavour(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	steps <- c("add", as.numeric(min(z[,"anc"])));#
	#
	return(list(par=matrix(fit$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=fit$lnLik, lnLik=fit$lnLik,#
		split.at=min(z[,"anc"]), aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3],#
		cut.at="node", model=fit$model, z=z, step=matrix(steps, nrow=1, dimnames=list(NULL,c("step", "node")))));#
}#
#
#
## Split the edge matrix 'z' by adding a partition at node 'node'.#
## The list 'desc' is a list of descendants (see makeCacheMedusa).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
medusaSplitStem <- function (node, z, desc, extract=FALSE)#
{#
	part <- z[,"partition"];#
	base <- min(part[z[,"anc"] == node | z[,"dec"] == node]);#
	tag <- max(part) + 1;#
	i <- desc[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	if (extract) {z <- z[idx,,drop=FALSE];}#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
medusaSplitNode <- function (node, z, desc, extract=FALSE)#
{#
	part <- z[,"partition"];#
	base <- min(part[z[,"anc"] == node]);#
	tag <- max(part) + 1;#
	i <- desc[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	if (extract) {z <- z[idx,,drop=FALSE];}#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
## The general function for when the flavour of shiftCut is unknown#
medusaSplit <- function (node, z, desc, shiftCut)#
{#
	descendants <- desc$stem; # will be correct half the time#
	if (shiftCut == "node") {descendants <- desc$node;}#
	#
	part <- z[,"partition"];#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted, especially for large trees.#
prefitTips <- function (pend.nodes, z, sp, model, fixPar, criterion, mc, numCores)#
{#
	if (all(z[z[,"dec"] %in% pend.nodes,"n.t"] == 1) && (model == "yule" || model == "mixed"))#
	{#
		fit <- list(list(par=c(0, NA), lnLik=0, model="yule"));#
		fit <- rep(fit, length(pend.nodes));#
		return(fit);#
	}#
	#
	if (model == "mixed") # yule will always have a better AIC for tip, regardless of richness#
	{#
		if (mc) {#
			tips <- mclapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model="yule", fixPar=fixPar, criterion=criterion, mc.cores=numCores);#
		} else {#
			tips <- lapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model="yule", fixPar=fixPar, criterion=criterion);#
		}#
	} else {#
		if (mc) {#
			tips <- mclapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model=model, fixPar=fixPar, criterion=criterion, mc.cores=numCores);#
		} else {#
			tips <- lapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	return(tips);#
}#
#
medusaMLPrefitTip <- function (node, z, sp, model, fixPar, criterion)#
{#
	z.tip <- z[z[,"dec"] == node,,drop=FALSE];#
	#
	if (all(z.tip[,"n.t"] == 1) && (model == "yule" || model == "mixed"))#
	{#
		return(list(par=c(0, NA), lnLik=0, model="yule"));#
	}#
	#
	fit <- getOptimalModelFlavour(z=z.tip, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
medusaMLPrefitNode <- function (node, z, desc, sp, model, fixPar, criterion)#
{#
	z.node <- medusaSplitNode(node=node, z=z, desc=desc, extract=TRUE)$z;#
	fit <- getOptimalModelFlavour(z=z.node, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
medusaMLPrefitStem <- function (node, z, desc, sp, model, fixPar, criterion)#
{#
	z.stem <- medusaSplitStem(node=node, z=z, desc=desc, extract=TRUE)$z;#
#	z.stem <- z.stem[z.stem[,"partition"] == 2,,drop=FALSE];#
	fit <- getOptimalModelFlavour(z=z.stem, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
#
## When model == mixed, fit both and find optimal flavour#
getOptimalModelFlavour <- function (z, sp, model, fixPar, criterion)#
{#
	fit.bd <- NULL;#
	fit.yule <- NULL;#
	fit <- NULL;#
	#
	if (model == "yule" | model == "mixed")#
	{#
		fit.yule <- medusaMLFitPartition(z=z, sp=sp, model="yule");#
		fit.yule$model <- "yule";#
	}#
	if (model == "bd" | model == "mixed")#
	{#
		if (is.na(sp[2])) {sp[2] <- 0.5;}#
		fit.bd <- medusaMLFitPartition(z=z, sp=sp, model="bd");#
		fit.bd$model <- "bd";#
	}#
	if (model != "mixed" && model != "bd" && model != "yule") # i.e. the constrained models#
	{#
		fit <- medusaMLFitPartition(z=z, sp=sp, model=model, fixPar=fixPar);#
		fit$model <- model;#
		return(fit);#
	}#
	#
## Figure out which model fits best#
	if (is.null(fit.bd))#
	{#
		fit <- fit.yule;#
	} else if (is.null(fit.yule)) {#
		fit <- fit.bd;#
	} else {#
## Considering both models#
		fit <- getBestPartialModel(fit1=fit.yule, fit2=fit.bd, z=z, criterion=criterion);#
		#
		#
		# fit.bd.val <- calculateModelFit(fit=fit.bd, z=z); ## NOT valid here, as sample size is NOT z#
		# fit.yule.val <- calculateModelFit(fit=fit.yule, z=z);#
		#
## The length condition below deals with single edges, where AICc correction becomes undefined (n-k-1)#
  # Undefined#
	}#
	return(fit);#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
medusaMLUpdate <- function (node, z, desc, fit, prefit, num.tips, root.node, model, fixPar, criterion, shiftCut, preserveModelFlavour)#
{#
## various combinations possible#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cool <- TRUE;#
	#
	# new.part.1 <- NULL;#
	# new.part.2 <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" | shiftCut == "both" | node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		obj.stem <- medusaSplitStem(node=node, z=z, desc=desc$stem);#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
		if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
		{#
			fit$lnLik <- -Inf;#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			return(fit);#
		}#
		#
## Everything is cool; proceed.#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
## first, consider diminshed clade. may result in a clade that has been cached previously#
		dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		#
## check if diminished clade conforms to a cached clade#
		x <- which(dimClade[,"anc"] == min(dimClade[,"anc"]));#
		if (length(x) == 1) # a cut-at-stem scenario#
		{#
			y <- as.numeric(dimClade[x, "dec"]);#
			if (length(unique(dimClade[(dimClade[,"dec"] < root.node),"dec"])) == prefit$num.tips[[y]])#
			{#
				if (y < root.node)#
				{#
					fit1.stem <- prefit$tips[[y]];#
				} else {#
					fit1.stem <- prefit$virgin.nodes$stem[[y - root.node]];#
				}#
#				cat("Worked! Clade is of size:", length(dimClade[,1]), "\n")#
			}#
		}#
				#
		if(is.null(fit1.stem))#
		{#
			if (model == "mixed")#
			{#
				if (preserveModelFlavour)  ## In mixed models, may want to conserve flavour of previously fit model#
				{#
					if (sum(!is.na(sp)) < 2) # yule#
					{#
						fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model="yule");#
					} else {#
						fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model="bd");#
					}#
				} else {#
## consider both model flavours#
					fit1.stem <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
				}#
			} else {#
				fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model=model, fixPar=fixPar);#
				fit1.stem$model <- model;#
			}#
		}#
		#
		#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == prefit$num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else {#
## novel shift#
			newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
			fit2.stem <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	#
	if ((shiftCut == "node" || shiftCut == "both") && (node > root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		obj.node <- medusaSplitNode(node=node, z=z, desc=desc$node);#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		#
## Need to check if cut is valid. May be inadmissable because of pattern of previous breaks (especially with shiftCut=both)#
		if (is.na(aff[1]) || is.na(aff[2]))#
		{#
			cool <- FALSE;#
		}		#
## Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (sum(z.node[,"partition"] == aff[1]) == 0 || sum(z.node[,"partition"] == aff[2]) == 0 || !cool)#
		{#
			fit$lnLik <- -Inf;#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			return(fit);#
		}#
		#
## Everything is cool; proceed.#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
## first, consider diminshed clade. may result in a clade that has been cached#
		dimClade <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		#
		if (model == "mixed")#
		{#
			if (preserveModelFlavour)  ## In mixed models, may want to conserve flavour of previously fit model#
			{#
				if (sum(!is.na(sp)) < 2) # yule#
				{#
					fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model="yule"); # should this change? probably.#
				} else {#
					fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model="bd");#
				}#
			} else {#
## consider both model flavours#
				fit1.node <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
			}#
		} else {#
			fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model=model, fixPar=fixPar);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == prefit$num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		} else {#
## novel shift#
			newClade <- z.node[z.node[,"partition"] == aff[2],,drop=FALSE];#
			fit2.node <- getOptimalModelFlavour (z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par, model=model);#
		stem.fit <- calculateModelFit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par, model=model);#
		node.fit <- calculateModelFit(fit=node.val, z=z);#
		#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
## sp = initializing values for r & epsilon. fixPar = fixed value for constrained model.#
## Default values should never be used (except for first model), as the values from the previous model are passed in.#
## The 'suppressWarnings' catches harmless warnings for when extreme parameter values are tried, #
## generating -Inf log-likelihoods. Depends on sclae of the tree.#
medusaMLFitPartition <- function (z, sp=c(0.05, 0.5), model, fixPar=NULL)#
{#
#	new.part <- z[z[,"partition"] == partition.id,,drop=FALSE]; # now subsetted earlier#
	new.part <- z;#
	#
# Construct likelihood function:#
	lik <- makePartitionLikelihood(partition=new.part, model=model, fixPar=fixPar);#
	foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
	#
	if (model == "bd")#
	{#
		fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=5000));#
		#
		if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
		#
		return(list(par=exp(fit$par), lnLik=-fit$value));#
	}#
		#
## grab values to get an intelligent upper bound on b or r#
		node.richness  <- sum(new.part[,"n.t"], na.rm=TRUE);#
		depth <- max(new.part[,"t.0"]);#
		#
# use different intervals based on model flavour#
	#
	if (model == "yule") {#
		#
		maxVal <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {maxVal <- 1e-5;#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-25, log(maxVal))));#
		par <- c(exp(fit$minimum), NA);#
		#
		while (par[1]/maxVal > 0.95) # crash against boundary; doesn't seem to get used...#
		{#
			maxVal <- par[1] * 3;#
			cat("Hit boundary\n")#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(par[1]/2), log(maxVal))));#
			par <- c(exp(fit$minimum), NA);#
		}#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedD") {#
## this is the messiest model flavour; reasonable range depends on magnitude of fixD#
		#
		x <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {x <- 0.01;} # MLE for single tip will be r ~ 0#
		maxVal <- fixPar + x;#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(log(fixPar), log(maxVal))));#
		b <- exp(fit$minimum);#
		par <- c((b - fixPar), (fixPar / b));#
		#
		while (fit$objective == Inf)#
		{#
			cat("maxVal =", maxVal, "; b =", b, "; r =", b - fixPar, "; epsilon =", fixPar/b, "\n")#
			#
			x <- x * 0.75;#
			maxVal <- fixPar + x;#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(fixPar), log(maxVal))));#
			b <- exp(fit$minimum);#
			par <- c((b - fixPar), (fixPar / b));#
		}#
		#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedEpsilon") {#
		#
		maxVal <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {maxVal <- 1;}#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-25, log(maxVal))));#
		par <- c(exp(fit$minimum), sp[2]);#
		#
		while (par[1]/maxVal > 0.9) # crash against boundary#
		{#
			maxVal <- par[1] * 3;#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(par[1]/2), log(maxVal))));#
			par <- c(exp(fit$minimum), sp[2]);#
		}#
		#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedB") {#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-50, log(fixPar))));#
		d <- exp(fit$minimum);#
		par <- c((fixPar - d), (d / fixPar));#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedR") {#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-50, 0)));#
		par <- c(sp[1], exp(fit$minimum));#
		return(list(par=par, lnLik=-fit$objective));#
	}#
}#
#
#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
#
## makePartitionLikelihood: generate a likelihood function for a single partition.#
makePartitionLikelihood <- function (partition, model, fixPar)#
{#
	i.int <- is.na(partition[,"n.t"])#
	i.pend <- !(i.int)#
	n.int <- sum(i.int);#
	#
	simple <- FALSE;#
	if (all(partition[,"n.t"] == 1, na.rm = TRUE)) {simple <- TRUE;}#
	#
	if (simple) {#
		if (model == "yule") {#
			sum.t <- sum(partition[,"t.len"]);#
			f <- function(pars) {#
				if (pars <= 0) return(-Inf);#
				r <- pars[1];#
				return(n.int * log(r) - r * sum.t);#
			}#
			return(f)#
		} #
		#
		sum.int.t.len <- sum(partition[i.int,"t.len"]);#
		int.t.0 <- partition[i.int,"t.0"];#
		pend.t.len <- partition[i.pend,"t.len"];#
		#
		if (model == "bd") {#
			f <- function(pars) {#
				r <- pars[1];#
				epsilon <- pars[2];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedD") {#
			fixD <- fixPar;#
			f <- function(pars) {#
				b <- pars[1];#
				r <- b - fixD;#
				epsilon <- fixD/b;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedEpsilon") {#
			epsilon <- fixPar;#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedR") {#
			r <- fixPar;#
			f <- function(pars) {#
				epsilon <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedB") {#
			fixB <- fixPar;#
			f <- function(pars) {#
				d <- pars[1];#
				r <- fixB - d;#
				epsilon <- d/fixB;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		}#
	} else {#
		sum.int.t.len <- sum(partition[i.int,"t.len"]);#
		pend.t.len <- partition[i.pend,"t.len"];#
		pend.n.t.minus.1 <- partition[i.pend,"n.t"] - 1;#
		#
		if (model == "yule") {#
			sum.pend.t.len <- sum(pend.t.len);#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0) return(-Inf);#
				return(n.int * log(r) - r * sum.int.t.len + sum(-pend.t.len * r + pend.n.t.minus.1*log(1 - exp(-pend.t.len * r))));#
			}#
			return(f)#
		}#
		#
		int.t.0 <- partition[i.int,"t.0"];#
		#
		if (model == "bd") {#
			f <- function(pars) {#
				r <- pars[1];#
				epsilon <- pars[2];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedD") {#
			fixD <- fixPar;#
			f <- function(pars) {#
				b <- pars[1];#
				r <- b - fixD;#
				epsilon <- fixD/b;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedEpsilon") {#
			epsilon <- fixPar;#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedR") {#
			r <- fixPar;#
			f <- function(pars) {#
				epsilon <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedB") {#
			fixB <- fixPar;#
			f <- function(pars) {#
				d <- pars[1];#
				r <- fixB - d;#
				epsilon <- d/fixB;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		}#
	}#
}#
#
#
#
## 'fit' contains '$par' and '$lnlik' and '$model'; check last value for presence of fixed parameters#
calculateModelFit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	model = fit$model[1];#
	#
	if (model == "fixedEpsilon" || model == "fixedR" || model == "fixedB" || model == "fixedD")#
	{#
		k <- 2 * num.models - 1;#
	} else {#
		k <- sum(!is.na(fit$par)) + num.models - 1; # number of estimated parameters + number of breaks#
	}#
	#
	lnLik <- fit$lnLik;#
	#
#	aic <- -2 * lnLik + 2*k;#
	aic <- getAIC(lnLik, k);#
#	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	aicc <- getAICc(lnLik, k, n);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
getAIC <- function (lnLik, k)#
{#
	return(-2 * lnLik + 2*k);#
}#
#
getAICc <- function (lnLik, k, n)#
{#
	return(getAIC(lnLik,k) + 2*k*(k+1)/(n-k-1));#
}#
#
## Used for comparing models fit to the same partition#
getBestPartialModel <- function (fit1, fit2, z, criterion)#
{#
	n <- (length(z[,1]) + 1); # the number of nodes involved#
## Add '1' to parameters to account for break#
	k1 <- 1 + sum(!is.na(fit1$par));#
	k2 <- 1 + sum(!is.na(fit2$par));#
	#
	if (n - k1 <= 1 || n - k2 <= 1) # deals with single edges, where AICc correction becomes undefined. use AIC.#
	{#
		if (getAIC(fit1$lnLik,k1) < getAIC(fit2$lnLik,k2))#
		{#
			return(fit1);#
		} else {#
			return(fit2);#
		}#
	} else {#
		if (criterion == "aicc")#
		{#
			if (getAICc(fit1$lnLik,k1,n) < getAICc(fit2$lnLik,k2,n))#
			{#
				return(fit1);#
			} else {#
				return(fit2);#
			}#
		} else {#
			if (getAIC(fit1$lnLik,k1) < getAIC(fit2$lnLik,k2))#
			{#
				return(fit1);#
			} else {#
				return(fit2);#
			}#
		}#
	}#
}
## Only used for base model#
medusaMLFitBase <- function (z, sp, model, fixPar, criterion)#
{#
	fit <- getOptimalModelFlavour(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	steps <- c("add", as.numeric(min(z[,"anc"])));#
	#
	return(list(par=matrix(fit$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=fit$lnLik, lnLik=fit$lnLik,#
		split.at=min(z[,"anc"]), aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3],#
		cut.at="node", model=fit$model, z=z, step=matrix(steps, nrow=1, dimnames=list(NULL,c("step", "node")))));#
}#
#
#
## Split the edge matrix 'z' by adding a partition at node 'node'.#
## The list 'desc' is a list of descendants (see makeCacheMedusa).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
medusaSplitStem <- function (node, z, desc, extract=FALSE)#
{#
	part <- z[,"partition"];#
	base <- min(part[z[,"anc"] == node | z[,"dec"] == node]);#
	tag <- max(part) + 1;#
	i <- desc[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	if (extract) {z <- z[idx,,drop=FALSE];}#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
medusaSplitNode <- function (node, z, desc, extract=FALSE)#
{#
	part <- z[,"partition"];#
	base <- min(part[z[,"anc"] == node]);#
	tag <- max(part) + 1;#
	i <- desc[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	if (extract) {z <- z[idx,,drop=FALSE];}#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
## The general function for when the flavour of shiftCut is unknown#
medusaSplit <- function (node, z, desc, shiftCut)#
{#
	descendants <- desc$stem; # will be correct half the time#
	if (shiftCut == "node") {descendants <- desc$node;}#
	#
	part <- z[,"partition"];#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted, especially for large trees.#
prefitTips <- function (pend.nodes, z, sp, model, fixPar, criterion, mc, numCores)#
{#
	if (all(z[z[,"dec"] %in% pend.nodes,"n.t"] == 1) && (model == "yule" || model == "mixed"))#
	{#
		fit <- list(list(par=c(0, NA), lnLik=0, model="yule"));#
		fit <- rep(fit, length(pend.nodes));#
		return(fit);#
	}#
	#
	if (model == "mixed") # yule will always have a better AIC for tip, regardless of richness#
	{#
		if (mc) {#
			tips <- mclapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model="yule", fixPar=fixPar, criterion=criterion, mc.cores=numCores);#
		} else {#
			tips <- lapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model="yule", fixPar=fixPar, criterion=criterion);#
		}#
	} else {#
		if (mc) {#
			tips <- mclapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model=model, fixPar=fixPar, criterion=criterion, mc.cores=numCores);#
		} else {#
			tips <- lapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	return(tips);#
}#
#
medusaMLPrefitTip <- function (node, z, sp, model, fixPar, criterion)#
{#
	z.tip <- z[z[,"dec"] == node,,drop=FALSE];#
	#
	if (all(z.tip[,"n.t"] == 1) && (model == "yule" || model == "mixed"))#
	{#
		return(list(par=c(0, NA), lnLik=0, model="yule"));#
	}#
	#
	fit <- getOptimalModelFlavour(z=z.tip, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
medusaMLPrefitNode <- function (node, z, desc, sp, model, fixPar, criterion)#
{#
	z.node <- medusaSplitNode(node=node, z=z, desc=desc, extract=TRUE)$z;#
	fit <- getOptimalModelFlavour(z=z.node, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
medusaMLPrefitStem <- function (node, z, desc, sp, model, fixPar, criterion)#
{#
	z.stem <- medusaSplitStem(node=node, z=z, desc=desc, extract=TRUE)$z;#
#	z.stem <- z.stem[z.stem[,"partition"] == 2,,drop=FALSE];#
	fit <- getOptimalModelFlavour(z=z.stem, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
#
## When model == mixed, fit both and find optimal flavour#
getOptimalModelFlavour <- function (z, sp, model, fixPar, criterion)#
{#
	fit.bd <- NULL;#
	fit.yule <- NULL;#
	fit <- NULL;#
	#
	if (model == "yule" | model == "mixed")#
	{#
		fit.yule <- medusaMLFitPartition(z=z, sp=sp, model="yule");#
		fit.yule$model <- "yule";#
	}#
	if (model == "bd" | model == "mixed")#
	{#
		if (is.na(sp[2])) {sp[2] <- 0.5;}#
		fit.bd <- medusaMLFitPartition(z=z, sp=sp, model="bd");#
		fit.bd$model <- "bd";#
	}#
	if (model != "mixed" && model != "bd" && model != "yule") # i.e. the constrained models#
	{#
		fit <- medusaMLFitPartition(z=z, sp=sp, model=model, fixPar=fixPar);#
		fit$model <- model;#
		return(fit);#
	}#
	#
## Figure out which model fits best#
	if (is.null(fit.bd))#
	{#
		fit <- fit.yule;#
	} else if (is.null(fit.yule)) {#
		fit <- fit.bd;#
	} else {#
## Considering both models#
		fit <- getBestPartialModel(fit1=fit.yule, fit2=fit.bd, z=z, criterion=criterion);#
		#
		#
		# fit.bd.val <- calculateModelFit(fit=fit.bd, z=z); ## NOT valid here, as sample size is NOT z#
		# fit.yule.val <- calculateModelFit(fit=fit.yule, z=z);#
		#
## The length condition below deals with single edges, where AICc correction becomes undefined (n-k-1)#
  # Undefined#
	}#
	return(fit);#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
medusaMLUpdate <- function (node, z, desc, fit, prefit, num.tips, root.node, model, fixPar, criterion, shiftCut, preserveModelFlavour)#
{#
## various combinations possible#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cool <- TRUE;#
	#
	# new.part.1 <- NULL;#
	# new.part.2 <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" | shiftCut == "both" | node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		obj.stem <- medusaSplitStem(node=node, z=z, desc=desc$stem);#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
		if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
		{#
			fit$lnLik <- -Inf;#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			return(fit);#
		}#
		#
## Everything is cool; proceed.#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
## first, consider diminshed clade. may result in a clade that has been cached previously#
		dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		#
## check if diminished clade conforms to a cached clade#
		x <- which(dimClade[,"anc"] == min(dimClade[,"anc"]));#
		if (length(x) == 1) # a cut-at-stem scenario#
		{#
			y <- as.numeric(dimClade[x, "dec"]);#
			if (length(unique(dimClade[(dimClade[,"dec"] < root.node),"dec"])) == prefit$num.tips[[y]])#
			{#
				if (y < root.node)#
				{#
					fit1.stem <- prefit$tips[[y]];#
				} else {#
					fit1.stem <- prefit$virgin.nodes$stem[[y - root.node]];#
				}#
#				cat("Worked! Clade is of size:", length(dimClade[,1]), "\n")#
			}#
		}#
				#
		if(is.null(fit1.stem))#
		{#
			if (model == "mixed")#
			{#
				if (preserveModelFlavour)  ## In mixed models, may want to conserve flavour of previously fit model#
				{#
					if (sum(!is.na(sp)) < 2) # yule#
					{#
						fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model="yule");#
					} else {#
						fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model="bd");#
					}#
				} else {#
## consider both model flavours#
					fit1.stem <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
				}#
			} else {#
				fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model=model, fixPar=fixPar);#
				fit1.stem$model <- model;#
			}#
		}#
		#
		#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == prefit$num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else {#
## novel shift#
			newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
			fit2.stem <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	#
	if ((shiftCut == "node" || shiftCut == "both") && (node > root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		obj.node <- medusaSplitNode(node=node, z=z, desc=desc$node);#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		#
## Need to check if cut is valid. May be inadmissable because of pattern of previous breaks (especially with shiftCut=both)#
		if (is.na(aff[1]) || is.na(aff[2]))#
		{#
			cool <- FALSE;#
		}		#
## Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (sum(z.node[,"partition"] == aff[1]) == 0 || sum(z.node[,"partition"] == aff[2]) == 0 || !cool)#
		{#
			fit$lnLik <- -Inf;#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			return(fit);#
		}#
		#
## Everything is cool; proceed.#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
## first, consider diminshed clade. may result in a clade that has been cached#
		dimClade <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		#
		if (model == "mixed")#
		{#
			if (preserveModelFlavour)  ## In mixed models, may want to conserve flavour of previously fit model#
			{#
				if (sum(!is.na(sp)) < 2) # yule#
				{#
					fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model="yule"); # should this change? probably.#
				} else {#
					fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model="bd");#
				}#
			} else {#
## consider both model flavours#
				fit1.node <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
			}#
		} else {#
			fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model=model, fixPar=fixPar);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == prefit$num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		} else {#
## novel shift#
			newClade <- z.node[z.node[,"partition"] == aff[2],,drop=FALSE];#
			fit2.node <- getOptimalModelFlavour (z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par, model=model);#
		stem.fit <- calculateModelFit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par, model=model);#
		node.fit <- calculateModelFit(fit=node.val, z=z);#
		#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
## sp = initializing values for r & epsilon. fixPar = fixed value for constrained model.#
## Default values should never be used (except for first model), as the values from the previous model are passed in.#
## The 'suppressWarnings' catches harmless warnings for when extreme parameter values are tried, #
## generating -Inf log-likelihoods. Depends on sclae of the tree.#
medusaMLFitPartition <- function (z, sp=c(0.05, 0.5), model, fixPar=NULL)#
{#
#	new.part <- z[z[,"partition"] == partition.id,,drop=FALSE]; # now subsetted earlier#
	new.part <- z;#
	#
# Construct likelihood function:#
	lik <- makePartitionLikelihood(partition=new.part, model=model, fixPar=fixPar);#
	foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
	#
	if (model == "bd")#
	{#
		fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=5000));#
		#
		if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
		#
		return(list(par=exp(fit$par), lnLik=-fit$value));#
	}#
		#
## grab values to get an intelligent upper bound on b or r#
		node.richness  <- sum(new.part[,"n.t"], na.rm=TRUE);#
		depth <- max(new.part[,"t.0"]);#
		#
# use different intervals based on model flavour#
	#
	if (model == "yule") {#
		#
		maxVal <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {maxVal <- 1e-5;}#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-25, log(maxVal))));#
		par <- c(exp(fit$minimum), NA);#
		#
		while (par[1]/maxVal > 0.95) # crash against boundary; doesn't seem to get used...#
		{#
			maxVal <- par[1] * 3;#
			cat("Hit boundary\n")#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(par[1]/2), log(maxVal))));#
			par <- c(exp(fit$minimum), NA);#
		}#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedD") {#
## this is the messiest model flavour; reasonable range depends on magnitude of fixD#
		#
		x <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {x <- 0.01;} # MLE for single tip will be r ~ 0#
		maxVal <- fixPar + x;#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(log(fixPar), log(maxVal))));#
		b <- exp(fit$minimum);#
		par <- c((b - fixPar), (fixPar / b));#
		#
		while (fit$objective == Inf)#
		{#
			cat("maxVal =", maxVal, "; b =", b, "; r =", b - fixPar, "; epsilon =", fixPar/b, "\n")#
			#
			x <- x * 0.75;#
			maxVal <- fixPar + x;#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(fixPar), log(maxVal))));#
			b <- exp(fit$minimum);#
			par <- c((b - fixPar), (fixPar / b));#
		}#
		#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedEpsilon") {#
		#
		maxVal <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {maxVal <- 1;}#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-25, log(maxVal))));#
		par <- c(exp(fit$minimum), sp[2]);#
		#
		while (par[1]/maxVal > 0.9) # crash against boundary#
		{#
			maxVal <- par[1] * 3;#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(par[1]/2), log(maxVal))));#
			par <- c(exp(fit$minimum), sp[2]);#
		}#
		#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedB") {#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-50, log(fixPar))));#
		d <- exp(fit$minimum);#
		par <- c((fixPar - d), (d / fixPar));#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedR") {#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-50, 0)));#
		par <- c(sp[1], exp(fit$minimum));#
		return(list(par=par, lnLik=-fit$objective));#
	}#
}#
#
#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
#
## makePartitionLikelihood: generate a likelihood function for a single partition.#
makePartitionLikelihood <- function (partition, model, fixPar)#
{#
	i.int <- is.na(partition[,"n.t"])#
	i.pend <- !(i.int)#
	n.int <- sum(i.int);#
	#
	simple <- FALSE;#
	if (all(partition[,"n.t"] == 1, na.rm = TRUE)) {simple <- TRUE;}#
	#
	if (simple) {#
		if (model == "yule") {#
			sum.t <- sum(partition[,"t.len"]);#
			f <- function(pars) {#
				if (pars <= 0) return(-Inf);#
				r <- pars[1];#
				return(n.int * log(r) - r * sum.t);#
			}#
			return(f)#
		} #
		#
		sum.int.t.len <- sum(partition[i.int,"t.len"]);#
		int.t.0 <- partition[i.int,"t.0"];#
		pend.t.len <- partition[i.pend,"t.len"];#
		#
		if (model == "bd") {#
			f <- function(pars) {#
				r <- pars[1];#
				epsilon <- pars[2];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedD") {#
			fixD <- fixPar;#
			f <- function(pars) {#
				b <- pars[1];#
				r <- b - fixD;#
				epsilon <- fixD/b;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedEpsilon") {#
			epsilon <- fixPar;#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedR") {#
			r <- fixPar;#
			f <- function(pars) {#
				epsilon <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedB") {#
			fixB <- fixPar;#
			f <- function(pars) {#
				d <- pars[1];#
				r <- fixB - d;#
				epsilon <- d/fixB;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		}#
	} else {#
		sum.int.t.len <- sum(partition[i.int,"t.len"]);#
		pend.t.len <- partition[i.pend,"t.len"];#
		pend.n.t.minus.1 <- partition[i.pend,"n.t"] - 1;#
		#
		if (model == "yule") {#
			sum.pend.t.len <- sum(pend.t.len);#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0) return(-Inf);#
				return(n.int * log(r) - r * sum.int.t.len + sum(-pend.t.len * r + pend.n.t.minus.1*log(1 - exp(-pend.t.len * r))));#
			}#
			return(f)#
		}#
		#
		int.t.0 <- partition[i.int,"t.0"];#
		#
		if (model == "bd") {#
			f <- function(pars) {#
				r <- pars[1];#
				epsilon <- pars[2];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedD") {#
			fixD <- fixPar;#
			f <- function(pars) {#
				b <- pars[1];#
				r <- b - fixD;#
				epsilon <- fixD/b;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedEpsilon") {#
			epsilon <- fixPar;#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedR") {#
			r <- fixPar;#
			f <- function(pars) {#
				epsilon <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedB") {#
			fixB <- fixPar;#
			f <- function(pars) {#
				d <- pars[1];#
				r <- fixB - d;#
				epsilon <- d/fixB;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		}#
	}#
}#
#
#
#
## 'fit' contains '$par' and '$lnlik' and '$model'; check last value for presence of fixed parameters#
calculateModelFit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	model = fit$model[1];#
	#
	if (model == "fixedEpsilon" || model == "fixedR" || model == "fixedB" || model == "fixedD")#
	{#
		k <- 2 * num.models - 1;#
	} else {#
		k <- sum(!is.na(fit$par)) + num.models - 1; # number of estimated parameters + number of breaks#
	}#
	#
	lnLik <- fit$lnLik;#
	#
#	aic <- -2 * lnLik + 2*k;#
	aic <- getAIC(lnLik, k);#
#	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	aicc <- getAICc(lnLik, k, n);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
getAIC <- function (lnLik, k)#
{#
	return(-2 * lnLik + 2*k);#
}#
#
getAICc <- function (lnLik, k, n)#
{#
	return(getAIC(lnLik,k) + 2*k*(k+1)/(n-k-1));#
}#
#
## Used for comparing models fit to the same partition#
getBestPartialModel <- function (fit1, fit2, z, criterion)#
{#
	n <- (length(z[,1]) + 1); # the number of nodes involved#
## Add '1' to parameters to account for break#
	k1 <- 1 + sum(!is.na(fit1$par));#
	k2 <- 1 + sum(!is.na(fit2$par));#
	#
	if (n - k1 <= 1 || n - k2 <= 1) # deals with single edges, where AICc correction becomes undefined. use AIC.#
	{#
		if (getAIC(fit1$lnLik,k1) < getAIC(fit2$lnLik,k2))#
		{#
			return(fit1);#
		} else {#
			return(fit2);#
		}#
	} else {#
		if (criterion == "aicc")#
		{#
			if (getAICc(fit1$lnLik,k1,n) < getAICc(fit2$lnLik,k2,n))#
			{#
				return(fit1);#
			} else {#
				return(fit2);#
			}#
		} else {#
			if (getAIC(fit1$lnLik,k1) < getAIC(fit2$lnLik,k2))#
			{#
				return(fit1);#
			} else {#
				return(fit2);#
			}#
		}#
	}#
}
}
## Only used for base model#
medusaMLFitBase <- function (z, sp, model, fixPar, criterion)#
{#
	fit <- getOptimalModelFlavour(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	steps <- c("add", as.numeric(min(z[,"anc"])));#
	#
	return(list(par=matrix(fit$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=fit$lnLik, lnLik=fit$lnLik,#
		split.at=min(z[,"anc"]), aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3],#
		cut.at="node", model=fit$model, z=z, step=matrix(steps, nrow=1, dimnames=list(NULL,c("step", "node")))));#
}#
#
#
## Split the edge matrix 'z' by adding a partition at node 'node'.#
## The list 'desc' is a list of descendants (see makeCacheMedusa).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
medusaSplitStem <- function (node, z, desc, extract=FALSE)#
{#
	part <- z[,"partition"];#
	base <- min(part[z[,"anc"] == node | z[,"dec"] == node]);#
	tag <- max(part) + 1;#
	i <- desc[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	if (extract) {z <- z[idx,,drop=FALSE];}#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
medusaSplitNode <- function (node, z, desc, extract=FALSE)#
{#
	part <- z[,"partition"];#
	base <- min(part[z[,"anc"] == node]);#
	tag <- max(part) + 1;#
	i <- desc[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	if (extract) {z <- z[idx,,drop=FALSE];}#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
## The general function for when the flavour of shiftCut is unknown#
medusaSplit <- function (node, z, desc, shiftCut)#
{#
	descendants <- desc$stem; # will be correct half the time#
	if (shiftCut == "node") {descendants <- desc$node;}#
	#
	part <- z[,"partition"];#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted, especially for large trees.#
prefitTips <- function (pend.nodes, z, sp, model, fixPar, criterion, mc, numCores)#
{#
	if (all(z[z[,"dec"] %in% pend.nodes,"n.t"] == 1) && (model == "yule" || model == "mixed"))#
	{#
		fit <- list(list(par=c(0, NA), lnLik=0, model="yule"));#
		fit <- rep(fit, length(pend.nodes));#
		return(fit);#
	}#
	#
	if (model == "mixed") # yule will always have a better AIC for tip, regardless of richness#
	{#
		if (mc) {#
			tips <- mclapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model="yule", fixPar=fixPar, criterion=criterion, mc.cores=numCores);#
		} else {#
			tips <- lapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model="yule", fixPar=fixPar, criterion=criterion);#
		}#
	} else {#
		if (mc) {#
			tips <- mclapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model=model, fixPar=fixPar, criterion=criterion, mc.cores=numCores);#
		} else {#
			tips <- lapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	return(tips);#
}#
#
medusaMLPrefitTip <- function (node, z, sp, model, fixPar, criterion)#
{#
	z.tip <- z[z[,"dec"] == node,,drop=FALSE];#
	#
	if (all(z.tip[,"n.t"] == 1) && (model == "yule" || model == "mixed"))#
	{#
		return(list(par=c(0, NA), lnLik=0, model="yule"));#
	}#
	#
	fit <- getOptimalModelFlavour(z=z.tip, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
medusaMLPrefitNode <- function (node, z, desc, sp, model, fixPar, criterion)#
{#
	z.node <- medusaSplitNode(node=node, z=z, desc=desc, extract=TRUE)$z;#
	fit <- getOptimalModelFlavour(z=z.node, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
medusaMLPrefitStem <- function (node, z, desc, sp, model, fixPar, criterion)#
{#
	z.stem <- medusaSplitStem(node=node, z=z, desc=desc, extract=TRUE)$z;#
#	z.stem <- z.stem[z.stem[,"partition"] == 2,,drop=FALSE];#
	fit <- getOptimalModelFlavour(z=z.stem, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
#
## When model == mixed, fit both and find optimal flavour#
getOptimalModelFlavour <- function (z, sp, model, fixPar, criterion)#
{#
	fit.bd <- NULL;#
	fit.yule <- NULL;#
	fit <- NULL;#
	#
	if (model == "yule" | model == "mixed")#
	{#
		fit.yule <- medusaMLFitPartition(z=z, sp=sp, model="yule");#
		fit.yule$model <- "yule";#
	}#
	if (model == "bd" | model == "mixed")#
	{#
		if (is.na(sp[2])) {sp[2] <- 0.5;}#
		fit.bd <- medusaMLFitPartition(z=z, sp=sp, model="bd");#
		fit.bd$model <- "bd";#
	}#
	if (model != "mixed" && model != "bd" && model != "yule") # i.e. the constrained models#
	{#
		fit <- medusaMLFitPartition(z=z, sp=sp, model=model, fixPar=fixPar);#
		fit$model <- model;#
		return(fit);#
	}#
	#
## Figure out which model fits best#
	if (is.null(fit.bd))#
	{#
		fit <- fit.yule;#
	} else if (is.null(fit.yule)) {#
		fit <- fit.bd;#
	} else {#
## Considering both models#
		fit <- getBestPartialModel(fit1=fit.yule, fit2=fit.bd, z=z, criterion=criterion);#
		#
		#
		# fit.bd.val <- calculateModelFit(fit=fit.bd, z=z); ## NOT valid here, as sample size is NOT z#
		# fit.yule.val <- calculateModelFit(fit=fit.yule, z=z);#
		#
## The length condition below deals with single edges, where AICc correction becomes undefined (n-k-1)#
  # Undefined#
	}#
	return(fit);#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
medusaMLUpdate <- function (node, z, desc, fit, prefit, num.tips, root.node, model, fixPar, criterion, shiftCut, preserveModelFlavour)#
{#
## various combinations possible#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cool <- TRUE;#
	#
	# new.part.1 <- NULL;#
	# new.part.2 <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" | shiftCut == "both" | node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		obj.stem <- medusaSplitStem(node=node, z=z, desc=desc$stem);#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
		if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
		{#
			fit$lnLik <- -Inf;#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			return(fit);#
		}#
		#
## Everything is cool; proceed.#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
## first, consider diminshed clade. may result in a clade that has been cached previously#
		dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		#
## check if diminished clade conforms to a cached clade#
		x <- which(dimClade[,"anc"] == min(dimClade[,"anc"]));#
		if (length(x) == 1) # a cut-at-stem scenario#
		{#
			y <- as.numeric(dimClade[x, "dec"]);#
			if (length(unique(dimClade[(dimClade[,"dec"] < root.node),"dec"])) == prefit$num.tips[[y]])#
			{#
				if (y < root.node)#
				{#
					fit1.stem <- prefit$tips[[y]];#
				} else {#
					fit1.stem <- prefit$virgin.nodes$stem[[y - root.node]];#
				}#
#				cat("Worked! Clade is of size:", length(dimClade[,1]), "\n")#
			}#
		}#
				#
		if(is.null(fit1.stem))#
		{#
			if (model == "mixed")#
			{#
				if (preserveModelFlavour)  ## In mixed models, may want to conserve flavour of previously fit model#
				{#
					if (sum(!is.na(sp)) < 2) # yule#
					{#
						fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model="yule");#
					} else {#
						fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model="bd");#
					}#
				} else {#
## consider both model flavours#
					fit1.stem <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
				}#
			} else {#
				fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model=model, fixPar=fixPar);#
				fit1.stem$model <- model;#
			}#
		}#
		#
		#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == prefit$num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else {#
## novel shift#
			newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
			fit2.stem <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	#
	if ((shiftCut == "node" || shiftCut == "both") && (node > root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		obj.node <- medusaSplitNode(node=node, z=z, desc=desc$node);#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		#
## Need to check if cut is valid. May be inadmissable because of pattern of previous breaks (especially with shiftCut=both)#
		if (is.na(aff[1]) || is.na(aff[2]))#
		{#
			cool <- FALSE;#
		}		#
## Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (sum(z.node[,"partition"] == aff[1]) == 0 || sum(z.node[,"partition"] == aff[2]) == 0 || !cool)#
		{#
			fit$lnLik <- -Inf;#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			return(fit);#
		}#
		#
## Everything is cool; proceed.#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
## first, consider diminshed clade. may result in a clade that has been cached#
		dimClade <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		#
		if (model == "mixed")#
		{#
			if (preserveModelFlavour)  ## In mixed models, may want to conserve flavour of previously fit model#
			{#
				if (sum(!is.na(sp)) < 2) # yule#
				{#
					fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model="yule"); # should this change? probably.#
				} else {#
					fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model="bd");#
				}#
			} else {#
## consider both model flavours#
				fit1.node <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
			}#
		} else {#
			fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model=model, fixPar=fixPar);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == prefit$num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		} else {#
## novel shift#
			newClade <- z.node[z.node[,"partition"] == aff[2],,drop=FALSE];#
			fit2.node <- getOptimalModelFlavour (z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par, model=model);#
		stem.fit <- calculateModelFit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par, model=model);#
		node.fit <- calculateModelFit(fit=node.val, z=z);#
		#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
## sp = initializing values for r & epsilon. fixPar = fixed value for constrained model.#
## Default values should never be used (except for first model), as the values from the previous model are passed in.#
## The 'suppressWarnings' catches harmless warnings for when extreme parameter values are tried, #
## generating -Inf log-likelihoods. Depends on sclae of the tree.#
medusaMLFitPartition <- function (z, sp=c(0.05, 0.5), model, fixPar=NULL)#
{#
#	new.part <- z[z[,"partition"] == partition.id,,drop=FALSE]; # now subsetted earlier#
	new.part <- z;#
	#
# Construct likelihood function:#
	lik <- makePartitionLikelihood(partition=new.part, model=model, fixPar=fixPar);#
	foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
	#
	if (model == "bd")#
	{#
		fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=5000));#
		#
		if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
		#
		return(list(par=exp(fit$par), lnLik=-fit$value));#
	}#
		#
## grab values to get an intelligent upper bound on b or r#
		node.richness  <- sum(new.part[,"n.t"], na.rm=TRUE);#
		depth <- max(new.part[,"t.0"]);#
		#
# use different intervals based on model flavour#
	#
	if (model == "yule") {#
		#
		maxVal <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {maxVal <- 1e-5;}#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-25, log(maxVal))));#
		par <- c(exp(fit$minimum), NA);#
		#
		while (par[1]/maxVal > 0.95) # crash against boundary; doesn't seem to get used...#
		{#
			maxVal <- par[1] * 3;#
			cat("Hit boundary\n")#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(par[1]/2), log(maxVal))));#
			par <- c(exp(fit$minimum), NA);#
		}#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedD") {#
## this is the messiest model flavour; reasonable range depends on magnitude of fixD#
		#
		x <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {x <- 0.01;} # MLE for single tip will be r ~ 0#
		maxVal <- fixPar + x;#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(log(fixPar), log(maxVal))));#
		b <- exp(fit$minimum);#
		par <- c((b - fixPar), (fixPar / b));#
		#
		while (fit$objective == Inf)#
		{#
			cat("maxVal =", maxVal, "; b =", b, "; r =", b - fixPar, "; epsilon =", fixPar/b, "\n")#
			#
			x <- x * 0.75;#
			maxVal <- fixPar + x;#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(fixPar), log(maxVal))));#
			b <- exp(fit$minimum);#
			par <- c((b - fixPar), (fixPar / b));#
		}#
		#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedEpsilon") {#
		#
		maxVal <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {maxVal <- 1;}#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-25, log(maxVal))));#
		par <- c(exp(fit$minimum), sp[2]);#
		#
		while (par[1]/maxVal > 0.9) # crash against boundary#
		{#
			maxVal <- par[1] * 3;#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(par[1]/2), log(maxVal))));#
			par <- c(exp(fit$minimum), sp[2]);#
		}#
		#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedB") {#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-50, log(fixPar))));#
		d <- exp(fit$minimum);#
		par <- c((fixPar - d), (d / fixPar));#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedR") {#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-50, 0)));#
		par <- c(sp[1], exp(fit$minimum));#
		return(list(par=par, lnLik=-fit$objective));#
	}#
}#
#
#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
#
## makePartitionLikelihood: generate a likelihood function for a single partition.#
makePartitionLikelihood <- function (partition, model, fixPar)#
{#
	i.int <- is.na(partition[,"n.t"])#
	i.pend <- !(i.int)#
	n.int <- sum(i.int);#
	#
	simple <- FALSE;#
	if (all(partition[,"n.t"] == 1, na.rm = TRUE)) {simple <- TRUE;}#
	#
	if (simple) {#
		if (model == "yule") {#
			sum.t <- sum(partition[,"t.len"]);#
			f <- function(pars) {#
				if (pars <= 0) return(-Inf);#
				r <- pars[1];#
				return(n.int * log(r) - r * sum.t);#
			}#
			return(f)#
		} #
		#
		sum.int.t.len <- sum(partition[i.int,"t.len"]);#
		int.t.0 <- partition[i.int,"t.0"];#
		pend.t.len <- partition[i.pend,"t.len"];#
		#
		if (model == "bd") {#
			f <- function(pars) {#
				r <- pars[1];#
				epsilon <- pars[2];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedD") {#
			fixD <- fixPar;#
			f <- function(pars) {#
				b <- pars[1];#
				r <- b - fixD;#
				epsilon <- fixD/b;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedEpsilon") {#
			epsilon <- fixPar;#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedR") {#
			r <- fixPar;#
			f <- function(pars) {#
				epsilon <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedB") {#
			fixB <- fixPar;#
			f <- function(pars) {#
				d <- pars[1];#
				r <- fixB - d;#
				epsilon <- d/fixB;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		}#
	} else {#
		sum.int.t.len <- sum(partition[i.int,"t.len"]);#
		pend.t.len <- partition[i.pend,"t.len"];#
		pend.n.t.minus.1 <- partition[i.pend,"n.t"] - 1;#
		#
		if (model == "yule") {#
			sum.pend.t.len <- sum(pend.t.len);#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0) return(-Inf);#
				return(n.int * log(r) - r * sum.int.t.len + sum(-pend.t.len * r + pend.n.t.minus.1*log(1 - exp(-pend.t.len * r))));#
			}#
			return(f)#
		}#
		#
		int.t.0 <- partition[i.int,"t.0"];#
		#
		if (model == "bd") {#
			f <- function(pars) {#
				r <- pars[1];#
				epsilon <- pars[2];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedD") {#
			fixD <- fixPar;#
			f <- function(pars) {#
				b <- pars[1];#
				r <- b - fixD;#
				epsilon <- fixD/b;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedEpsilon") {#
			epsilon <- fixPar;#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedR") {#
			r <- fixPar;#
			f <- function(pars) {#
				epsilon <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedB") {#
			fixB <- fixPar;#
			f <- function(pars) {#
				d <- pars[1];#
				r <- fixB - d;#
				epsilon <- d/fixB;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		}#
	}#
}#
#
#
#
## 'fit' contains '$par' and '$lnlik' and '$model'; check last value for presence of fixed parameters#
calculateModelFit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	model = fit$model[1];#
	#
	if (model == "fixedEpsilon" || model == "fixedR" || model == "fixedB" || model == "fixedD")#
	{#
		k <- 2 * num.models - 1;#
	} else {#
		k <- sum(!is.na(fit$par)) + num.models - 1; # number of estimated parameters + number of breaks#
	}#
	#
	lnLik <- fit$lnLik;#
	#
#	aic <- -2 * lnLik + 2*k;#
	aic <- getAIC(lnLik, k);#
#	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	aicc <- getAICc(lnLik, k, n);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
getAIC <- function (lnLik, k)#
{#
	return(-2 * lnLik + 2*k);#
}#
#
getAICc <- function (lnLik, k, n)#
{#
	return(getAIC(lnLik,k) + 2*k*(k+1)/(n-k-1));#
}#
#
## Used for comparing models fit to the same partition#
getBestPartialModel <- function (fit1, fit2, z, criterion)#
{#
	n <- (length(z[,1]) + 1); # the number of nodes involved#
## Add '1' to parameters to account for break#
	k1 <- 1 + sum(!is.na(fit1$par));#
	k2 <- 1 + sum(!is.na(fit2$par));#
	#
	if (n - k1 <= 1 || n - k2 <= 1) # deals with single edges, where AICc correction becomes undefined. use AIC.#
	{#
		if (getAIC(fit1$lnLik,k1) < getAIC(fit2$lnLik,k2))#
		{#
			return(fit1);#
		} else {#
			return(fit2);#
		}#
	} else {#
		if (criterion == "aicc")#
		{#
			if (getAICc(fit1$lnLik,k1,n) < getAICc(fit2$lnLik,k2,n))#
			{#
				return(fit1);#
			} else {#
				return(fit2);#
			}#
		} else {#
			if (getAIC(fit1$lnLik,k1) < getAIC(fit2$lnLik,k2))#
			{#
				return(fit1);#
			} else {#
				return(fit2);#
			}#
		}#
	}#
}
fitSisters(x, node=327) -> foo
fitSisters(x, node=422) -> foo
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
require(geiger)
load("/Users/josephwb/Projects/R_working/turboMEDUSA/DATA/tmp.rda")
phy <- tmp$phy
fitSisters(phy, node=422)
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(phy, node=422)
## Function to prune tree using 'richness' information, assumed to have minimally two columns, "taxon" and "n.taxa"#
##   Perhaps relax on these column names, may cause too many problems#
## May also include 'exemplar' column; in that case, rename relevant tip.label before pruning.#
prepareData <- function (phy, richness, verbose)#
{#
	if (is.null(richness)) { # Assume tree represents single species tips and is completely sampled#
		richness <- data.frame(taxon=phy$tip.label, n.taxa=1);#
	}#
# Rename exemplar taxa with taxon name in richness file#
	if (!is.null(richness$exemplar))#
	{#
# Change relevant tip.labels in phy; individual 'exemplar' may be NA, use original tip.label.#
# Ordering in richness file should NOT be assumed to match order of tip.labels#
		i.na <- is.na(richness$exemplar);#
		phy$tip.label[match(richness$exemplar[!i.na], phy$tip.label)] <- as.character(richness$taxon[!i.na]);#
	}#
	#
# make sure things are in the correct order and of correct format#
	if (length(richness[1,]) == 2)#
	{#
		if (colnames(richness)[1] != "taxon" || colnames(richness)[2] != "n.taxa")#
		{#
			if (class(richness[,1]) == "factor" & class(richness[,2]) == "integer")#
			{#
				colnames(richness) = c("taxon", "n.taxa");#
			} else if (class(richness[,1]) == "integer" & class(richness[,2]) == "factor")#
			{#
				colnames(richness) = c("n.taxa", "taxon");#
			} else {#
				cat("MEDUSA thinks your richness data is in an incorrect format. See ?MEDUSA.\n")#
				stop;#
			}#
		}#
	}#
	#
	if (class(phy) != "phylo") {cat("\n\nWARNING: tree is not of class \"phylo\". Stopping.\n"); stop;}#
	#
# Prune tree down to lineages with assigned richnesses#
	temp <- richness[, "n.taxa"];#
	names(temp) <- richness[, "taxon"];#
	pruned <- treedata(phy, temp, warnings=verbose)  # geiger function calling ape (namecheck)#
	#
# checking for typos#
	if (length(pruned$phy$tip.label) == 0) {#
		cat("\n\nWARNING: MEDUSA encountered a serious error. Tree has no tips after processing richness information! \nIt is likely that an incorrect richness file is being used. \nAnalysis cannot proceed. Please examine the information below to identify the error.\\nn");#
		cat("\nTree tip labels:\n");#
		print(phy$tip.label);#
		cat("\nRichness taxon labels:\n");#
		print(as.character(richness[, "taxon"]));#
		stop;#
	} else if (length(phy$tip.label) != length(pruned$phy$tip.label)) {#
		cat("MEDUSA thinks there is a typo in either the tree or richness files, as one or more tips were dropped from the tree.\n");#
		stop;#
	}#
#
	phy <- pruned$phy;#
# Check the tree#
	#	plotNN(phy)					# Node numbers (ape-style) plotted#
	#
	return(list(phy=phy, richness=richness));#
}#
#
# Determine desired model from passed in fixed parameters (if present)#
configureModel <- function (model, epsilon, r, b, d, constraint, initialR, initialE)#
{#
	sp <- NULL;#
	fixPar <- NULL;#
	if (!is.null(epsilon)) # user-defined epsilon#
	{#
		if (epsilon <= 0 | epsilon >= 1) {cat("\n\nWARNING: value of epsilon (", epsilon, ") is invalid; must be > 0 and < 1. Stopping analysis.\n", sep=""); stop;}#
		sp <- c(initialR, epsilon);#
		fixPar <- epsilon;#
		model <- "fixedEpsilon";#
	} else if (!is.null(r)) # user-defined net diversification rate#
	{#
		if (r <= 0) {cat("\n\nWARNING: value of r (", r, ") is invalid; must be > 0. Stopping analysis.\n", sep=""); stop;}#
		sp <- c(r, initialE);#
		fixPar <- r;#
		model <- "fixedR";#
	} else if (!is.null(d)) # user-defined extiction rate#
	{#
		if (d <= 0) {cat("\n\nWARNING: value of d (", d, ") is invalid; must be > 0. Stopping analysis.\n", sep=""); stop;}#
		sp <- c(initialR, d);#
		fixPar <- d;#
		model <- "fixedD";#
	} else if (!is.null(b)) # user-defined speciation rate#
	{#
		if (b <= 0) {cat("\n\nWARNING: value of b (", b, ") is invalid; must be > 0. Stopping analysis.\n", sep=""); stop;}#
		sp <- c((b/2), initialE);#
		fixPar <- b;#
		model <- "fixedB";#
	} else {#
		sp <- c(initialR, initialE);#
	}#
	return(list(model=model, sp=sp, fixPar=fixPar))#
}#
#
#
## Original default was to fit 20 models (or less if the tree was small).#
## Changing to a stop-criterion (stop="modelLimit") e.g. when k = n-1 (i.e. when denominator of aicc correction is undefined).#
## k <- (3*i-1) # when both birth and death are estimated, where i is the number of piecewise models#
  ## This occurs when i = n/3#
  ## If Yule, max i = n/2#
## n <- (2*num.taxa - 1) == (2*length(richness[,1]) - 1) # i.e. total number of nodes in tree (internal + pendant)#
## Alternatively use aicc threshold itself as a stopping criterion (stop="threshold").#
# AICc = AIC + 2*k*(k+1)/(n-k-1);#
getMaxModelLimit <- function (richness, modelLimit, model, stop)#
{#
	samp.size <- (2*length(richness[,1]) - 1)#
	if (model == "bd" || model == "mixed")#
	{#
		max.modelLimit <- as.integer(samp.size/3) - ((!(samp.size %% 3)) * 1);#
	} else {#
		max.modelLimit <- as.integer(samp.size/2) - ((!(samp.size %% 2)) * 1); # models estimating only one diversification parameter#
	}#
	#
	if (stop == "modelLimit")#
	{#
		if (modelLimit > max.modelLimit) {modelLimit <- max.modelLimit;}#
		cat("Limiting consideration to ", modelLimit, " piecewise", sep="");#
		if (model == "bd") {#
			cat(" birth-death models")#
		} else if (model == "mixed") {#
			cat(" mixed models")#
		} else if (model == "yule") {#
			cat(" pure-birth (Yule) models");#
		} else {#
			cat(" diversification models")#
		}#
		cat(".\n\n");#
	}#
	#
	return(modelLimit);#
}#
#
#
## Fitted curve from random b-d simulations#
## Value corresponds to 95th percentile of AICc(split) - AICc(no-split) for no-split simulations#
## x-shifted power function#
getThreshold <- function (treeSize, fixThreshold, stop)#
{#
	a = -3.5941052380332650E+01;#
	b =  6.7372587299747000E+00;#
	c = -1.0061508340754866E-01;#
	Offset =  2.7516678664333408E+01;#
	threshold <- a * (treeSize-b)^c + Offset;#
	if (threshold < 0 || is.nan(threshold)) threshold <- 0;#
	#
	if (!is.null(fixThreshold))#
	{#
		if (is.nan(fixThreshold) || class(fixThreshold) != "numeric" || fixThreshold < 0)#
		{#
			cat("Provided threshold value of '", fixThreshold, "' is invalid.\n", sep="")#
			cat("Will proceed with value determined from simulations.\n")#
			cat("Appropriate AICc threshold for tree of ", treeSize, " tips is: ", threshold, ".\n", sep="");#
			return(threshold);#
		} else {#
			cat("Using provided threshold value of ", fixThreshold, ".\n", sep="")#
			cat("From simulations, appropriate AICc threshold for tree of ", treeSize, " tips would be: ", threshold, ".\n", sep="");#
			return(fixThreshold);#
		}#
	} else {#
		if (stop == "threshold") {#
			cat("Using AIC-threshold as analysis-terminating criterion.\n");#
			cat("Appropriate threshold for tree of ", treeSize, " tips is: ", threshold, ".\n\n", sep="");#
		}#
		return(threshold);#
	}#
}#
#
#
## The makeCacheMedusa function is like the first half of the original splitEdgeMatrix().#
## It works through and reorders the edges, then works out start and end times of these#
## based on the phylogeny's branching times.#
###
## In addition, every node's descendants are also calculated.  The element 'desc' is a list.#
## $desc[i] contains the indices within $edge, $t.start, etc., of all descendants of node 'i'#
## (in ape node numbering format).#
makeCacheMedusa <- function (phy, richness, all.nodes, shiftCut, mc, numCores)#
{#
	n.tips <- length(phy$tip.label);#
	n.int <- nrow(phy$edge) - n.tips;#
	#
## Ape numbers the tips first#
	i.int <- seq_len(n.int);#
	interior <- phy$edge[,2] %in% phy$edge[,1];#
	bt <- branching.times(phy);#
	#
# Consider only internal edges first#
	edges.int <- phy$edge[interior,];#
	colnames(edges.int) <- c("anc", "dec");#
	#
	t.0 <- bt[match(edges.int[,1], (n.tips+1):max(edges.int))];#
	t.1 <- c(t.0[i.int] - phy$edge.length[interior]);#
	#
	z.internal <- cbind(edges.int, t.0, t.1, t.len=t.0 - t.1,#
		n.0=rep(1, n.int), n.t=rep(NA, n.int));#
	#
# Now, pendant edges; #
	edges.pendant <- phy$edge[match(seq_len(n.tips), phy$edge[,2]),];#
	colnames(edges.pendant) <- c("anc", "dec");#
	#
	t.0 <- bt[match(edges.pendant[,1], (n.tips+1):max(edges.pendant))];#
	t.1 <- rep(0, n.tips);#
# cannot assume richness ordering necessarily matches that of tip labels#
	ext.richness <- richness$n.taxa[match(phy$tip.label, richness$taxon)];#
	#
	z.pendant <- cbind(edges.pendant, t.0, t.1, t.len=t.0 - t.1,#
		n.0=rep(1, n.tips), n.t=ext.richness);#
	#
	z <- rbind(z.internal, z.pendant);#
	z <- cbind(z,partition=rep(1, length(z[,1]))); # Stores piecewise model structure#
	rownames(z) <- NULL;#
	#
# Used for identifying descendant nodes below i.e. tracking breakpoints#
	all.edges <- as.matrix(z[,c("anc","dec")]);#
	desc.stem <- list();#
	desc.node <- list();#
	#
	cat("  Gathering descendant node information...");#
	if (mc)#
	{#
		if (shiftCut == "both" || shiftCut == "stem")#
		{#
			desc.stem <- mclapply(seq_len(max(all.edges)), descendantsCutAtStem.idx, all.edges=all.edges, mc.cores=numCores);#
		}#
		if (shiftCut == "both" || shiftCut == "node")#
		{#
			if (!is.null(desc.stem))#
			{#
				root <- min(z[,"anc"]);#
				desc.node <- mclapply(desc.stem, stripStem, mc.cores=numCores);#
				desc.node[root] <- desc.stem[root];#
			} else {#
				desc.node <- mclapply(seq_len(max(all.edges)), descendantsCutAtNode.idx, all.edges=all.edges, mc.cores=numCores);#
			}#
		}#
	} else {#
		if (shiftCut == "both" || shiftCut == "stem")#
		{#
			desc.stem <- lapply(seq_len(max(all.edges)), descendantsCutAtStem.idx, all.edges=all.edges);#
		}#
		if (shiftCut == "both" || shiftCut == "node")#
		{#
			if (!is.null(desc.stem))#
			{#
				root <- min(z[,"anc"]);#
				desc.node <- lapply(desc.stem, stripStem);#
				desc.node[root] <- desc.stem[root];#
			} else {#
				desc.node <- lapply(seq_len(max(all.edges)), descendantsCutAtNode.idx, all.edges=all.edges);#
			}#
		}#
	}#
	cat(" done.\n");#
	#
## Needed downstream; don't recalculate#
 ## Gives the number of tips associated with an internal node; determines whether a node is 'virgin' or not#
	num.tips <- list()#
	cat("  Gathering tip richness information...");#
	if (mc)#
	{#
		num.tips <- mclapply(all.nodes, getNumTips, phy=phy, totalTips=n.tips, mc.cores=numCores);#
	} else {#
		num.tips <- lapply(all.nodes, getNumTips, phy=phy, totalTips=n.tips);#
	}#
	cat(" done.\n");#
	#
	res <- list(z=z, desc.stem=desc.stem, desc.node=desc.node, num.tips=num.tips);#
	return(res);#
}#
#
#
## Get the number of tips descended from internal node 'node'.#
## Needed for determining whether nodes are virgin nodes.#
## Uses code from geiger functions 'node.sons' and 'node.leaves'.#
getNumTips <- function (node, phy, totalTips=NULL)#
{#
	if (is.null(totalTips)) totalTips <- length(phy$tip.label);#
	if (node <= totalTips) return(1);#
	#
	n <- 0;#
	d <- phy$edge[which(phy$edge[, 1] == node), 2];#
	for (j in d) {#
		if (j <= totalTips)#
			n <- n + 1#
		else n <- n + getNumTips(j, phy, totalTips)#
	}#
	return(n);#
}#
#
#
#
#
#
# *** MAYBE RECODE descendantsCutAtStem IN C++ AS IT IS SLOW FOR LARGE TREES ***#
#
## This generates the indices of all descendants of a node, using ape's edge matrix.#
## Deals with row numbers of the edge matrix rather than node numbers of the tree.#
descendantsCutAtStem <- function (node, all.edges)#
{#
	ans <- numeric();#
	ans <- node;#
	repeat {#
		node <- all.edges[all.edges[,1] %in% node,2];#
		if (length(node) > 0)#
		{#
			ans <- c(ans, node);#
		} else {break;}#
	}#
	return(ans);#
}#
#
#
## The function 'descendants' returns the indices of all descendants within the edge matrix.#
descendantsCutAtStem.idx <- function (node.list, all.edges)#
{#
	which(all.edges[,1] == node.list | all.edges[,2] %in% descendantsCutAtStem(node.list, all.edges));#
}#
#
#
# Remove stem node from previously calculated set of descendants; about a billion times faster than descendantsCutAtNode#
stripStem <- function (x)#
{#
	y <- unlist(x);#
	return(y[-1]);#
}#
#
#
## This generates the indices of all descendants of a node, using ape's edge matrix.#
## Deals with row numbers of the edge matrix rather than node numbers of the tree.#
descendantsCutAtNode <- function (node, all.edges)#
{#
	ans <- numeric();#
	repeat {#
		node <- all.edges[all.edges[,1] %in% node,2];#
		if (length(node) > 0)#
		{#
			ans <- c(ans, node);#
		} else {break;}#
	}#
	return(ans);#
}#
#
#
## The function 'descendants' returns the indices of all descendants within the edge matrix.#
descendantsCutAtNode.idx <- function (node.list, all.edges)#
{#
	which(all.edges[,1] == node.list | all.edges[,2] %in% descendantsCutAtNode(node.list, all.edges));#
}#
#
#
## Check that provided arguments are valid#
checkValidArguments <- function (phy, richness, model, modelLimit, stop, shiftCut, criterion, stepBack,#
	preserveModelFlavour, epsilon, r, b, d, fixThreshold, initialR, initialE,#
	verbose, mc, numCores)#
{#
	if (class(phy) != "phylo" && class(phy) != "multiPhylo") {cat("\n\nWARNING: tree is not of class \"phylo\". Stopping.\n"); stop;}#
	#
## String arguments#
	model=match.arg(model, choices=c("mixed", "bd", "yule"));#
	stop=match.arg(stop, choices=c("threshold","modelLimit"));#
	shiftCut=match.arg(shiftCut, choices=c("both", "stem", "node"));#
	criterion=match.arg(criterion, choices=c("aicc", "aic"));#
	#
## Boolean arguments#
	if (class(stepBack) != "logical") {cat("\n\nWARNING: argument \"stepBack\"is not of class \"logical\". Stopping.\n"); stop;}#
	if (class(preserveModelFlavour) != "logical") {cat("\n\nWARNING: argument \"preserveModelFlavour\"is not of class \"logical\". Stopping.\n"); stop;}#
	if (class(verbose) != "logical") {cat("\n\nWARNING: argument \"verbose\"is not of class \"logical\". Stopping.\n"); stop;}#
	if (class(mc) != "logical") {cat("\n\nWARNING: argument \"mc\"is not of class \"logical\". Stopping.\n"); stop;}#
	#
## Numeric arguments#
	if (class(modelLimit) != "numeric" && class(modelLimit) != "NULL") {cat("\n\nWARNING: argument \"modelLimit\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(epsilon) != "numeric" && class(epsilon) != "NULL") {cat("\n\nWARNING: argument \"epsilon\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(r) != "numeric" && class(r) != "NULL") {cat("\n\nWARNING: argument \"r\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(b) != "numeric" && class(b) != "NULL") {cat("\n\nWARNING: argument \"b\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(d) != "numeric" && class(d) != "NULL") {cat("\n\nWARNING: argument \"d\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(fixThreshold) != "numeric" && class(fixThreshold) != "NULL") {cat("\n\nWARNING: argument \"fixThreshold\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(initialR) != "numeric" && class(initialR) != "NULL") {cat("\n\nWARNING: argument \"initialR\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(initialE) != "numeric" && class(initialE) != "NULL") {cat("\n\nWARNING: argument \"initialE\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(numCores) != "numeric" && class(numCores) != "NULL") {cat("\n\nWARNING: argument \"numCores\"is invalid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
}
fitSisters(phy, node=422)
## Only used for base model#
medusaMLFitBase <- function (z, sp, model, fixPar, criterion)#
{#
	fit <- getOptimalModelFlavour(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	steps <- c("add", as.numeric(min(z[,"anc"])));#
	#
	return(list(par=matrix(fit$par, nrow=1, dimnames=list(NULL,c("r", "epsilon"))), lnLik.part=fit$lnLik, lnLik=fit$lnLik,#
		split.at=min(z[,"anc"]), aic=round(model.fit[1], digits=7), aicc=round(model.fit[2], digits=7), num.par=model.fit[3],#
		cut.at="node", model=fit$model, z=z, step=matrix(steps, nrow=1, dimnames=list(NULL,c("step", "node")))));#
}#
#
#
## Split the edge matrix 'z' by adding a partition at node 'node'.#
## The list 'desc' is a list of descendants (see makeCacheMedusa).#
## Returns a list with elements:#
##   z: new medusa matrix, with the new partition added#
##   affected: indices of the partitions affected by the split (n == 2).#
medusaSplitStem <- function (node, z, desc, extract=FALSE)#
{#
	part <- z[,"partition"];#
	base <- min(part[z[,"anc"] == node | z[,"dec"] == node]);#
	tag <- max(part) + 1;#
	i <- desc[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	if (extract) {z <- z[idx,,drop=FALSE];}#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
medusaSplitNode <- function (node, z, desc, extract=FALSE)#
{#
	part <- z[,"partition"];#
	base <- min(part[z[,"anc"] == node]);#
	tag <- max(part) + 1;#
	i <- desc[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	if (extract) {z <- z[idx,,drop=FALSE];}#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
## The general function for when the flavour of shiftCut is unknown#
medusaSplit <- function (node, z, desc, shiftCut)#
{#
	descendants <- desc$stem; # will be correct half the time#
	if (shiftCut == "node") {descendants <- desc$node;}#
	#
	part <- z[,"partition"];#
	base <- min(part[z[,1] == node | z[,2] == node]);#
	tag <- max(part) + 1;#
	i <- descendants[[node]];#
	idx <- i[part[i] == base];#
	z[idx,"partition"] <- tag;#
	return(list(z=z, affected=c(unique(part[idx]), tag)));#
}#
#
#
## Pre-fit values for pendant edges; DON'T recalculate later; should account for ~25% of all calculations#
## Also cache values for virgin nodes; useful until subsetted, especially for large trees.#
prefitTips <- function (pend.nodes, z, sp, model, fixPar, criterion, mc, numCores)#
{#
	if (all(z[z[,"dec"] %in% pend.nodes,"n.t"] == 1) && (model == "yule" || model == "mixed"))#
	{#
		fit <- list(list(par=c(0, NA), lnLik=0, model="yule"));#
		fit <- rep(fit, length(pend.nodes));#
		return(fit);#
	}#
	#
	if (model == "mixed") # yule will always have a better AIC for tip, regardless of richness#
	{#
		if (mc) {#
			tips <- mclapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model="yule", fixPar=fixPar, criterion=criterion, mc.cores=numCores);#
		} else {#
			tips <- lapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model="yule", fixPar=fixPar, criterion=criterion);#
		}#
	} else {#
		if (mc) {#
			tips <- mclapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model=model, fixPar=fixPar, criterion=criterion, mc.cores=numCores);#
		} else {#
			tips <- lapply(pend.nodes, medusaMLPrefitTip, z=z, sp=sp,#
				model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	return(tips);#
}#
#
medusaMLPrefitTip <- function (node, z, sp, model, fixPar, criterion)#
{#
	z.tip <- z[z[,"dec"] == node,,drop=FALSE];#
	#
	if (all(z.tip[,"n.t"] == 1) && (model == "yule" || model == "mixed"))#
	{#
		return(list(par=c(0, NA), lnLik=0, model="yule"));#
	}#
	#
	fit <- getOptimalModelFlavour(z=z.tip, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
medusaMLPrefitNode <- function (node, z, desc, sp, model, fixPar, criterion)#
{#
	z.node <- medusaSplitNode(node=node, z=z, desc=desc, extract=TRUE)$z;#
	fit <- getOptimalModelFlavour(z=z.node, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
medusaMLPrefitStem <- function (node, z, desc, sp, model, fixPar, criterion)#
{#
	z.stem <- medusaSplitStem(node=node, z=z, desc=desc, extract=TRUE)$z;#
#	z.stem <- z.stem[z.stem[,"partition"] == 2,,drop=FALSE];#
	fit <- getOptimalModelFlavour(z=z.stem, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	return(fit);#
}#
#
#
## When model == mixed, fit both and find optimal flavour#
getOptimalModelFlavour <- function (z, sp, model, fixPar, criterion)#
{#
	fit.bd <- NULL;#
	fit.yule <- NULL;#
	fit <- NULL;#
	#
	if (model == "yule" | model == "mixed")#
	{#
		fit.yule <- medusaMLFitPartition(z=z, sp=sp, model="yule");#
		fit.yule$model <- "yule";#
	}#
	if (model == "bd" | model == "mixed")#
	{#
		if (is.na(sp[2])) {sp[2] <- 0.5;}#
		fit.bd <- medusaMLFitPartition(z=z, sp=sp, model="bd");#
		fit.bd$model <- "bd";#
	}#
	if (model != "mixed" && model != "bd" && model != "yule") # i.e. the constrained models#
	{#
		fit <- medusaMLFitPartition(z=z, sp=sp, model=model, fixPar=fixPar);#
		fit$model <- model;#
		return(fit);#
	}#
	#
## Figure out which model fits best#
	if (is.null(fit.bd))#
	{#
		fit <- fit.yule;#
	} else if (is.null(fit.yule)) {#
		fit <- fit.bd;#
	} else {#
## Considering both models#
		fit <- getBestPartialModel(fit1=fit.yule, fit2=fit.bd, z=z, criterion=criterion);#
		#
		#
		# fit.bd.val <- calculateModelFit(fit=fit.bd, z=z); ## NOT valid here, as sample size is NOT z#
		# fit.yule.val <- calculateModelFit(fit=fit.yule, z=z);#
		#
## The length condition below deals with single edges, where AICc correction becomes undefined (n-k-1)#
  # Undefined#
	}#
	return(fit);#
}#
#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
medusaMLUpdate <- function (node, z, desc, fit, prefit, num.tips, root.node, model, fixPar, criterion, shiftCut, preserveModelFlavour)#
{#
## various combinations possible#
	fit1.stem <- NULL;#
	fit1.node <- NULL;#
	fit2.stem <- NULL;#
	fit2.node <- NULL;#
	cut.at <- NULL;#
	#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cool <- TRUE;#
	#
	# new.part.1 <- NULL;#
	# new.part.2 <- NULL;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
	if (shiftCut == "stem" | shiftCut == "both" | node < root.node) # can enter on "node" if a tip#
	{#
## First, diminshed clade#
		obj.stem <- medusaSplitStem(node=node, z=z, desc=desc$stem);#
		z.stem <- obj.stem$z;#
		aff <- obj.stem$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
		if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
		{#
			fit$lnLik <- -Inf;#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			return(fit);#
		}#
		#
## Everything is cool; proceed.#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
## first, consider diminshed clade. may result in a clade that has been cached previously#
		dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
		#
## check if diminished clade conforms to a cached clade#
		x <- which(dimClade[,"anc"] == min(dimClade[,"anc"]));#
		if (length(x) == 1) # a cut-at-stem scenario#
		{#
			y <- as.numeric(dimClade[x, "dec"]);#
			if (length(unique(dimClade[(dimClade[,"dec"] < root.node),"dec"])) == prefit$num.tips[[y]])#
			{#
				if (y < root.node)#
				{#
					fit1.stem <- prefit$tips[[y]];#
				} else {#
					fit1.stem <- prefit$virgin.nodes$stem[[y - root.node]];#
				}#
#				cat("Worked! Clade is of size:", length(dimClade[,1]), "\n")#
			}#
		}#
				#
		if(is.null(fit1.stem))#
		{#
			if (model == "mixed")#
			{#
				if (preserveModelFlavour)  ## In mixed models, may want to conserve flavour of previously fit model#
				{#
					if (sum(!is.na(sp)) < 2) # yule#
					{#
						fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model="yule");#
					} else {#
						fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model="bd");#
					}#
				} else {#
## consider both model flavours#
					fit1.stem <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
				}#
			} else {#
				fit1.stem <- medusaMLFitPartition(z=dimClade, sp=sp, model=model, fixPar=fixPar);#
				fit1.stem$model <- model;#
			}#
		}#
		#
		#
## Second, new clade#
		if (node < root.node) # tip, already calculated#
		{#
			fit2.stem <- prefit$tips[[node]];#
		} else if (length(unique(z.stem[(z.stem[,"partition"] == aff[2] & z.stem[,"dec"] < root.node),"dec"])) == prefit$num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.stem <- prefit$virgin.nodes$stem[[node - root.node]];#
		} else {#
## novel shift#
			newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
			fit2.stem <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	#
	if ((shiftCut == "node" || shiftCut == "both") && (node > root.node)) # never enter if tip#
	{#
## First, diminshed clade#
		obj.node <- medusaSplitNode(node=node, z=z, desc=desc$node);#
		z.node <- obj.node$z;#
		aff <- obj.node$affected;#
		#
## Need to check if cut is valid. May be inadmissable because of pattern of previous breaks (especially with shiftCut=both)#
		if (is.na(aff[1]) || is.na(aff[2]))#
		{#
			cool <- FALSE;#
		}		#
## Check that partition is not empty; can occur with "node" or "both" cutting.#
		if (sum(z.node[,"partition"] == aff[1]) == 0 || sum(z.node[,"partition"] == aff[2]) == 0 || !cool)#
		{#
			fit$lnLik <- -Inf;#
			fit$aic <- Inf;#
			fit$aicc <- Inf;#
			return(fit);#
		}#
		#
## Everything is cool; proceed.#
		sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
		#
## first, consider diminshed clade. may result in a clade that has been cached#
		dimClade <- z.node[z.node[,"partition"] == aff[1],,drop=FALSE];#
		#
		if (model == "mixed")#
		{#
			if (preserveModelFlavour)  ## In mixed models, may want to conserve flavour of previously fit model#
			{#
				if (sum(!is.na(sp)) < 2) # yule#
				{#
					fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model="yule"); # should this change? probably.#
				} else {#
					fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model="bd");#
				}#
			} else {#
## consider both model flavours#
				fit1.node <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
			}#
		} else {#
			fit1.node <- medusaMLFitPartition(z=dimClade, sp=sp, model=model, fixPar=fixPar);#
			fit1.node$model <- model;#
		}#
## Second, new clade#
		if (length(unique(z.node[(z.node[,"partition"] == aff[2] & z.node[,"dec"] < root.node),"dec"])) == prefit$num.tips[[node]]) {#
## vigin node, already calculated#
			fit2.node <- prefit$virgin.nodes$node[[node - root.node]];#
		} else {#
## novel shift#
			newClade <- z.node[z.node[,"partition"] == aff[2],,drop=FALSE];#
			fit2.node <- getOptimalModelFlavour (z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		}#
	}#
	#
## Now, figure out which shift position is optimal	#
	if (is.null(fit2.node))#
	{#
		fit1 <- fit1.stem;#
		fit2 <- fit2.stem;#
		cut.at <- "stem";#
	} else if (is.null(fit1.stem)) {#
		fit1 <- fit1.node;#
		fit2 <- fit2.node;#
		cut.at <- "node";#
	} else {#
## Considering both places for a shift#
		stem.lik <- (fit1.stem$lnLik + fit2.stem$lnLik);#
		stem.par <- rbind(fit1.stem$par, fit2.stem$par)#
		stem.val <- list(lnLik=stem.lik, par=stem.par, model=model);#
		stem.fit <- calculateModelFit(fit=stem.val, z=z);#
		#
		node.lik <- (fit1.node$lnLik + fit2.node$lnLik);#
		node.par <- rbind(fit1.node$par, fit2.node$par)#
		node.val <- list(lnLik=node.lik, par=node.par, model=model);#
		node.fit <- calculateModelFit(fit=node.val, z=z);#
		#
		if (criterion == "aic") {element <- 1;} else {element <- 2;}#
		#
		if (stem.fit[[element]] < node.fit[[element]])#
		{#
			fit1 <- fit1.stem;#
			fit2 <- fit2.stem;#
			cut.at <- "stem";#
		} else {#
			fit1 <- fit1.node;#
			fit2 <- fit2.node;#
			cut.at <- "node";#
		}#
	}#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	if (!preserveModelFlavour) {fit$model[aff[1]] <- fit1$model;} # update altered model#
	#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	#
	return(fit);#
}#
#
## sp = initializing values for r & epsilon. fixPar = fixed value for constrained model.#
## Default values should never be used (except for first model), as the values from the previous model are passed in.#
## The 'suppressWarnings' catches harmless warnings for when extreme parameter values are tried, #
## generating -Inf log-likelihoods. Depends on sclae of the tree.#
medusaMLFitPartition <- function (z, sp=c(0.05, 0.5), model, fixPar=NULL)#
{#
#	new.part <- z[z[,"partition"] == partition.id,,drop=FALSE]; # now subsetted earlier#
	new.part <- z;#
	#
# Construct likelihood function:#
	lik <- makePartitionLikelihood(partition=new.part, model=model, fixPar=fixPar);#
	foo <- function (x) {-lik(pars=exp(x));} # work with parameters in log-space to preserve precision#
	#
	if (model == "bd")#
	{#
		fit <- optim(fn=foo, par=log(sp), method="N", control=list(maxit=5000));#
		#
		if(fit$convergence != 0) {cat("\nDidn't converge. Shit. Convergence = ", fit$convergence, "\n");}#
		#
		return(list(par=exp(fit$par), lnLik=-fit$value));#
	}#
		#
## grab values to get an intelligent upper bound on b or r#
		node.richness  <- sum(new.part[,"n.t"], na.rm=TRUE);#
		depth <- max(new.part[,"t.0"]);#
		#
# use different intervals based on model flavour#
	#
	if (model == "yule") {#
		#
		maxVal <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {maxVal <- 1e-5;}#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-25, log(maxVal))));#
		par <- c(exp(fit$minimum), NA);#
		#
		while (par[1]/maxVal > 0.95) # crash against boundary; doesn't seem to get used...#
		{#
			maxVal <- par[1] * 3;#
			cat("Hit boundary\n")#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(par[1]/2), log(maxVal))));#
			par <- c(exp(fit$minimum), NA);#
		}#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedD") {#
## this is the messiest model flavour; reasonable range depends on magnitude of fixD#
		#
		x <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {x <- 0.01;} # MLE for single tip will be r ~ 0#
		maxVal <- fixPar + x;#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(log(fixPar), log(maxVal))));#
		b <- exp(fit$minimum);#
		par <- c((b - fixPar), (fixPar / b));#
		#
		while (fit$objective == Inf)#
		{#
			cat("maxVal =", maxVal, "; b =", b, "; r =", b - fixPar, "; epsilon =", fixPar/b, "\n")#
			#
			x <- x * 0.75;#
			maxVal <- fixPar + x;#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(fixPar), log(maxVal))));#
			b <- exp(fit$minimum);#
			par <- c((b - fixPar), (fixPar / b));#
		}#
		#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedEpsilon") {#
		#
		maxVal <- (log(node.richness) / depth) * 5;#
		if (node.richness <= 1) {maxVal <- 1;}#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-25, log(maxVal))));#
		par <- c(exp(fit$minimum), sp[2]);#
		#
		while (par[1]/maxVal > 0.9) # crash against boundary#
		{#
			maxVal <- par[1] * 3;#
			suppressWarnings(fit <- optimize(f=foo, interval=c(log(par[1]/2), log(maxVal))));#
			par <- c(exp(fit$minimum), sp[2]);#
		}#
		#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedB") {#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-50, log(fixPar))));#
		d <- exp(fit$minimum);#
		par <- c((fixPar - d), (d / fixPar));#
		return(list(par=par, lnLik=-fit$objective));#
		#
	} else if (model == "fixedR") {#
		#
		suppressWarnings(fit <- optimize(f=foo, interval=c(-50, 0)));#
		par <- c(sp[1], exp(fit$minimum));#
		return(list(par=par, lnLik=-fit$objective));#
	}#
}#
#
#
## Calculations are from the following:#
## Rabosky et al. 2007. Proc. Roy. Soc. 274: 2915-2923.#
## Foote et al. 1999. Science. 283: 1310-1314#
## Raup. 1985. Paleobiology 11: 42-52 [Foote et al. correct the equation [A18] where a > 1]#
## Bailey. 1964. The Elements Of Stochastic Processes, With Applications To The Natural Sciences#
## Kendall. 1948. Ann. Math. Stat. 19: 1–15.#
###
## A = probability of extinction of one lineage over time 't'#
## B = A * (lambda/mu)#
###
## When there is a single lineage at time 0 (a = 1), the calculation is#
##   log(1 - A) + log(1 - B) + (n - 1)*log(B)#
## but this is conditioned on survival by dividing by (1-A)#
## (subtracting log(1 - A) on a log scale) which cancels to give:#
##   log(1 - B) + (n - 1)*log(B)#
##      - for n.t == 1, reduces further to log(1-B)#
###
## A = mu*(exp((lambda - mu)*t) - 1)) / (lambda*exp((lambda - mu)*t) - mu)#
##  let r = (lambda - mu); ert = exp((lambda - mu)*t)#
## A = mu*(ert - 1)/(lambda*ert - mu)#
###
## B = A * (lambda/mu)#
##   = [mu*(ert - 1)/(lambda*ert - mu)] * (lambda/mu)#
##   = (lambda*(ert - 1))/(lambda*ert - mu)#
##   = (lambda*(ert - 1))/(lambda(ert - mu/lambda))#
##   = (ert - 1) / (ert - epsilon)#
#
## All pendant nodes begin with richness '1'; calculations simple.#
#			i.pend.n.t.1 <- which(pend.n.t == 1)   # calculations even simpler: log(1-B)#
#			i.pend.n.t.n1 <- which(pend.n.t != 1)#
#
## makePartitionLikelihood: generate a likelihood function for a single partition.#
makePartitionLikelihood <- function (partition, model, fixPar)#
{#
	i.int <- is.na(partition[,"n.t"])#
	i.pend <- !(i.int)#
	n.int <- sum(i.int);#
	#
	simple <- FALSE;#
	if (all(partition[,"n.t"] == 1, na.rm = TRUE)) {simple <- TRUE;}#
	#
	if (simple) {#
		if (model == "yule") {#
			sum.t <- sum(partition[,"t.len"]);#
			f <- function(pars) {#
				if (pars <= 0) return(-Inf);#
				r <- pars[1];#
				return(n.int * log(r) - r * sum.t);#
			}#
			return(f)#
		} #
		#
		sum.int.t.len <- sum(partition[i.int,"t.len"]);#
		int.t.0 <- partition[i.int,"t.0"];#
		pend.t.len <- partition[i.pend,"t.len"];#
		#
		if (model == "bd") {#
			f <- function(pars) {#
				r <- pars[1];#
				epsilon <- pars[2];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedD") {#
			fixD <- fixPar;#
			f <- function(pars) {#
				b <- pars[1];#
				r <- b - fixD;#
				epsilon <- fixD/b;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedEpsilon") {#
			epsilon <- fixPar;#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedR") {#
			r <- fixPar;#
			f <- function(pars) {#
				epsilon <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedB") {#
			fixB <- fixPar;#
			f <- function(pars) {#
				d <- pars[1];#
				r <- fixB - d;#
				epsilon <- d/fixB;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				l.pend <- sum(log(1 - epsilon) - log(exp(r * pend.t.len) - epsilon));#
				return(l.int + l.pend);#
			}#
			return(f)#
		}#
	} else {#
		sum.int.t.len <- sum(partition[i.int,"t.len"]);#
		pend.t.len <- partition[i.pend,"t.len"];#
		pend.n.t.minus.1 <- partition[i.pend,"n.t"] - 1;#
		#
		if (model == "yule") {#
			sum.pend.t.len <- sum(pend.t.len);#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0) return(-Inf);#
				return(n.int * log(r) - r * sum.int.t.len + sum(-pend.t.len * r + pend.n.t.minus.1*log(1 - exp(-pend.t.len * r))));#
			}#
			return(f)#
		}#
		#
		int.t.0 <- partition[i.int,"t.0"];#
		#
		if (model == "bd") {#
			f <- function(pars) {#
				r <- pars[1];#
				epsilon <- pars[2];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedD") {#
			fixD <- fixPar;#
			f <- function(pars) {#
				b <- pars[1];#
				r <- b - fixD;#
				epsilon <- fixD/b;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedEpsilon") {#
			epsilon <- fixPar;#
			f <- function(pars) {#
				r <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedR") {#
			r <- fixPar;#
			f <- function(pars) {#
				epsilon <- pars[1];#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		} else if (model == "fixedB") {#
			fixB <- fixPar;#
			f <- function(pars) {#
				d <- pars[1];#
				r <- fixB - d;#
				epsilon <- d/fixB;#
				if (r <= 0 | epsilon < 0 | epsilon >= 1) {return(-Inf);}#
				l.int <- n.int * log(r) - r * sum.int.t.len - sum(log(1 - (epsilon * exp(-r * int.t.0))));#
				ert <- exp(r * pend.t.len);#
				B <- (ert - 1) / (ert - epsilon);#
				l.pend <- sum(log(1 - B) + pend.n.t.minus.1*log(B));#
				return(l.int + l.pend);#
			}#
			return(f)#
		}#
	}#
}#
#
#
#
## 'fit' contains '$par' and '$lnlik' and '$model'; check last value for presence of fixed parameters#
calculateModelFit <- function (fit, z)#
{#
## Sample size taken (for now) as the total num.nodes in the tree (internal + pendant)#
  # num.nodes = (2*length(phy$tip.label) - 1) == (2*length(richness[,1]) - 1) == length(z[,1]) + 1#
#	n <- (length(z[,1]) + 1) + sum(!is.na(z[,"n.f"]));#
	#
# Since each edge defines a node (i.e. an 'observation'), need only add root node as final obervation#
	n <- (length(z[,1]) + 1);#
	#
 # Includes both formal parameters AND number of breaks. Note: first model does not involve a break.#
## Models where all parameters are estimated (i.e. BD model):#
  # 2 parameters for base model (no breakpoint) + 3 parameters (r, eps, breakpoint) for each subsequent model#
  #
# Determine number of piecewise models currently involved#
	if (length(fit$par) < 3) # i.e. base model#
	{#
		num.models <- 1;#
	} else {#
		num.models <- length(fit$par[,1]);#
	}#
	model = fit$model[1];#
	#
	if (model == "fixedEpsilon" || model == "fixedR" || model == "fixedB" || model == "fixedD")#
	{#
		k <- 2 * num.models - 1;#
	} else {#
		k <- sum(!is.na(fit$par)) + num.models - 1; # number of estimated parameters + number of breaks#
	}#
	#
	lnLik <- fit$lnLik;#
	#
#	aic <- -2 * lnLik + 2*k;#
	aic <- getAIC(lnLik, k);#
#	aicc <- aic + 2*k*(k+1)/(n-k-1);#
	aicc <- getAICc(lnLik, k, n);#
	#
	model.fit <- c(aic, aicc, k);#
	return(model.fit);#
}#
#
getAIC <- function (lnLik, k)#
{#
	return(-2 * lnLik + 2*k);#
}#
#
getAICc <- function (lnLik, k, n)#
{#
	return(getAIC(lnLik,k) + 2*k*(k+1)/(n-k-1));#
}#
#
## Used for comparing models fit to the same partition#
getBestPartialModel <- function (fit1, fit2, z, criterion)#
{#
	n <- (length(z[,1]) + 1); # the number of nodes involved#
## Add '1' to parameters to account for break#
	k1 <- 1 + sum(!is.na(fit1$par));#
	k2 <- 1 + sum(!is.na(fit2$par));#
	#
	if (n - k1 <= 1 || n - k2 <= 1) # deals with single edges, where AICc correction becomes undefined. use AIC.#
	{#
		if (getAIC(fit1$lnLik,k1) < getAIC(fit2$lnLik,k2))#
		{#
			return(fit1);#
		} else {#
			return(fit2);#
		}#
	} else {#
		if (criterion == "aicc")#
		{#
			if (getAICc(fit1$lnLik,k1,n) < getAICc(fit2$lnLik,k2,n))#
			{#
				return(fit1);#
			} else {#
				return(fit2);#
			}#
		} else {#
			if (getAIC(fit1$lnLik,k1) < getAIC(fit2$lnLik,k2))#
			{#
				return(fit1);#
			} else {#
				return(fit2);#
			}#
		}#
	}#
}
fitSisters(phy, node=422)
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$model[aff[1]] <- fit1$model;#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(phy, node=422)
medusaSummary <- function(results, modelNum=NULL, cutoff="threshold", criterion="aicc", plotTree=TRUE,#
	time=TRUE, node.labels=TRUE, cex=0.5, plotSurface=FALSE, printTitle=TRUE, n.points=100, ...)#
{#
# Desirables:#
#  1. table listing parameter values of selected model#
#  2. list parameters of base model#
#  3. tree printed with colour-coded edges, node labels to indicate split position(s)#
#  4. plot likelihood surface#
	#
# Extract components from results#
	fit <- results$models;#
	phy <- results$phy;#
	desc <- results$desc;#
	modelSummary <- results$modelSummary;#
	threshold <- results$threshold;#
	cutAt <- as.character(modelSummary$Cut.at);#
	cutAt[1] <- "NA";#
	fixPar <- results$fixPar;#
	baseModel <- as.data.frame(fit[[1]]$par);#
	baseFlavour <- fit[[1]]$model;#
	#
# First, determine which model is desired#
	model.id <- 0;#
	if (!is.null(modelNum))#
	{#
		model.id <- modelNum;#
	} else {   # Find best model using some criterion (threshold or user-defined)#
		if (cutoff != "threshold") {threshold <- cutoff}#
		else {cat("\nSelecting model based on corrected threshold (improvement in information theoretic score of ",#
				threshold, " units).\n", sep="");}#
		model.id <- 1;#
		while (1)#
		{#
			if ((model.id + 1) > length(fit)) break;#
			if ((unlist(fit[[model.id]][criterion]) - unlist(fit[[model.id+1]][criterion])) < threshold) break;#
			model.id <- model.id + 1;#
		}#
	}#
	#
	fit <- fit[[model.id]];#
	break.pts <- fit$split.at;#
	cuts <- cutAt[1:length(break.pts)];#
	modelFlavour <- fit$model;#
	z <- fit$z;#
	#
	# Get desired tree-model conformation#
# Check on cutAtStem option to accurately recover model and paint tree; made more difficult by stepBack ***#
	labels <- break.pts;#
	if (length(break.pts) > 1)#
	{#
		labels[1] <- break.pts[1];#
		for (i in 2:length(break.pts))#
		{#
#			tmp <- medusaSplit(node=break.pts[i], z=z, desc=desc, shiftCut=cutAt[i]);#
			if (cutAt[i] == "stem")#
			{#
				labels[i] <- z[which(z[,"dec"] == break.pts[i]),"anc"];#
			}#
#			z <- tmp$z;#
		}#
	}#
	#
# Determine parameter confidence intervals, print in table#
	profLikes <- getProfileLikelihoods(z=z, parm=fit$par, models=modelFlavour, fixPar=fixPar);#
		#
	opt.model <- cbind(N.Models=seq(1:length(fit$split.at)), Shift.Node=fit$split.at,#
		round(fit$par, digits=7), LnLik.part=fit$lnLik.part)#
	opt.model <- as.data.frame(opt.model);#
	if (all(modelFlavour == "yule"))#
	{#
		opt.model <- cbind(opt.model[,c(1:2)], Cut.at=cuts, Model=modelFlavour, r=opt.model[,3], profLikes[,c(1:2)],#
			opt.model[,c(4:5)])#
	} else {#
		opt.model <- cbind(opt.model[,c(1:2)], Cut.at=cuts, Model=modelFlavour, r=opt.model[,3], profLikes[,c(1:2)],#
			epsilon=opt.model[,4], profLikes[,c(3:4)], LnLik.part=opt.model[,5])#
	}#
	#
	opt.model[1,2] <- NA # root node for base model#
	#
	cat("\nEstimated parameter values for model #", model.id, ":\n\n", sep="");#
	print.data.frame(opt.model, digits=5);#
	cat("\n95% confidence intervals calculated from profile likelihoods\n")#
	#
	opt.fit <- 0;#
	base.fit <- 0;#
	if (criterion == "aicc")#
	{#
		opt.fit <- modelSummary$aicc[model.id];#
		base.fit <- modelSummary$aicc[1];#
	} else { # aic used#
		opt.fit <- modelSummary$aic[model.id];#
		base.fit <- modelSummary$aic[1];#
	}#
	cat("\nModel fit summary for model #", model.id, ":\n\n", sep="");#
	cat("\tLog-likelihood = ", as.numeric(results$models[[model.id]]["lnLik"]), "\n", sep="");#
	cat("\t", criterion, " = ", opt.fit, "\n", sep="");#
	#
	if (model.id != 1)#
	{#
		cat("\nFor comparison, failure to accommodate rate heterogeneity leads to the following estimated parameter values for the base (single homogeneous-", baseFlavour, ") model:\n\n", sep="");#
		print.data.frame(baseModel, digits=5, row.names=FALSE);#
		cat("\nModel fit summary for base model:\n\n", sep="");#
		cat("\tLog-likelihood = ", as.numeric(results$models[[1]]["lnLik"]), "\n", sep="");#
		cat("\t", criterion, " = ", base.fit, "\n", sep="");#
	}#
		#
	mm <- match(phy$edge[,2], z[,"dec"]);#
	edge.color=z[mm,"partition"];#
# Plot tree with purdy colours and labelled nodes (to better map between tree and table)#
	if (plotTree)#
	{#
		dev.new();#
		margin <- FALSE;#
		#
		if (time) margin <- TRUE;#
		plot.phylo(phy, edge.color=edge.color, no.margin=!margin, cex=cex, ...);#
		if (time)#
		{#
			axisPhylo(cex.axis=0.75);#
			mtext("Divergence Time (MYA)", at=(max(get("last_plot.phylo", envir = .PlotPhyloEnv)$xx)*0.5),#
				side = 1, line = 2, cex=0.75);#
		}#
		if (node.labels) # label with stem/node breaks in mind#
		{#
			for (i in  1:length(break.pts))#
			{#
				nodelabels(i, node=labels[i], frame = "c", font = 1, cex=0.5);#
			}#
		}#
	}#
	#
	#
## *** BRING THIS OUTSIDE TO FORM ITS OWN FUNCTION ***#
	if (plotSurface)#
	{#
		n.pieces <- length(opt.model[,1]);#
		cat("\n");#
		for (k in 1:n.pieces)#
		{	#
			if (fit$model[k] == "bd")#
			{#
				lik <- makePartitionLikelihood(z[z[,"partition"] == k,,drop=FALSE], model="bd");#
## center these around the MLEs#
				opt.r <- as.numeric(opt.model[k,"r"]);#
				opt.epsilon <- as.numeric(opt.model[k,"epsilon"]);#
				#
				lik.vals <- matrix(nrow=n.points, ncol=n.points);#
				r.vals <- seq(from=(opt.r/10), to=(opt.r*2), length.out=n.points);#
				eps.vals <- seq(from=1e-10, to=1.0, length.out=n.points);#
				#
				for (i in 1:length(r.vals))#
				{#
					for (j in 1:(length(eps.vals))) {lik.vals[i,j] <- lik(pars=c(r.vals[i], eps.vals[j]));}#
				}#
				if (n.pieces > 1) {cat("Completed computing surface for piecewise model #", k, "\n", sep="");}#
				#
# Contour plot#
				dev.new();#
				#
				max.lik <- as.numeric(opt.model[k,"LnLik.part"])  # MLE#
				#
				lines <- c(max.lik-0.5, max.lik-1, max.lik-2, max.lik-3, max.lik-4, max.lik-5,#
					max.lik-10, max.lik-50, max.lik-100)#
				contour(lik.vals, levels=lines, labels=c(0.5, 1, 2, 3, 4, 5, 10, 50, 100), axes=FALSE,#
					xlab="r (b-d)", ylab="epsilon (d/b)", method="flattest")#
				tics<-floor(c(1, n.points/4, n.points/2, n.points*3/4, n.points));#
				axis(1, at=c(0, 0.25, 0.5, 0.75, 1), labels=round(r.vals[tics], 3));#
				axis(2, at=c(0, 0.25, 0.5, 0.75, 1), labels=round(eps.vals[tics], 3));#
				points(x=opt.r*(1/(min(r.vals)+max(r.vals))), y=opt.epsilon*(1/(min(eps.vals)+max(eps.vals))),#
					pch=16, col="black"); # inferred ML values#
				if (n.pieces > 1 && printTitle) {title(main=paste("Piecewise Birth-Death Model #", k, sep=""));}#
			} else if (fit$model[k] == "yule" || fit$model[k] == "fixedEpsilon" || fit$model[k] == "fixedR") {#
				lik <- makePartitionLikelihood(z[z[,"partition"] == k,,drop=FALSE], model=fit$model[k], fixPar=fixPar);#
				#
				opt.val <- as.numeric(opt.model[k,"r"]);#
				lik.vals <- numeric(n.points);#
				#
				if (opt.val > 0)#
				{#
					if (fit$model[k] == "fixedR")#
					{#
						par.vals <- seq(from=(profLikes[k,3]/2), to=(profLikes[k,4] * 2), length.out=n.points);#
					} else {#
						par.vals <- seq(from=(profLikes[k,1]/2), to=(profLikes[k,2] * 2), length.out=n.points);	#
					}#
				} else {#
					par.vals <- seq(from=0, to=1e-5, length.out=n.points);#
				}#
				#
				for (i in 1:length(par.vals))#
				{#
					lik.vals[i] <- lik(pars=par.vals[i]);#
				}#
				if (n.pieces > 1) {cat("Completed computing surface for piecewise model #", k, "\n", sep="");}#
				#
				dev.new();#
				#
				max.lik <- as.numeric(opt.model[k,"LnLik.part"]);  # MLE#
				#
				xLabel <- "r (b-d)";#
				if (fit$model[k] == "fixedR") {xLabel <- "epsilon (d/b)";}#
				plot(par.vals, lik.vals, xlab=xLabel, ylab="Log-Likelihood", type="l");#
				points(x=opt.val, y=max.lik, pch=16, col="black");#
				if (n.pieces > 1 && printTitle) {title(main=paste("Piecewise ", fit$model[k], " Model #", k, sep=""));}#
			}#
		}#
	}#
	treeParameters <- list(z=z, edge.colour=edge.color, break.pts=break.pts, phy=phy, labels=labels);#
	class(treeParameters) <- "medusa.summary";#
	invisible(treeParameters);#
}#
#
#
## Prints out a table of likelihoods, parameters, and aic scores#
calculateModelFitSummary <- function (models, phy, threshold, ...)#
{#
	tmp <- matrix(nrow=(length(models)), ncol=6);#
	colnames(tmp) <- c("N.Models", "Shift.Node", "N.Param", "Ln.Lik", "aic", "aicc");#
	#
	w.aic <- numeric(length(models));#
	w.aicc <- numeric(length(models));#
	cut.at <- character(length(models));#
	model <- character(length(models));#
	#
	for (i in 1:length(tmp[,1]))#
	{#
		tmp[i,] <- c(length(models[[i]]$split.at), tail(models[[i]]$split.at,1), models[[i]]$num.par, models[[i]]$lnLik,#
			models[[i]]$aic, models[[i]]$aicc);#
		cut.at[i] <- tail(models[[i]]$cut.at,1);#
		model[i] <- tail(models[[i]]$model,1);#
	}#
	cut.at[1] <- "NA";#
	#
	all.res <- as.data.frame(tmp);#
	#
	if (threshold == 0)#
	{#
		w.aic <- round(calculateModelWeights(all.res$aic), digits=5);#
		w.aicc <- round(calculateModelWeights(all.res$aicc), digits=5);#
		all.res <- cbind(all.res[,c(1:2)], Cut.at=cut.at, Model=model, all.res[,c(3:5)], w.aic=w.aic$w,#
			aicc=all.res$aicc, w.aicc=w.aicc$w);#
	} else {#
		all.res <- cbind(all.res[,c(1:2)], Cut.at=cut.at, Model=model, all.res[,c(3:6)]);#
	}#
	#
	all.res[1,2] <- NA # root node for base model#
#
	return(all.res);#
}#
#
#
## 'fit' is a single vector of AIC scores across all models#
## These are meaningless when using a threshold criterion#
calculateModelWeights <- function (fit)#
{#
	best <- min(fit);#
	delta <- fit-best;#
	sumDelta <- sum(exp(-0.5 * delta));#
	w <- (exp(-0.5 * delta)/sumDelta);#
	#
	results <- data.frame(fit=fit, delta=delta, w=w);#
	#
	return(results);#
}#
#
#
## Create a plot of model-fit vs. model-size. not used anymore. easily generated.#
plotModelFit <- function (all.res)#
{#
	ylim <- c(min(all.res[,"aic"],all.res[,"aicc"]), max(all.res[,"aic"],all.res[,"aicc"]));#
	plot(all.res[,"N.Models"],all.res[,"aicc"], xlab="Number of Piecewise Models", ylab="Model Fit",#
		ylim=ylim, type="l", col="blue");#
	points(all.res[,"N.Models"],all.res[,"aicc"], col="blue", pch=21, bg="white");#
	points(all.res[,"N.Models"],all.res[,"aic"], col="black", type="l");#
	points(all.res[,"N.Models"],all.res[,"aic"], col="black", pch=21, bg="white");#
	#
	legend("topleft", c("aicc","aic"), pch=21, pt.bg="white", lty=1, col=c("blue", "black"),#
		inset = .05, cex=0.75, bty="n"); # 'bottomright' also works#
}#
#
#
## passed-in function fun will have form: lik <- makePartitionLikelihood(partition=new.part, model=model);#
## passed-in parameters parm are MLEs stored in a matrix#
getProfileLikelihoods <- function (z, parm, models, fixPar, crit=1.92)#
{#
	res <- matrix(nrow=length(parm[,1]), ncol=4);#
	colnames(res) <- c("r.low", "r.high", "eps.low", "eps.high")#
	inc <- 0.05;#
	#
	for (i in 1:length(parm[,1]))#
	{#
#		cat("Model",i,"\n")#
		model <- models[i]#
		sp <- as.numeric(parm[i,]);#
		new.part <- z[z[,"partition"] == i,,drop=FALSE];#
		lik <- makePartitionLikelihood(partition=new.part, model=model, fixPar=fixPar);#
		#
		if (model == "yule")#
		{#
			par <- sp[1];#
			maxLik <- lik(par); if (maxLik == -Inf) maxLik <- 0; # correct for -Inf at boundary lambda == 0#
			#
			threshold <- function (x) lik(x) - maxLik + crit; # find roots on either side of maxLik#
			#
	## need intelligent bounds#
			if (par != 0)#
			{#
				low.bound <- par - par/2;#
				up.bound <- par + par/2;#
			} else {#
				low.bound <- par;#
				up.bound <- par + inc/2;#
			}#
			#
			if (low.bound != 0)#
			{#
				while (threshold(low.bound) > 0)#
				{#
					low.bound <- low.bound - inc;#
				}#
			}#
			while (threshold(up.bound) > 0)#
			{#
				up.bound <- up.bound + inc;#
			}#
			#
			if (low.bound <= 0) {#
				res[i,1] <- 0;#
			} else {#
				res[i,1] <- uniroot(threshold, lower=low.bound, upper=par)$root;#
			}#
			if (par == 0) par <- 1e-10; # avoid -Inf at boundary#
			res[i,2] <- uniroot(threshold, lower=par, upper=up.bound)$root;#
			#
		} else if (model == "bd") {#
			par1 <- sp[1]; par2 <- sp[2];#
			maxLik <- lik(sp);#
			#
	## first, r#
			thresholdR <- function (x) lik(c(x, par2)) - maxLik + crit;#
			#
			low.bound <- par1 - par1/2;#
			up.bound <- par1 + par1/2;#
			#
			while (thresholdR(low.bound) > 0)#
			{#
				low.bound <- low.bound - inc;#
			}#
			while (thresholdR(up.bound) > 0)#
			{#
				up.bound <- up.bound + inc;#
			}#
			if (low.bound <= 0) low.bound <- 0;#
			#
			res[i,1] <- uniroot(thresholdR, lower=low.bound, upper=par1)$root;#
			res[i,2] <- uniroot(thresholdR, lower=par1, upper=up.bound)$root;#
			#
	## now, epsilon#
			thresholdE <- function (x) lik(c(par1, x)) - maxLik + crit;#
			#
			low.bound <- par2 - par2/2;#
			up.bound <- par2 + par2/2;#
			#
			while (thresholdE(low.bound) > 0)#
			{#
				low.bound <- low.bound - inc;#
			}#
			while (thresholdE(up.bound) > 0)#
			{#
				up.bound <- up.bound + inc;#
			}#
			#
			if (low.bound < 0) low.bound <- 0;#
			if (up.bound > 1) up.bound <- 1;#
			#
			if (low.bound == 0)#
			{#
				res[i,3] <- 0;#
			} else {#
				res[i,3] <- uniroot(thresholdE, lower=0, upper=par2)$root;#
			}#
			if (up.bound == 1)#
			{#
				res[i,4] <- 1;#
			} else {#
				res[i,4] <- uniroot(thresholdE, lower=par2, upper=up.bound)$root;#
			}#
			#
			if (res[i,3] == par2) res[i,3] <- 0; # precision problem?!? check optimization ***#
			#
		} else if (model == "fixedR" || model == "fixedEpsilon") {#
			par <- sp[1]; # for model == "fixedEpsilon"#
			if (model == "fixedR") {#
				par <- sp[2];#
			}#
			#
			maxLik <- lik(par);#
			threshold <- function (x) lik(x) - maxLik + crit; # find roots on either side of maxLik#
			#
			low.bound <- par - par/2;#
			up.bound <- par + par/2;#
			#
			while (threshold(low.bound) > 0)#
			{#
				low.bound <- low.bound - inc;#
			}#
			while (threshold(up.bound) > 0)#
			{#
				up.bound <- up.bound + inc;#
			}#
			#
			if (low.bound < 0) low.bound <- 0;#
			if (up.bound > 1 && model == "fixedR") up.bound <- 1;#
			#
			if (model == "fixedEpsilon")#
			{#
				res[i,1] <- uniroot(threshold, lower=low.bound, upper=par)$root;#
				res[i,2] <- uniroot(threshold, lower=par, upper=up.bound)$root;#
			} else if (model == "fixedR") {#
				if (par < 1e-10 || low.bound == 0)#
				{#
					res[i,3] <- 0;#
				} else {#
					res[i,3] <- uniroot(threshold, lower=low.bound, upper=par)$root;#
				}#
				if (up.bound == 1)#
				{#
					res[i,4] <- 1;#
				} else {#
					res[i,4] <- uniroot(threshold, lower=par, upper=up.bound)$root;#
				}#
			}#
			#
		} else if (model == "fixedB" || model == "fixedD") {#
			par <- NULL;#
			if (model == "fixedB")#
			{#
				par <- getBD(sp)$d;#
			} else {#
				par <- getBD(sp)$b;#
			}#
			maxLik <- lik(par);#
			threshold <- function (x) lik(x) - maxLik + crit; # find roots on either side of maxLik#
			#
			low.bound <- par - par/2;#
			up.bound <- par + par/2;#
			#
			while (threshold(low.bound) > 0)#
			{#
				low.bound <- low.bound - inc;#
			}#
			while (threshold(up.bound) > 0)#
			{#
				up.bound <- up.bound + inc;#
			}#
			#
			if (low.bound <= 0) low.bound <- 0;#
			if (model == "fixedD") low.bound <- max(low.bound, fixPar);#
			if (model == "fixedB") up.bound <- min(up.bound, fixPar);#
			#
			down <- suppressWarnings(uniroot(threshold, lower=low.bound, upper=par)$root);#
			up <- suppressWarnings(uniroot(threshold, lower=par, upper=up.bound)$root);#
			#
			if (model == "fixedB")#
			{#
				res[i,1] <- fixPar - up;#
				res[i,2] <- fixPar - down;#
				res[i,3] <- down / fixPar;#
				res[i,4] <- up / fixPar;#
			} else { # fixedD#
				res[i,1] <- down - fixPar;#
				res[i,2] <- up - fixPar;#
				res[i,3] <- fixPar / up;#
				res[i,4] <- fixPar / down;#
			}#
		}#
	}#
	res <- as.data.frame(round(res, digits=7));#
	return(res);#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
## More general version of the function getBD below#
BD <- function (par1, par2=NULL)#
{#
	if (is.null(par2))#
	{#
		r <- par1[1];#
		epsilon <- par1[2];#
	} else {#
		r <- par1;#
		epsilon <- par2;#
	}#
	#
	if (is.na(epsilon)) {epsilon <- 0;}#
	#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
#
## Get b and d values from r (b-d) and epsilson (d/b)#
## Used in previous version of program; now in terms of r and epsilon#
## Possibly of use to users wishing to translate results#
getBD <- function (r, epsilon)#
{#
	if (is.na(epsilon)) {epsilon <- 0;}#
	#
	b <- r/(1-epsilon);#
	d <- b-r;   # Alternatively: d <- eps*r/(1-eps)#
	return(list(b=b, d=d));#
}#
#
## Print out tree with ape-style node-numbering#
## Possibly of interest for users to identify numbers of node(s) off interest#
 ## If this is the case, make sure to pass in pruned tree#
plotNN <- function (phy, time=TRUE, margin=TRUE, label.offset=0.5, cex=0.5, ...) #
{#
	phy$node.label <- (length(phy$tip.label) + 1):max(phy$edge);#
	plot.phylo(phy, show.node.label=TRUE, no.margin=!margin, label.offset=label.offset, cex=cex, ...);#
#	if (time && !margin) {cat("Cannot plot time axis without a margin.\n");}#
	if (time && margin) {axisPhylo(cex.axis=0.75)};#
}#
#
print.medusa <- function(x, ...)#
{#
	cat("\n");#
	print(x$modelSummary);#
	cat("\n");#
}#
#
print.multiMedusa <- function(x, ...)#
{#
	cat("\n");#
	cat("MEDUSA results for ", length(x), " trees.\n", sep="")#
	#
	for (i in 1:length(x))#
	{#
		cat("\n");#
		print(x[[i]]$modelSummary);#
	}#
}
fitSisters(phy, node=422)
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$model[aff[1]] <- fit1$model;#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		z <- results$z;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(phy, node=422)
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy, fixPar=fixPar));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=res$fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$model[aff[1]] <- fit1$model;#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		z <- results$z;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(phy, node=422)
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
	#
## Set up model	#
		conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
			initialR=initialR, initialE=initialE);#
		sp <- conf$sp;#
		model <- conf$model;#
		fixPar <- conf$fixPar;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$model[aff[1]] <- fit1$model;#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		z <- results$z;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(phy, node=422)
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
## Set up model	#
	conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
		initialR=initialR, initialE=initialE);#
	sp <- conf$sp;#
	model <- conf$model;#
	fixPar <- conf$fixPar;#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$model[aff[1]] <- fit1$model;#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		z <- results$z;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(phy, node=422)
x
x <- c(phy, phy, phy)
fitSisters(x[[1]], node=422)
fitSisters(x, node=422)
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
## Set up model	#
	conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
		initialR=initialR, initialE=initialE);#
	sp <- conf$sp;#
	model <- conf$model;#
	fixPar <- conf$fixPar;#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar, nTrees=summ$nTrees);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$model[aff[1]] <- fit1$model;#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		z <- results$z;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(x, node=422)
fitSisters(x, node=422) -> foo
attribiutes(foo)
attributes(foo)
foo$nTrees
fitSisters(x, node="root") -> foo
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
## Set up model	#
	conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
		initialR=initialR, initialE=initialE);#
	sp <- conf$sp;#
	model <- conf$model;#
	fixPar <- conf$fixPar;#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar, nTrees=summ$nTrees);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$model[aff[1]] <- fit1$model;#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		z <- results$z;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	if (x$nTrees > 1)#
	{#
		cat("\nResults from the analysis of", x$nTrees, " phylogenetic trees.\n", sep="");#
	}#
	#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
foo
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
## Set up model	#
	conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
		initialR=initialR, initialE=initialE);#
	sp <- conf$sp;#
	model <- conf$model;#
	fixPar <- conf$fixPar;#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar, nTrees=summ$nTrees);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$model[aff[1]] <- fit1$model;#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		z <- results$z;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	if (x$nTrees > 1)#
	{#
		cat("\nResults from the analysis of ", x$nTrees, " phylogenetic trees.\n", sep="");#
	}#
	#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
foo
fitSisters(x[[1]], node="root") -> foo
foo
print.sisterFit <- function(x, ...)#
{#
	if (x$nTrees > 1) {cat("\nResults from the analysis of ", x$nTrees, " phylogenetic trees.\n", sep="");}#
	#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	if (x$nTrees == 1) {cat("\n95% confidence intervals calculated from profile likelihoods\n");}#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
foo
print.sisterFit <- function(x, ...)#
{#
	if (x$nTrees > 1) {cat("\nResults from the analysis of ", x$nTrees, " phylogenetic trees.\n", sep="");}#
	#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	if (x$nTrees == 1) {cat("\n95% confidence intervals calculated from profile likelihoods.\n");}#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
foo
fitSisters(x[[1]], node="root", model="bd") -> foo
foo
fitSisters(x, node="root", model="bd") -> foo
foo
res
results
x
phy <- x
richness=NULL
node="root"
initialR=0.05
initialE=0.5
verbose=TRUE
	conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
		initialR=initialR, initialE=initialE);#
	sp <- conf$sp;#
	model <- conf$model;#
	fixPar <- conf$fixPar;
epsilon=NULL
r=NULL
model <- "bd"
	conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
		initialR=initialR, initialE=initialE);#
	sp <- conf$sp;#
	model <- conf$model;#
	fixPar <- conf$fixPar;
b=NULL
d=NULL
criterion="aicc"
	conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
		initialR=initialR, initialE=initialE);#
	sp <- conf$sp;#
	model <- conf$model;#
	fixPar <- conf$fixPar;
		res <- lapply(phy, runFitSisters, richness);
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}
		res <- lapply(phy, runFitSisters, richness);
tips=NULL
		res <- lapply(phy, runFitSisters, richness);
mc=FALSE
numCores=NULL
		res <- lapply(phy, runFitSisters, richness);
res
results <- res
length(res)
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		#
		if (all(is.na(summPar[c(2,4,6),2:5]))) # yule; forget epsilon#
		{#
			summPar <- summPar[c(1,3,5),];#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		} else {#
			cladeNames <- rep(cladeNames, each=2);#
			parameterSummary <- cbind(Clade=cladeNames, summPar);#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}
		summary <- summarizeMultipleTrees();
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);
summBasePar
p <- basePar
p
	p1 <- c(Mean=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));
p1
	p1 <- c(Mean.r=mean(p[,1]), Min.r=min(p[,1]), Max.r=max(p[,1]), St.Dev.r=sd(p[,1]));#
	p2 <- c(Mean.eps=mean(p[,2]), Min.eps=min(p[,2]), Max.eps=max(p[,2]), St.Dev.eps.=sd(p[,2]));
p1
c(p1,p2)
as.data.frame(c(p1,p2))
as.data.frame(p1,p2)
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean.r=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean.eps=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- as.data.frame(rbind(p1, p2));#
	parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}
	p1 <- c(Mean.r=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));
	p2 <- c(Mean.eps=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));
p1
p2
	summ <- c(p1, p2);
summ
	summ <- as.data.frame(summ);
summ
?as.data.frame
	summ <- data.frame(summ);
summ
	summ <- cbind(p1, p2);
summ
	p1 <- c(Mean.r=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean.eps=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	summ <- c(p1, p2);
summ
class(summ)
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean.r=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean.eps=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- c(p1, p2);#
	# summ <- data.frame(summ);#
	#
	# parSummary <- as.data.frame(rbind(p1, p2));#
	# parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	# rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);
summClade2Par
summClade1Par
summBasePar
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);
summPar
class(summPar)
		summPar <- as.data.frame(summPar);
summPar
class(summPar)
		summPar <- cbind(Clade=cladeNames, summPar);
summPar
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		summPar <- as.data.frame(summPar); rownames(summPar) <- NULL;#
		summPar <- cbind(Clade=cladeNames, summPar);
summPar
summPar[,Mean.eps]
summPar[,"Mean.eps"]
summPar[,c(1:5)];
?as.data.frame
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);
as.data.frame(summPar);
as.data.frame(summPar, row.names=NULL);
data.frame(summPar)
data.frame(summPar, row.namnes=NULL)
data.frame(summPar, row.names=NULL)
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		summPar <- data.frame(summPar, row.names=NULL);#
		summPar <- cbind(Clade=cladeNames, summPar);
summPar
summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);
summPar
as.data.frame(summPar)
		summPar <- as.data.frame(summPar); rownames(summPar) <- NULL;
summPar
		summPar <- cbind(Clade=cladeNames, summPar);
summPar
fitSisters(x[[1]], node="root") -> foo
fitSisters(x, node="root") -> foo
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
## Set up model	#
	conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
		initialR=initialR, initialE=initialE);#
	sp <- conf$sp;#
	model <- conf$model;#
	fixPar <- conf$fixPar;#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar, nTrees=summ$nTrees);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$model[aff[1]] <- fit1$model;#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		z <- results$z;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		summPar <- as.data.frame(summPar); rownames(summPar) <- NULL;#
		summPar <- cbind(Clade=cladeNames, summPar);#
		#
		if (all(is.na(summPar[,"Mean.eps"]))) # yule; forget epsilon#
		{#
			summPar <- summPar[,c(1:5)];#
			parameterSummary <- summPar[,c(1:5)];#
		} else {#
			parameterSummary <- summPar;#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean.r=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), St.Dev.=sd(p[,1]));#
	p2 <- c(Mean.eps=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), St.Dev.=sd(p[,2]));#
	#
	parSummary <- c(p1, p2);#
	# summ <- data.frame(summ);#
	#
	# parSummary <- as.data.frame(rbind(p1, p2));#
	# parSummary <- cbind(Par=c("r", "epsilon"), parSummary);#
	#
	# rownames(parSummary) <- NULL;#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	if (x$nTrees > 1) {cat("\nResults from the analysis of ", x$nTrees, " phylogenetic trees.\n", sep="");}#
	#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	if (x$nTrees == 1) {cat("\n95% confidence intervals calculated from profile likelihoods.\n");}#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(x, node="root") -> foo
fitSisters(x, node="root", model="bd") -> foo
fitSisters(x, node="root", epsilon=0.5) -> foo
foo
fitSisters(x, node="root", model="yule") -> foo
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	epsilon=NULL, r=NULL, b=NULL, d=NULL, criterion="aicc", plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
## Set up model	#
	conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d, constraint=constraint,#
		initialR=initialR, initialE=initialE);#
	sp <- conf$sp;#
	model <- conf$model;#
	fixPar <- conf$fixPar;#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## First, use richness information to prune tree. Could be several trees. Just use one for now.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		res <- lapply(phy, runFitSisters, richness);#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar, nTrees=summ$nTrees);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$model[aff[1]] <- fit1$model;#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		z <- results$z;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		summPar <- as.data.frame(summPar); rownames(summPar) <- NULL;#
		summPar <- cbind(Clade=cladeNames, summPar);#
		#
		if (all(is.na(summPar[,"Mean.eps"]))) # yule; forget epsilon#
		{#
			summPar <- summPar[,c(1:5)];#
			parameterSummary <- summPar[,c(1:5)];#
		} else {#
			parameterSummary <- summPar;#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean.r=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), StDev=sd(p[,1]));#
	p2 <- c(Mean.eps=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), StDev=sd(p[,2]));#
	#
	parSummary <- c(p1, p2);#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	if (x$nTrees > 1) {cat("\nResults from the analysis of ", x$nTrees, " phylogenetic trees.\n", sep="");}#
	#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	if (x$nTrees == 1) {cat("\n95% confidence intervals calculated from profile likelihoods.\n");}#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(x, node="root", model="yule") -> foo
fitSisters(x, node="root", model="bd") -> foo
phy
phy[[1]]
phy[[1]][1]
ls()
foo
ls()
foo
help(multicore)
require(multicore)
help(multicore)
?multicore
phy
fitSisters(x[[1]]) -> foo
fitSisters(x[[1]], node="root") -> foo
fitSisters(x, node="root") -> foo
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);
phy
x <- phy
phy <- phy[[1]]
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);
## Function to prune tree using 'richness' information, assumed to have minimally two columns, "taxon" and "n.taxa"#
##   Perhaps relax on these column names, may cause too many problems#
## May also include 'exemplar' column; in that case, rename relevant tip.label before pruning.#
prepareData <- function (phy, richness, verbose)#
{#
	if (is.null(richness)) { # Assume tree represents single species tips and is completely sampled#
		richness <- data.frame(taxon=phy$tip.label, n.taxa=1);#
	}#
# Rename exemplar taxa with taxon name in richness file#
	if (!is.null(richness$exemplar))#
	{#
# Change relevant tip.labels in phy; individual 'exemplar' may be NA, use original tip.label.#
# Ordering in richness file should NOT be assumed to match order of tip.labels#
		i.na <- is.na(richness$exemplar);#
		phy$tip.label[match(richness$exemplar[!i.na], phy$tip.label)] <- as.character(richness$taxon[!i.na]);#
	}#
	#
# make sure things are in the correct order and of correct format#
	if (length(richness[1,]) == 2)#
	{#
		if (colnames(richness)[1] != "taxon" || colnames(richness)[2] != "n.taxa")#
		{#
			if (class(richness[,1]) == "factor" & class(richness[,2]) == "integer")#
			{#
				colnames(richness) = c("taxon", "n.taxa");#
			} else if (class(richness[,1]) == "integer" & class(richness[,2]) == "factor")#
			{#
				colnames(richness) = c("n.taxa", "taxon");#
			} else {#
				cat("MEDUSA thinks your richness data is in an incorrect format. See ?MEDUSA.\n")#
				stop;#
			}#
		}#
	}#
	#
	if (class(phy) != "phylo") {cat("\n\nWARNING: tree is not of class \"phylo\". Stopping.\n"); stop;}#
	#
# Prune tree down to lineages with assigned richnesses#
	temp <- richness[, "n.taxa"];#
	names(temp) <- richness[, "taxon"];#
	pruned <- treedata(phy, temp, warnings=verbose)  # geiger function calling ape (namecheck)#
	#
# checking for typos#
	if (length(pruned$phy$tip.label) == 0) {#
		cat("\n\nWARNING: MEDUSA encountered a serious error. Tree has no tips after processing richness information! \nIt is likely that an incorrect richness file is being used. \nAnalysis cannot proceed. Please examine the information below to identify the error.\\nn");#
		cat("\nTree tip labels:\n");#
		print(phy$tip.label);#
		cat("\nRichness taxon labels:\n");#
		print(as.character(richness[, "taxon"]));#
		stop;#
	} else if (length(phy$tip.label) != length(pruned$phy$tip.label)) {#
		cat("MEDUSA thinks there is a typo in either the tree or richness files, as one or more tips were dropped from the tree.\n");#
		stop;#
	}#
#
	phy <- pruned$phy;#
# Check the tree#
	#	plotNN(phy)					# Node numbers (ape-style) plotted#
	#
	return(list(phy=phy, richness=richness));#
}#
#
# Determine desired model from passed in fixed parameters (if present)#
configureModel <- function (model, epsilon, r, b, d, initialR, initialE)#
{#
	sp <- NULL;#
	fixPar <- NULL;#
	if (!is.null(epsilon)) # user-defined epsilon#
	{#
		if (epsilon <= 0 | epsilon >= 1) {cat("\n\nWARNING: value of epsilon (", epsilon, ") is invalid; must be > 0 and < 1. Stopping analysis.\n", sep=""); stop;}#
		sp <- c(initialR, epsilon);#
		fixPar <- epsilon;#
		model <- "fixedEpsilon";#
	} else if (!is.null(r)) # user-defined net diversification rate#
	{#
		if (r <= 0) {cat("\n\nWARNING: value of r (", r, ") is invalid; must be > 0. Stopping analysis.\n", sep=""); stop;}#
		sp <- c(r, initialE);#
		fixPar <- r;#
		model <- "fixedR";#
	} else if (!is.null(d)) # user-defined extiction rate#
	{#
		if (d <= 0) {cat("\n\nWARNING: value of d (", d, ") is invalid; must be > 0. Stopping analysis.\n", sep=""); stop;}#
		sp <- c(initialR, d);#
		fixPar <- d;#
		model <- "fixedD";#
	} else if (!is.null(b)) # user-defined speciation rate#
	{#
		if (b <= 0) {cat("\n\nWARNING: value of b (", b, ") is invalid; must be > 0. Stopping analysis.\n", sep=""); stop;}#
		sp <- c((b/2), initialE);#
		fixPar <- b;#
		model <- "fixedB";#
	} else {#
		sp <- c(initialR, initialE);#
	}#
	return(list(model=model, sp=sp, fixPar=fixPar))#
}#
#
#
## Original default was to fit 20 models (or less if the tree was small).#
## Changing to a stop-criterion (stop="modelLimit") e.g. when k = n-1 (i.e. when denominator of aicc correction is undefined).#
## k <- (3*i-1) # when both birth and death are estimated, where i is the number of piecewise models#
  ## This occurs when i = n/3#
  ## If Yule, max i = n/2#
## n <- (2*num.taxa - 1) == (2*length(richness[,1]) - 1) # i.e. total number of nodes in tree (internal + pendant)#
## Alternatively use aicc threshold itself as a stopping criterion (stop="threshold").#
# AICc = AIC + 2*k*(k+1)/(n-k-1);#
getMaxModelLimit <- function (richness, modelLimit, model, stop)#
{#
	samp.size <- (2*length(richness[,1]) - 1)#
	if (model == "bd" || model == "mixed")#
	{#
		max.modelLimit <- as.integer(samp.size/3) - ((!(samp.size %% 3)) * 1);#
	} else {#
		max.modelLimit <- as.integer(samp.size/2) - ((!(samp.size %% 2)) * 1); # models estimating only one diversification parameter#
	}#
	#
	if (stop == "modelLimit")#
	{#
		if (modelLimit > max.modelLimit) {modelLimit <- max.modelLimit;}#
		cat("Limiting consideration to ", modelLimit, " piecewise", sep="");#
		if (model == "bd") {#
			cat(" birth-death models")#
		} else if (model == "mixed") {#
			cat(" mixed models")#
		} else if (model == "yule") {#
			cat(" pure-birth (Yule) models");#
		} else {#
			cat(" diversification models")#
		}#
		cat(".\n\n");#
	}#
	#
	return(modelLimit);#
}#
#
#
## Fitted curve from random b-d simulations#
## Value corresponds to 95th percentile of AICc(split) - AICc(no-split) for no-split simulations#
## x-shifted power function#
getThreshold <- function (treeSize, fixThreshold, stop)#
{#
	a = -3.5941052380332650E+01;#
	b =  6.7372587299747000E+00;#
	c = -1.0061508340754866E-01;#
	Offset =  2.7516678664333408E+01;#
	threshold <- a * (treeSize-b)^c + Offset;#
	if (threshold < 0 || is.nan(threshold)) threshold <- 0;#
	#
	if (!is.null(fixThreshold))#
	{#
		if (is.nan(fixThreshold) || class(fixThreshold) != "numeric" || fixThreshold < 0)#
		{#
			cat("Provided threshold value of '", fixThreshold, "' is invalid.\n", sep="")#
			cat("Will proceed with value determined from simulations.\n")#
			cat("Appropriate AICc threshold for tree of ", treeSize, " tips is: ", threshold, ".\n", sep="");#
			return(threshold);#
		} else {#
			cat("Using provided threshold value of ", fixThreshold, ".\n", sep="")#
			cat("From simulations, appropriate AICc threshold for tree of ", treeSize, " tips would be: ", threshold, ".\n", sep="");#
			return(fixThreshold);#
		}#
	} else {#
		if (stop == "threshold") {#
			cat("Using AIC-threshold as analysis-terminating criterion.\n");#
			cat("Appropriate threshold for tree of ", treeSize, " tips is: ", threshold, ".\n\n", sep="");#
		}#
		return(threshold);#
	}#
}#
#
#
## The makeCacheMedusa function is like the first half of the original splitEdgeMatrix().#
## It works through and reorders the edges, then works out start and end times of these#
## based on the phylogeny's branching times.#
###
## In addition, every node's descendants are also calculated.  The element 'desc' is a list.#
## $desc[i] contains the indices within $edge, $t.start, etc., of all descendants of node 'i'#
## (in ape node numbering format).#
makeCacheMedusa <- function (phy, richness, all.nodes, shiftCut, mc, numCores, verbose=TRUE)#
{#
	n.tips <- length(phy$tip.label);#
	n.int <- nrow(phy$edge) - n.tips;#
	#
## Ape numbers the tips first#
	i.int <- seq_len(n.int);#
	interior <- phy$edge[,2] %in% phy$edge[,1];#
	bt <- branching.times(phy);#
	#
# Consider only internal edges first#
	edges.int <- phy$edge[interior,];#
	colnames(edges.int) <- c("anc", "dec");#
	#
	t.0 <- bt[match(edges.int[,1], (n.tips+1):max(edges.int))];#
	t.1 <- c(t.0[i.int] - phy$edge.length[interior]);#
	#
	z.internal <- cbind(edges.int, t.0, t.1, t.len=t.0 - t.1,#
		n.0=rep(1, n.int), n.t=rep(NA, n.int));#
	#
# Now, pendant edges; #
	edges.pendant <- phy$edge[match(seq_len(n.tips), phy$edge[,2]),];#
	colnames(edges.pendant) <- c("anc", "dec");#
	#
	t.0 <- bt[match(edges.pendant[,1], (n.tips+1):max(edges.pendant))];#
	t.1 <- rep(0, n.tips);#
# cannot assume richness ordering necessarily matches that of tip labels#
	ext.richness <- richness$n.taxa[match(phy$tip.label, richness$taxon)];#
	#
	z.pendant <- cbind(edges.pendant, t.0, t.1, t.len=t.0 - t.1,#
		n.0=rep(1, n.tips), n.t=ext.richness);#
	#
	z <- rbind(z.internal, z.pendant);#
	z <- cbind(z,partition=rep(1, length(z[,1]))); # Stores piecewise model structure#
	rownames(z) <- NULL;#
	#
# Used for identifying descendant nodes below i.e. tracking breakpoints#
	all.edges <- as.matrix(z[,c("anc","dec")]);#
	desc.stem <- list();#
	desc.node <- list();#
	#
	if (verbose) cat("  Gathering descendant node information...");#
	if (mc)#
	{#
		if (shiftCut == "both" || shiftCut == "stem")#
		{#
			desc.stem <- mclapply(seq_len(max(all.edges)), descendantsCutAtStem.idx, all.edges=all.edges, mc.cores=numCores);#
		}#
		if (shiftCut == "both" || shiftCut == "node")#
		{#
			if (!is.null(desc.stem))#
			{#
				root <- min(z[,"anc"]);#
				desc.node <- mclapply(desc.stem, stripStem, mc.cores=numCores);#
				desc.node[root] <- desc.stem[root];#
			} else {#
				desc.node <- mclapply(seq_len(max(all.edges)), descendantsCutAtNode.idx, all.edges=all.edges, mc.cores=numCores);#
			}#
		}#
	} else {#
		if (shiftCut == "both" || shiftCut == "stem")#
		{#
			desc.stem <- lapply(seq_len(max(all.edges)), descendantsCutAtStem.idx, all.edges=all.edges);#
		}#
		if (shiftCut == "both" || shiftCut == "node")#
		{#
			if (!is.null(desc.stem))#
			{#
				root <- min(z[,"anc"]);#
				desc.node <- lapply(desc.stem, stripStem);#
				desc.node[root] <- desc.stem[root];#
			} else {#
				desc.node <- lapply(seq_len(max(all.edges)), descendantsCutAtNode.idx, all.edges=all.edges);#
			}#
		}#
	}#
	if (verbose) cat(" done.\n");#
	#
## Needed downstream; don't recalculate#
 ## Gives the number of tips associated with an internal node; determines whether a node is 'virgin' or not#
	num.tips <- list()#
	if (verbose) cat("  Gathering tip richness information...");#
	if (mc)#
	{#
		num.tips <- mclapply(all.nodes, getNumTips, phy=phy, totalTips=n.tips, mc.cores=numCores);#
	} else {#
		num.tips <- lapply(all.nodes, getNumTips, phy=phy, totalTips=n.tips);#
	}#
	if (verbose) cat(" done.\n");#
	#
	res <- list(z=z, desc.stem=desc.stem, desc.node=desc.node, num.tips=num.tips);#
	return(res);#
}#
#
#
## Get the number of tips descended from internal node 'node'.#
## Needed for determining whether nodes are virgin nodes.#
## Uses code from geiger functions 'node.sons' and 'node.leaves'.#
getNumTips <- function (node, phy, totalTips=NULL)#
{#
	if (is.null(totalTips)) totalTips <- length(phy$tip.label);#
	if (node <= totalTips) return(1);#
	#
	n <- 0;#
	d <- phy$edge[which(phy$edge[, 1] == node), 2];#
	for (j in d) {#
		if (j <= totalTips)#
			n <- n + 1#
		else n <- n + getNumTips(j, phy, totalTips)#
	}#
	return(n);#
}#
#
#
#
#
#
# *** MAYBE RECODE descendantsCutAtStem IN C++ AS IT IS SLOW FOR LARGE TREES ***#
#
## This generates the indices of all descendants of a node, using ape's edge matrix.#
## Deals with row numbers of the edge matrix rather than node numbers of the tree.#
descendantsCutAtStem <- function (node, all.edges)#
{#
	ans <- numeric();#
	ans <- node;#
	repeat {#
		node <- all.edges[all.edges[,1] %in% node,2];#
		if (length(node) > 0)#
		{#
			ans <- c(ans, node);#
		} else {break;}#
	}#
	return(ans);#
}#
#
#
## The function 'descendants' returns the indices of all descendants within the edge matrix.#
descendantsCutAtStem.idx <- function (node.list, all.edges)#
{#
	which(all.edges[,1] == node.list | all.edges[,2] %in% descendantsCutAtStem(node.list, all.edges));#
}#
#
#
# Remove stem node from previously calculated set of descendants; about a billion times faster than descendantsCutAtNode#
stripStem <- function (x)#
{#
	y <- unlist(x);#
	return(y[-1]);#
}#
#
#
## This generates the indices of all descendants of a node, using ape's edge matrix.#
## Deals with row numbers of the edge matrix rather than node numbers of the tree.#
descendantsCutAtNode <- function (node, all.edges)#
{#
	ans <- numeric();#
	repeat {#
		node <- all.edges[all.edges[,1] %in% node,2];#
		if (length(node) > 0)#
		{#
			ans <- c(ans, node);#
		} else {break;}#
	}#
	return(ans);#
}#
#
#
## The function 'descendants' returns the indices of all descendants within the edge matrix.#
descendantsCutAtNode.idx <- function (node.list, all.edges)#
{#
	which(all.edges[,1] == node.list | all.edges[,2] %in% descendantsCutAtNode(node.list, all.edges));#
}#
#
#
## Check that provided arguments are valid#
checkValidArguments <- function (phy, richness, model, modelLimit, stop, shiftCut, criterion, stepBack,#
	preserveModelFlavour, epsilon, r, b, d, fixThreshold, initialR, initialE,#
	verbose, mc, numCores)#
{#
	if (class(phy) != "phylo" && class(phy) != "multiPhylo") {cat("\n\nWARNING: tree is not of class \"phylo\". Stopping.\n"); stop;}#
	#
## String arguments#
	model=match.arg(model, choices=c("mixed", "bd", "yule"));#
	stop=match.arg(stop, choices=c("threshold","modelLimit"));#
	shiftCut=match.arg(shiftCut, choices=c("both", "stem", "node"));#
	criterion=match.arg(criterion, choices=c("aicc", "aic"));#
	#
## Boolean arguments#
	if (class(stepBack) != "logical") {cat("\n\nWARNING: argument \"stepBack\"is not of class \"logical\". Stopping.\n"); stop;}#
	if (class(preserveModelFlavour) != "logical") {cat("\n\nWARNING: argument \"preserveModelFlavour\"is not of class \"logical\". Stopping.\n"); stop;}#
	if (class(verbose) != "logical") {cat("\n\nWARNING: argument \"verbose\"is not of class \"logical\". Stopping.\n"); stop;}#
	if (class(mc) != "logical") {cat("\n\nWARNING: argument \"mc\"is not of class \"logical\". Stopping.\n"); stop;}#
	#
## Numeric arguments#
	if (class(modelLimit) != "numeric" && class(modelLimit) != "NULL") {cat("\n\nWARNING: argument \"modelLimit\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(epsilon) != "numeric" && class(epsilon) != "NULL") {cat("\n\nWARNING: argument \"epsilon\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(r) != "numeric" && class(r) != "NULL") {cat("\n\nWARNING: argument \"r\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(b) != "numeric" && class(b) != "NULL") {cat("\n\nWARNING: argument \"b\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(d) != "numeric" && class(d) != "NULL") {cat("\n\nWARNING: argument \"d\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(fixThreshold) != "numeric" && class(fixThreshold) != "NULL") {cat("\n\nWARNING: argument \"fixThreshold\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(initialR) != "numeric" && class(initialR) != "NULL") {cat("\n\nWARNING: argument \"initialR\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(initialE) != "numeric" && class(initialE) != "NULL") {cat("\n\nWARNING: argument \"initialE\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(numCores) != "numeric" && class(numCores) != "NULL") {cat("\n\nWARNING: argument \"numCores\"is invalid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
}
fitSisters(x, node="root") -> foo
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	criterion="aicc", epsilon=NULL, r=NULL, b=NULL, d=NULL, plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
## Set up model	#
	conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d,#
		initialR=initialR, initialE=initialE);#
	sp <- conf$sp;#
	model <- conf$model;#
	fixPar <- conf$fixPar;#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## Use richness information to prune tree. Could be several trees.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		if (mc)#
		{#
			res <- mclapply(phy, runFitSisters, richness);#
		} else {#
			res <- lapply(phy, runFitSisters, richness);#
		}#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar, nTrees=summ$nTrees);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$model[aff[1]] <- fit1$model;#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		z <- results$z;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		summPar <- as.data.frame(summPar); rownames(summPar) <- NULL;#
		summPar <- cbind(Clade=cladeNames, summPar);#
		#
		if (all(is.na(summPar[,"Mean.eps"]))) # yule; forget epsilon#
		{#
			summPar <- summPar[,c(1:5)];#
			parameterSummary <- summPar[,c(1:5)];#
		} else {#
			parameterSummary <- summPar;#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean.r=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), StDev=sd(p[,1]));#
	p2 <- c(Mean.eps=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), StDev=sd(p[,2]));#
	#
	parSummary <- c(p1, p2);#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	if (x$nTrees > 1) {cat("\nResults from the analysis of ", x$nTrees, " phylogenetic trees.\n", sep="");}#
	#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	if (x$nTrees == 1) {cat("\n95% confidence intervals calculated from profile likelihoods.\n");}#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(x, node="root") -> foo
fitSisters(x, node="root", verbose=FALSE) -> foo
## Function to prune tree using 'richness' information, assumed to have minimally two columns, "taxon" and "n.taxa"#
##   Perhaps relax on these column names, may cause too many problems#
## May also include 'exemplar' column; in that case, rename relevant tip.label before pruning.#
prepareData <- function (phy, richness, verbose)#
{#
	if (is.null(richness)) { # Assume tree represents single species tips and is completely sampled#
		richness <- data.frame(taxon=phy$tip.label, n.taxa=1);#
	}#
# Rename exemplar taxa with taxon name in richness file#
	if (!is.null(richness$exemplar))#
	{#
# Change relevant tip.labels in phy; individual 'exemplar' may be NA, use original tip.label.#
# Ordering in richness file should NOT be assumed to match order of tip.labels#
		i.na <- is.na(richness$exemplar);#
		phy$tip.label[match(richness$exemplar[!i.na], phy$tip.label)] <- as.character(richness$taxon[!i.na]);#
	}#
	#
# make sure things are in the correct order and of correct format#
	if (length(richness[1,]) == 2)#
	{#
		if (colnames(richness)[1] != "taxon" || colnames(richness)[2] != "n.taxa")#
		{#
			if (class(richness[,1]) == "factor" & class(richness[,2]) == "integer")#
			{#
				colnames(richness) = c("taxon", "n.taxa");#
			} else if (class(richness[,1]) == "integer" & class(richness[,2]) == "factor")#
			{#
				colnames(richness) = c("n.taxa", "taxon");#
			} else {#
				cat("MEDUSA thinks your richness data is in an incorrect format. See ?MEDUSA.\n")#
				stop;#
			}#
		}#
	}#
	#
	if (class(phy) != "phylo") {cat("\n\nWARNING: tree is not of class \"phylo\". Stopping.\n"); stop;}#
	#
# Prune tree down to lineages with assigned richnesses#
	temp <- richness[, "n.taxa"];#
	names(temp) <- richness[, "taxon"];#
	pruned <- treedata(phy, temp, warnings=verbose)  # geiger function calling ape (namecheck)#
	#
# checking for typos#
	if (length(pruned$phy$tip.label) == 0) {#
		cat("\n\nWARNING: MEDUSA encountered a serious error. Tree has no tips after processing richness information! \nIt is likely that an incorrect richness file is being used. \nAnalysis cannot proceed. Please examine the information below to identify the error.\\nn");#
		cat("\nTree tip labels:\n");#
		print(phy$tip.label);#
		cat("\nRichness taxon labels:\n");#
		print(as.character(richness[, "taxon"]));#
		stop;#
	} else if (length(phy$tip.label) != length(pruned$phy$tip.label)) {#
		cat("MEDUSA thinks there is a typo in either the tree or richness files, as one or more tips were dropped from the tree.\n");#
		stop;#
	}#
#
	phy <- pruned$phy;#
# Check the tree#
	#	plotNN(phy)					# Node numbers (ape-style) plotted#
	#
	return(list(phy=phy, richness=richness));#
}#
#
# Determine desired model from passed in fixed parameters (if present)#
configureModel <- function (model, epsilon, r, b, d, initialR, initialE)#
{#
	sp <- NULL;#
	fixPar <- NULL;#
	if (!is.null(epsilon)) # user-defined epsilon#
	{#
		if (epsilon <= 0 | epsilon >= 1) {cat("\n\nWARNING: value of epsilon (", epsilon, ") is invalid; must be > 0 and < 1. Stopping analysis.\n", sep=""); stop;}#
		sp <- c(initialR, epsilon);#
		fixPar <- epsilon;#
		model <- "fixedEpsilon";#
	} else if (!is.null(r)) # user-defined net diversification rate#
	{#
		if (r <= 0) {cat("\n\nWARNING: value of r (", r, ") is invalid; must be > 0. Stopping analysis.\n", sep=""); stop;}#
		sp <- c(r, initialE);#
		fixPar <- r;#
		model <- "fixedR";#
	} else if (!is.null(d)) # user-defined extiction rate#
	{#
		if (d <= 0) {cat("\n\nWARNING: value of d (", d, ") is invalid; must be > 0. Stopping analysis.\n", sep=""); stop;}#
		sp <- c(initialR, d);#
		fixPar <- d;#
		model <- "fixedD";#
	} else if (!is.null(b)) # user-defined speciation rate#
	{#
		if (b <= 0) {cat("\n\nWARNING: value of b (", b, ") is invalid; must be > 0. Stopping analysis.\n", sep=""); stop;}#
		sp <- c((b/2), initialE);#
		fixPar <- b;#
		model <- "fixedB";#
	} else {#
		sp <- c(initialR, initialE);#
	}#
	return(list(model=model, sp=sp, fixPar=fixPar))#
}#
#
#
## Original default was to fit 20 models (or less if the tree was small).#
## Changing to a stop-criterion (stop="modelLimit") e.g. when k = n-1 (i.e. when denominator of aicc correction is undefined).#
## k <- (3*i-1) # when both birth and death are estimated, where i is the number of piecewise models#
  ## This occurs when i = n/3#
  ## If Yule, max i = n/2#
## n <- (2*num.taxa - 1) == (2*length(richness[,1]) - 1) # i.e. total number of nodes in tree (internal + pendant)#
## Alternatively use aicc threshold itself as a stopping criterion (stop="threshold").#
# AICc = AIC + 2*k*(k+1)/(n-k-1);#
getMaxModelLimit <- function (richness, modelLimit, model, stop)#
{#
	samp.size <- (2*length(richness[,1]) - 1)#
	if (model == "bd" || model == "mixed")#
	{#
		max.modelLimit <- as.integer(samp.size/3) - ((!(samp.size %% 3)) * 1);#
	} else {#
		max.modelLimit <- as.integer(samp.size/2) - ((!(samp.size %% 2)) * 1); # models estimating only one diversification parameter#
	}#
	#
	if (stop == "modelLimit")#
	{#
		if (modelLimit > max.modelLimit) {modelLimit <- max.modelLimit;}#
		cat("Limiting consideration to ", modelLimit, " piecewise", sep="");#
		if (model == "bd") {#
			cat(" birth-death models")#
		} else if (model == "mixed") {#
			cat(" mixed models")#
		} else if (model == "yule") {#
			cat(" pure-birth (Yule) models");#
		} else {#
			cat(" diversification models")#
		}#
		cat(".\n\n");#
	}#
	#
	return(modelLimit);#
}#
#
#
## Fitted curve from random b-d simulations#
## Value corresponds to 95th percentile of AICc(split) - AICc(no-split) for no-split simulations#
## x-shifted power function#
getThreshold <- function (treeSize, fixThreshold, stop)#
{#
	a = -3.5941052380332650E+01;#
	b =  6.7372587299747000E+00;#
	c = -1.0061508340754866E-01;#
	Offset =  2.7516678664333408E+01;#
	threshold <- a * (treeSize-b)^c + Offset;#
	if (threshold < 0 || is.nan(threshold)) threshold <- 0;#
	#
	if (!is.null(fixThreshold))#
	{#
		if (is.nan(fixThreshold) || class(fixThreshold) != "numeric" || fixThreshold < 0)#
		{#
			cat("Provided threshold value of '", fixThreshold, "' is invalid.\n", sep="")#
			cat("Will proceed with value determined from simulations.\n")#
			cat("Appropriate AICc threshold for tree of ", treeSize, " tips is: ", threshold, ".\n", sep="");#
			return(threshold);#
		} else {#
			cat("Using provided threshold value of ", fixThreshold, ".\n", sep="")#
			cat("From simulations, appropriate AICc threshold for tree of ", treeSize, " tips would be: ", threshold, ".\n", sep="");#
			return(fixThreshold);#
		}#
	} else {#
		if (stop == "threshold") {#
			cat("Using AIC-threshold as analysis-terminating criterion.\n");#
			cat("Appropriate threshold for tree of ", treeSize, " tips is: ", threshold, ".\n\n", sep="");#
		}#
		return(threshold);#
	}#
}#
#
#
## The makeCacheMedusa function is like the first half of the original splitEdgeMatrix().#
## It works through and reorders the edges, then works out start and end times of these#
## based on the phylogeny's branching times.#
###
## In addition, every node's descendants are also calculated.  The element 'desc' is a list.#
## $desc[i] contains the indices within $edge, $t.start, etc., of all descendants of node 'i'#
## (in ape node numbering format).#
makeCacheMedusa <- function (phy, richness, all.nodes, shiftCut, mc, numCores, verbose=TRUE)#
{#
	n.tips <- length(phy$tip.label);#
	n.int <- nrow(phy$edge) - n.tips;#
	#
## Ape numbers the tips first#
	i.int <- seq_len(n.int);#
	interior <- phy$edge[,2] %in% phy$edge[,1];#
	bt <- branching.times(phy);#
	#
# Consider only internal edges first#
	edges.int <- phy$edge[interior,];#
	colnames(edges.int) <- c("anc", "dec");#
	#
	t.0 <- bt[match(edges.int[,1], (n.tips+1):max(edges.int))];#
	t.1 <- c(t.0[i.int] - phy$edge.length[interior]);#
	#
	z.internal <- cbind(edges.int, t.0, t.1, t.len=t.0 - t.1,#
		n.0=rep(1, n.int), n.t=rep(NA, n.int));#
	#
# Now, pendant edges; #
	edges.pendant <- phy$edge[match(seq_len(n.tips), phy$edge[,2]),];#
	colnames(edges.pendant) <- c("anc", "dec");#
	#
	t.0 <- bt[match(edges.pendant[,1], (n.tips+1):max(edges.pendant))];#
	t.1 <- rep(0, n.tips);#
# cannot assume richness ordering necessarily matches that of tip labels#
	ext.richness <- richness$n.taxa[match(phy$tip.label, richness$taxon)];#
	#
	z.pendant <- cbind(edges.pendant, t.0, t.1, t.len=t.0 - t.1,#
		n.0=rep(1, n.tips), n.t=ext.richness);#
	#
	z <- rbind(z.internal, z.pendant);#
	z <- cbind(z,partition=rep(1, length(z[,1]))); # Stores piecewise model structure#
	rownames(z) <- NULL;#
	#
# Used for identifying descendant nodes below i.e. tracking breakpoints#
	all.edges <- as.matrix(z[,c("anc","dec")]);#
	desc.stem <- list();#
	desc.node <- list();#
	#
	if (verbose) cat("  Gathering descendant node information...");#
	if (mc)#
	{#
		if (shiftCut == "both" || shiftCut == "stem")#
		{#
			desc.stem <- mclapply(seq_len(max(all.edges)), descendantsCutAtStem.idx, all.edges=all.edges, mc.cores=numCores);#
		}#
		if (shiftCut == "both" || shiftCut == "node")#
		{#
			if (!is.null(desc.stem))#
			{#
				root <- min(z[,"anc"]);#
				desc.node <- mclapply(desc.stem, stripStem, mc.cores=numCores);#
				desc.node[root] <- desc.stem[root];#
			} else {#
				desc.node <- mclapply(seq_len(max(all.edges)), descendantsCutAtNode.idx, all.edges=all.edges, mc.cores=numCores);#
			}#
		}#
	} else {#
		if (shiftCut == "both" || shiftCut == "stem")#
		{#
			desc.stem <- lapply(seq_len(max(all.edges)), descendantsCutAtStem.idx, all.edges=all.edges);#
		}#
		if (shiftCut == "both" || shiftCut == "node")#
		{#
			if (!is.null(desc.stem))#
			{#
				root <- min(z[,"anc"]);#
				desc.node <- lapply(desc.stem, stripStem);#
				desc.node[root] <- desc.stem[root];#
			} else {#
				desc.node <- lapply(seq_len(max(all.edges)), descendantsCutAtNode.idx, all.edges=all.edges);#
			}#
		}#
	}#
	if (verbose) cat(" done.\n");#
	#
## Needed downstream; don't recalculate#
 ## Gives the number of tips associated with an internal node; determines whether a node is 'virgin' or not#
	num.tips <- list()#
	if (verbose) cat("  Gathering tip richness information...");#
	if (mc)#
	{#
		num.tips <- mclapply(all.nodes, getNumTips, phy=phy, totalTips=n.tips, mc.cores=numCores);#
	} else {#
		num.tips <- lapply(all.nodes, getNumTips, phy=phy, totalTips=n.tips);#
	}#
	if (verbose) cat(" done.\n");#
	#
	res <- list(z=z, desc.stem=desc.stem, desc.node=desc.node, num.tips=num.tips);#
	return(res);#
}#
#
#
## Get the number of tips descended from internal node 'node'.#
## Needed for determining whether nodes are virgin nodes.#
## Uses code from geiger functions 'node.sons' and 'node.leaves'.#
getNumTips <- function (node, phy, totalTips=NULL)#
{#
	if (is.null(totalTips)) totalTips <- length(phy$tip.label);#
	if (node <= totalTips) return(1);#
	#
	n <- 0;#
	d <- phy$edge[which(phy$edge[, 1] == node), 2];#
	for (j in d) {#
		if (j <= totalTips)#
			n <- n + 1#
		else n <- n + getNumTips(j, phy, totalTips)#
	}#
	return(n);#
}#
#
#
#
#
#
# *** MAYBE RECODE descendantsCutAtStem IN C++ AS IT IS SLOW FOR LARGE TREES ***#
#
## This generates the indices of all descendants of a node, using ape's edge matrix.#
## Deals with row numbers of the edge matrix rather than node numbers of the tree.#
descendantsCutAtStem <- function (node, all.edges)#
{#
	ans <- numeric();#
	ans <- node;#
	repeat {#
		node <- all.edges[all.edges[,1] %in% node,2];#
		if (length(node) > 0)#
		{#
			ans <- c(ans, node);#
		} else {break;}#
	}#
	return(ans);#
}#
#
#
## The function 'descendants' returns the indices of all descendants within the edge matrix.#
descendantsCutAtStem.idx <- function (node.list, all.edges)#
{#
	which(all.edges[,1] == node.list | all.edges[,2] %in% descendantsCutAtStem(node.list, all.edges));#
}#
#
#
# Remove stem node from previously calculated set of descendants; about a billion times faster than descendantsCutAtNode#
stripStem <- function (x)#
{#
	y <- unlist(x);#
	return(y[-1]);#
}#
#
#
## This generates the indices of all descendants of a node, using ape's edge matrix.#
## Deals with row numbers of the edge matrix rather than node numbers of the tree.#
descendantsCutAtNode <- function (node, all.edges)#
{#
	ans <- numeric();#
	repeat {#
		node <- all.edges[all.edges[,1] %in% node,2];#
		if (length(node) > 0)#
		{#
			ans <- c(ans, node);#
		} else {break;}#
	}#
	return(ans);#
}#
#
#
## The function 'descendants' returns the indices of all descendants within the edge matrix.#
descendantsCutAtNode.idx <- function (node.list, all.edges)#
{#
	which(all.edges[,1] == node.list | all.edges[,2] %in% descendantsCutAtNode(node.list, all.edges));#
}#
#
#
## Check that provided arguments are valid#
checkValidArguments <- function (phy, richness, model, modelLimit, stop, shiftCut, criterion, stepBack,#
	preserveModelFlavour, epsilon, r, b, d, fixThreshold, initialR, initialE,#
	verbose, mc, numCores)#
{#
	if (class(phy) != "phylo" && class(phy) != "multiPhylo") {cat("\n\nWARNING: tree is not of class \"phylo\". Stopping.\n"); stop;}#
	#
## String arguments#
	model=match.arg(model, choices=c("mixed", "bd", "yule"));#
	stop=match.arg(stop, choices=c("threshold","modelLimit"));#
	shiftCut=match.arg(shiftCut, choices=c("both", "stem", "node"));#
	criterion=match.arg(criterion, choices=c("aicc", "aic"));#
	#
## Boolean arguments#
	if (class(stepBack) != "logical") {cat("\n\nWARNING: argument \"stepBack\"is not of class \"logical\". Stopping.\n"); stop;}#
	if (class(preserveModelFlavour) != "logical") {cat("\n\nWARNING: argument \"preserveModelFlavour\"is not of class \"logical\". Stopping.\n"); stop;}#
	if (class(verbose) != "logical") {cat("\n\nWARNING: argument \"verbose\"is not of class \"logical\". Stopping.\n"); stop;}#
	if (class(mc) != "logical") {cat("\n\nWARNING: argument \"mc\"is not of class \"logical\". Stopping.\n"); stop;}#
	#
## Numeric arguments#
	if (class(modelLimit) != "numeric" && class(modelLimit) != "NULL") {cat("\n\nWARNING: argument \"modelLimit\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(epsilon) != "numeric" && class(epsilon) != "NULL") {cat("\n\nWARNING: argument \"epsilon\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(r) != "numeric" && class(r) != "NULL") {cat("\n\nWARNING: argument \"r\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(b) != "numeric" && class(b) != "NULL") {cat("\n\nWARNING: argument \"b\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(d) != "numeric" && class(d) != "NULL") {cat("\n\nWARNING: argument \"d\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(fixThreshold) != "numeric" && class(fixThreshold) != "NULL") {cat("\n\nWARNING: argument \"fixThreshold\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(initialR) != "numeric" && class(initialR) != "NULL") {cat("\n\nWARNING: argument \"initialR\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(initialE) != "numeric" && class(initialE) != "NULL") {cat("\n\nWARNING: argument \"initialE\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(numCores) != "numeric" && class(numCores) != "NULL") {cat("\n\nWARNING: argument \"numCores\"is invalid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
}
fitSisters(x, node="root", verbose=FALSE) -> foo
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	criterion="aicc", epsilon=NULL, r=NULL, b=NULL, d=NULL, plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
## Set up model	#
	conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d,#
		initialR=initialR, initialE=initialE);#
	sp <- conf$sp;#
	model <- conf$model;#
	fixPar <- conf$fixPar;#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## Use richness information to prune tree. Could be several trees.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores, verbose=verbose);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		if (mc)#
		{#
			res <- mclapply(phy, runFitSisters, richness);#
		} else {#
			res <- lapply(phy, runFitSisters, richness);#
		}#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar, nTrees=summ$nTrees);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$model[aff[1]] <- fit1$model;#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		z <- results$z;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		summPar <- as.data.frame(summPar); rownames(summPar) <- NULL;#
		summPar <- cbind(Clade=cladeNames, summPar);#
		#
		if (all(is.na(summPar[,"Mean.eps"]))) # yule; forget epsilon#
		{#
			summPar <- summPar[,c(1:5)];#
			parameterSummary <- summPar[,c(1:5)];#
		} else {#
			parameterSummary <- summPar;#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean.r=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), StDev=sd(p[,1]));#
	p2 <- c(Mean.eps=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), StDev=sd(p[,2]));#
	#
	parSummary <- c(p1, p2);#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	if (x$nTrees > 1) {cat("\nResults from the analysis of ", x$nTrees, " phylogenetic trees.\n", sep="");}#
	#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	if (x$nTrees == 1) {cat("\n95% confidence intervals calculated from profile likelihoods.\n");}#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(x, node="root", verbose=FALSE) -> foo
foo
fitSisters <- function (phy, richness=NULL, node=NULL, tips=NULL, model="mixed",#
	criterion="aicc", epsilon=NULL, r=NULL, b=NULL, d=NULL, plotSurface=FALSE,#
	initialR=0.05, initialE=0.5, verbose=TRUE, mc=FALSE, numCores=NULL, ...)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
## Set up model	#
	conf <- configureModel(model=model, epsilon=epsilon, r=r, b=b, d=d,#
		initialR=initialR, initialE=initialE);#
	sp <- conf$sp;#
	model <- conf$model;#
	fixPar <- conf$fixPar;#
	#
	runFitSisters <- function(phy, richness, ...)#
	{#
## Use richness information to prune tree. Could be several trees.#
		phyData <- extractSubTree(phy=phy, tips=tips, node=node, richness=richness, verbose=verbose);#
		phy <- phyData$phy;#
		richness <- phyData$richness;#
		#
## Identify nodes#
		pend.nodes <- seq_len(length(phy$tip.label));#
		int.nodes <- (length(phy$tip.label)+2):max(phy$edge); # Omit root node#
		root.node <- length(phy$tip.label) + 1;#
		all.nodes <- c(pend.nodes, root.node, int.nodes);#
		#
## The important bits. Set up z, get descendants and number of tips per node#
		obj <- makeCacheMedusa(phy=phy, richness=richness, all.nodes=all.nodes, shiftCut ="stem", mc=mc, numCores=numCores, verbose=verbose);#
		desc <- obj$desc.stem;#
		z <- obj$z;#
		#
## Get immediate descendant nodes of root. In case of multiple trees, make sure ordering is consistent.#
		sisNodes <- z[z[,"anc"] == root.node,"dec"];#
		#
		fit <- medusaMLFitBase(z=z, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
		models <- list(fit);#
		sisterModel <- sisterFit(node=sisNodes[1], z=z, desc=desc, fit=fit, model=model, fixPar=fixPar, criterion=criterion);#
		models <- c(models, sisterModel);#
		#
		return(list(models=models, phy=phy));#
	}#
	#
	if (class(phy) == "phylo")#
	{#
		res <- runFitSisters(phy, richness);#
	} else if (class(phy) == "multiPhylo") {#
		if (mc)#
		{#
			res <- mclapply(phy, runFitSisters, richness);#
		} else {#
			res <- lapply(phy, runFitSisters, richness);#
		}#
	}#
	#
## Summary#
	summ <- sisterFitSummary(results=res, criterion=criterion, fixPar=fixPar, plotSurface=plotSurface);#
	#
	results <- list(parameterSummary=summ$parSumm, modelSummary=summ$modSumm, models=res$models, fixPar=fixPar, nTrees=summ$nTrees);#
	class(results) <- "sisterFit";#
	#
	invisible(results);#
}#
#
## 'fit' contains parameter values from previous model, used to initialize subsequent model.#
## Pass in pre-fitted values for pendant edges and virgin nodes (in 'prefit'); DON'T recalculate.#
## Need to consider the possibility of birth-death, yule, mixed, or constrained models.#
## Need to consider where shft is placed (shiftCut). Placement affects not only new clade, but#
## also the size of the split clade. Only relevant if shiftCut = "both".#
sisterFit <- function (node, z, desc, fit, model, fixPar, criterion)#
{#
	sp <- NULL;#
	aff <- NULL;#
	op <- fit$par; # store previously fit parameter values#
	cut.at <- NULL;#
	cool <- TRUE;#
	#
	fit1 <- NULL;#
	fit2 <- NULL;#
	#
## First, diminshed clade#
	obj <- medusaSplitStem(node=node, z=z, desc=desc);#
	z.stem <- obj$z;#
	aff <- obj$affected;#
#
## Ensure that neither partition is empty; can occur with "node" or "both" cutting. If so, kill it.#
	if (sum(z.stem[,"partition"] == aff[1]) == 0 || sum(z.stem[,"partition"] == aff[2]) == 0)#
	{#
		fit$lnLik <- -Inf;#
		fit$aic <- Inf;#
		fit$aicc <- Inf;#
		return(fit);#
	}#
	#
## Everything is cool; proceed.#
	sp <- op[aff[1],]; # Use previously fit parameter values from clade that is currently being split#
	#
## first, consider diminshed clade. may result in a clade that has been cached previously#
	dimClade <- z.stem[z.stem[,"partition"] == aff[1],,drop=FALSE];#
	#
	fit1 <- getOptimalModelFlavour(z=dimClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
	#
## Sister clade#
	newClade <- z.stem[z.stem[,"partition"] == aff[2],,drop=FALSE];#
	fit2 <- getOptimalModelFlavour(z=newClade, sp=sp, model=model, fixPar=fixPar, criterion=criterion);#
#
	cut.at <- "stem";#
	#
	op[aff[1],] <- fit1$par; # Replace parameters with new values for diminished clade#
	#
	fit$model[aff[1]] <- fit1$model;#
	fit$par <- rbind(op, fit2$par);#
	fit$lnLik.part[aff] <- c(fit1$lnLik, fit2$lnLik); # Replace parameters with new values for diminished clade#
	fit$split.at <- c(fit$split.at, node);#
	fit$lnLik <- sum(fit$lnLik.part);#
	#
	model.fit <- calculateModelFit(fit=fit, z=z);#
	#
	fit$aic <- model.fit[1];#
	fit$aicc <- model.fit[2];#
	fit$num.par <- model.fit[3];#
	fit$cut.at <- c(fit$cut.at, cut.at);#
	fit$model <- c(fit$model, fit2$model);#
	fit$z <- z.stem;#
	fit$step <- rbind(fit$step, c("add", node));#
	#
	return(list(fit));#
}#
#
findMrca <- function(phy, tips)#
{#
	tt <- match(tips, phy$tip.label);#
	if (sum(!is.na(tt)) != length(tips))#
	{#
		for (i in 1:length(tt))#
		{#
			if (is.na(tt[i]))#
			{#
				cat("\n\nWarning: taxon '", tips[i], "' is not found in the tree. Stopping.\n", sep="");#
				stop;#
			}#
		}#
	}#
	return(getMRCA(phy, tt)); # ape function#
}#
#
# 'tips' contains 2 (or more) tip labels, used for defining a MRCA node#
extractSubTree <- function (phy, tips=NULL, node=NULL, richness=NULL, verbose=T)#
{#
	if (is.null(tips) && is.null(node) && node != "root") stop("\n\nWarning: need to provide either a node number or set of 2 taxa whose MRCA is the desired node. Stopping.\n");#
	#
	if (!is.null(tips))#
	{#
		node <- findMrca(phy, tips);#
	} else if (node == "root") {#
		node <- length(phy$tip.label) + 1;#
	}#
#	cat(node, "\n");#
	phy <- extract.clade(phy, node); # ape function#
	#
## Prune tree with richness data as necessary.#
	phyData <- prepareData(phy=phy, richness=richness, verbose=verbose);#
	#
	return(phyData);#
}#
#
#
sisterFitSummary <- function (results, criterion, fixPar, plotSurface=FALSE)#
{#
	summarizeSingleTree <- function ()#
	{#
	## Get profile likelihoods for base and sister model separately#
		models <- results$models;#
		z <- results$z;#
		#
		base <- models[[1]];#
		sis <- models[[2]];#
		#
		baseProfLikes <- getProfileLikelihoods(z=base$z, parm=base$par, models=base$model, fixPar=fixPar);#
		sisterProfLikes <- getProfileLikelihoods(z=sis$z, parm=sis$par, models=sis$model, fixPar=fixPar);#
		profLikes <- rbind(baseProfLikes, sisterProfLikes);#
		par <- rbind(base$par, sis$par);#
		modelFlavour <- c(base$model, sis$model[1], sis$model[2]);#
		richness <- c(sum(z[,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 1,"n.t"], na.rm=T), sum(sis$z[sis$z[,"partition"] == 2,"n.t"], na.rm=T));#
		#
		clades <- c("Base", "Clade1", "Clade2");#
		indLikes <- c(base$lnLik, sis$lnLik.part[1], sis$lnLik.part[2]);#
		modelLikes <- c(base$lnLik, sis$lnLik);#
		numPar <- c(base$num.par, sis$num.par);#
		#
	## Calculate model weights; 'fit' contains just AIC scores. Returns: data.frame(fit=fit, delta=delta, w=w);#
		scores <- c(as.numeric(models[[1]][criterion]), as.numeric(models[[2]][criterion]));#
		weights <- calculateModelWeights(fit=scores);#
		#
		if (all(modelFlavour == "yule"))#
		{#
			parameterSummary <- cbind(Clade=clades, Richness=richness, lnLik=indLikes, model=modelFlavour, r=par[,1], profLikes[,1:2]);#
		} else {#
			parameterSummary <- cbind(Clade=clades, Richness=richness,lnLik=indLikes, model=modelFlavour, par, profLikes);#
		}#
		#
		modelSummary <- cbind(Model=c("Base", "Sisters"), lnLik=modelLikes, numPar=numPar, weights);#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	summarizeMultipleTrees <- function ()#
	{#
		cladeNames <-c("Base", "Clade1", "Clade2");#
		basePar <- NULL;#
		clade1Par <- NULL;#
		clade2Par <- NULL;#
		AICscores <- list();#
		#
		for (i in 1:length(results))#
		{#
			models <- results[[i]]$models;#
			base <- models[[1]];#
			sis <- models[[2]];#
			basePar <- rbind(basePar, base$par);#
			clade1Par <- rbind(clade1Par, sis$par[1,]);#
			clade2Par <- rbind(clade2Par, sis$par[2,]);#
			AICscores <- c(AICscores, list(c(as.numeric(base[criterion]), as.numeric(sis[criterion]))));#
		}#
		summBasePar <- summarizeParameters(basePar);#
		summClade1Par <- summarizeParameters(clade1Par);#
		summClade2Par <- summarizeParameters(clade2Par);#
		summPar <- rbind(summBasePar, summClade1Par, summClade2Par);#
		summPar <- as.data.frame(summPar); rownames(summPar) <- NULL;#
		summPar <- cbind(Clade=cladeNames, summPar);#
		#
		if (all(is.na(summPar[,"Mean.eps"]))) # yule; forget epsilon#
		{#
			summPar <- summPar[,c(1:5)];#
			parameterSummary <- summPar[,c(1:5)];#
		} else {#
			parameterSummary <- summPar;#
		}#
		#
		modelSummary <- summarizeMultipleSisterModelFit(AICscores);#
		#
		cat("\nResults from the analysis of ", length(results), " phylogenetic trees.\n", sep="");#
		#
		cat("\nParameter Summary:\n\n");#
		print(parameterSummary);#
		#
		cat("\nModel Fit Summary:\n\n");#
		print(modelSummary);#
		#
		summary <- list(parSumm=parameterSummary, modSumm=modelSummary);#
		return(summary);#
	}#
	#
	if (length(results) == 2) # single tree#
	{#
		summary <- summarizeSingleTree();#
		summary$nTrees <- 1;#
	} else { # multiple trees#
		summary <- summarizeMultipleTrees();#
		summary$nTrees <- length(results);#
	}#
	#
	return(summary);#
}#
#
#
## Passed-in 'p' will be a two-column matrix#
summarizeParameters <- function(p)#
{#
## Want: mean, min, max, st.dev#
	p1 <- c(Mean.r=mean(p[,1]), Min=min(p[,1]), Max=max(p[,1]), StDev=sd(p[,1]));#
	p2 <- c(Mean.eps=mean(p[,2]), Min=min(p[,2]), Max=max(p[,2]), StDev=sd(p[,2]));#
	#
	parSummary <- c(p1, p2);#
	#
	return(parSummary);#
}#
#
#
## 'AICscores' is a list of AIC scores for base and sister models#
summarizeMultipleSisterModelFit <- function(AICscores)#
{#
	delta <- NULL;#
	w <- NULL;#
	#
	for (i in 1:length(AICscores))#
	{#
		x <- calculateModelWeights(AICscores[[i]]);#
		delta <- rbind(delta, x$delta);#
		w <- rbind(w, x$w);#
	}#
	#
	res <- matrix(nrow=2, ncol=6);#
	colnames(res) <- c("Mean.delta", "SD.delta", "Mean.w", "SD.w", "Min.w", "Max.w");#
	#
	res[1,] <- c(mean(delta[,1]), sd(delta[,1]), mean(w[,1]), sd(w[,1]), min(w[,1]), max(w[,1]));#
	res[2,] <- c(mean(delta[,2]), sd(delta[,2]), mean(w[,2]), sd(w[,2]), min(w[,2]), max(w[,2]));#
	res <- as.data.frame(res);#
	#
	best <- sum(delta[,1] == 0) / length(delta[,1]);#
	best <- c(best, 1-best);#
	#
	modelSummary <- cbind(Model=c("Base", "Sisters"), Prop.best=best, res);#
	#
	return(modelSummary);#
}#
#
print.sisterFit <- function(x, ...)#
{#
	if (x$nTrees > 1) {cat("\nResults from the analysis of ", x$nTrees, " phylogenetic trees.\n", sep="");}#
	#
	cat("\nParameter Summary:\n\n");#
	print(x$parameterSummary);#
	if (x$nTrees == 1) {cat("\n95% confidence intervals calculated from profile likelihoods.\n");}#
	#
	cat("\nModel Fit Summary:\n\n");#
	print(x$modelSummary);#
	cat("\n");#
}
fitSisters(x, node="root", verbose=FALSE) -> foo
require(turboMEDUSA)
citation("turboMEDUSA")
require(MEDUSA)
load("/Users/josephwb/Projects/R_working/turboMEDUSA/DATA/tmp.rda")
phy <- tmp$phy
richness <- tmp$richness
MEDUSA(phy, richness) -> res
res
class(res)
print.medusa
print.medusa <- function(x, ...)#
{#
	cat("\n");#
	print(x$modelSummary);#
	cat("\n");#
}
res
rm(print.medusa)
res
require(MEDUSA)
load("/Users/josephwb/Projects/R_working/turboMEDUSA/DATA/tmp.rda")
phy <- tmp$phy
MEDUSA(phy) -> foo
class (foo)
foo
require(geiger)
?birthdeath
require(MEDUSA)
load("/Users/josephwb/Projects/R_working/turboMEDUSA/DATA/tmp.rda")
phy <- tmp$phy
richness <- tmp$richness
MEDUSA(phy, richness) -> res
res
class(res)
fitSisters(phy, node=422) -> foo
class(foo)
foo
check.multicore<-function () #
{#
    tmp = rownames(installed.packages())#
    if ("multicore" %in% tmp) {#
        require(multicore);#
        return(TRUE);#
    }#
    else {#
        return(FALSE);#
    }#
}
check.multicore<-function () #
{#
    tmp = rownames(installed.packages());#
    if ("multicore" %in% tmp)#
    {#
        require(multicore);#
        return(TRUE);#
    } else {#
        return(FALSE);#
    }#
}
		res <- check.multicore();
res
check.multicore()
!check.multicore()
## Function to prune tree using 'richness' information, assumed to have minimally two columns, "taxon" and "n.taxa"#
##   Perhaps relax on these column names, may cause too many problems#
## May also include 'exemplar' column; in that case, rename relevant tip.label before pruning.#
prepareData <- function (phy, richness, verbose)#
{#
	if (is.null(richness)) { # Assume tree represents single species tips and is completely sampled#
		richness <- data.frame(taxon=phy$tip.label, n.taxa=1);#
	}#
# Rename exemplar taxa with taxon name in richness file#
	if (!is.null(richness$exemplar))#
	{#
# Change relevant tip.labels in phy; individual 'exemplar' may be NA, use original tip.label.#
# Ordering in richness file should NOT be assumed to match order of tip.labels#
		i.na <- is.na(richness$exemplar);#
		phy$tip.label[match(richness$exemplar[!i.na], phy$tip.label)] <- as.character(richness$taxon[!i.na]);#
	}#
	#
# make sure things are in the correct order and of correct format#
	if (length(richness[1,]) == 2)#
	{#
		if (colnames(richness)[1] != "taxon" || colnames(richness)[2] != "n.taxa")#
		{#
			if (class(richness[,1]) == "factor" & class(richness[,2]) == "integer")#
			{#
				colnames(richness) = c("taxon", "n.taxa");#
			} else if (class(richness[,1]) == "integer" & class(richness[,2]) == "factor")#
			{#
				colnames(richness) = c("n.taxa", "taxon");#
			} else {#
				cat("MEDUSA thinks your richness data is in an incorrect format. See ?MEDUSA.\n")#
				stop;#
			}#
		}#
	}#
	#
	if (class(phy) != "phylo") {cat("\n\nWARNING: tree is not of class \"phylo\". Stopping.\n"); stop;}#
	#
# Prune tree down to lineages with assigned richnesses#
	temp <- richness[, "n.taxa"];#
	names(temp) <- richness[, "taxon"];#
	pruned <- treedata(phy, temp, warnings=verbose)  # geiger function calling ape (namecheck)#
	#
# checking for typos#
	if (length(pruned$phy$tip.label) == 0) {#
		cat("\n\nWARNING: MEDUSA encountered a serious error. Tree has no tips after processing richness information! \nIt is likely that an incorrect richness file is being used. \nAnalysis cannot proceed. Please examine the information below to identify the error.\\nn");#
		cat("\nTree tip labels:\n");#
		print(phy$tip.label);#
		cat("\nRichness taxon labels:\n");#
		print(as.character(richness[, "taxon"]));#
		stop;#
	} else if (length(phy$tip.label) != length(pruned$phy$tip.label)) {#
		cat("MEDUSA thinks there is a typo in either the tree or richness files, as one or more tips were dropped from the tree.\n");#
		stop;#
	}#
#
	phy <- pruned$phy;#
# Check the tree#
	#	plotNN(phy)					# Node numbers (ape-style) plotted#
	#
	return(list(phy=phy, richness=richness));#
}#
#
# Determine desired model from passed in fixed parameters (if present)#
configureModel <- function (model, epsilon, r, b, d, initialR, initialE)#
{#
	sp <- NULL;#
	fixPar <- NULL;#
	if (!is.null(epsilon)) # user-defined epsilon#
	{#
		if (epsilon <= 0 | epsilon >= 1) {cat("\n\nWARNING: value of epsilon (", epsilon, ") is invalid; must be > 0 and < 1. Stopping analysis.\n", sep=""); stop;}#
		sp <- c(initialR, epsilon);#
		fixPar <- epsilon;#
		model <- "fixedEpsilon";#
	} else if (!is.null(r)) # user-defined net diversification rate#
	{#
		if (r <= 0) {cat("\n\nWARNING: value of r (", r, ") is invalid; must be > 0. Stopping analysis.\n", sep=""); stop;}#
		sp <- c(r, initialE);#
		fixPar <- r;#
		model <- "fixedR";#
	} else if (!is.null(d)) # user-defined extiction rate#
	{#
		if (d <= 0) {cat("\n\nWARNING: value of d (", d, ") is invalid; must be > 0. Stopping analysis.\n", sep=""); stop;}#
		sp <- c(initialR, d);#
		fixPar <- d;#
		model <- "fixedD";#
	} else if (!is.null(b)) # user-defined speciation rate#
	{#
		if (b <= 0) {cat("\n\nWARNING: value of b (", b, ") is invalid; must be > 0. Stopping analysis.\n", sep=""); stop;}#
		sp <- c((b/2), initialE);#
		fixPar <- b;#
		model <- "fixedB";#
	} else {#
		sp <- c(initialR, initialE);#
	}#
	return(list(model=model, sp=sp, fixPar=fixPar))#
}#
#
#
## Original default was to fit 20 models (or less if the tree was small).#
## Changing to a stop-criterion (stop="modelLimit") e.g. when k = n-1 (i.e. when denominator of aicc correction is undefined).#
## k <- (3*i-1) # when both birth and death are estimated, where i is the number of piecewise models#
  ## This occurs when i = n/3#
  ## If Yule, max i = n/2#
## n <- (2*num.taxa - 1) == (2*length(richness[,1]) - 1) # i.e. total number of nodes in tree (internal + pendant)#
## Alternatively use aicc threshold itself as a stopping criterion (stop="threshold").#
# AICc = AIC + 2*k*(k+1)/(n-k-1);#
getMaxModelLimit <- function (richness, modelLimit, model, stop)#
{#
	samp.size <- (2*length(richness[,1]) - 1)#
	if (model == "bd" || model == "mixed")#
	{#
		max.modelLimit <- as.integer(samp.size/3) - ((!(samp.size %% 3)) * 1);#
	} else {#
		max.modelLimit <- as.integer(samp.size/2) - ((!(samp.size %% 2)) * 1); # models estimating only one diversification parameter#
	}#
	#
	if (stop == "modelLimit")#
	{#
		if (modelLimit > max.modelLimit) {modelLimit <- max.modelLimit;}#
		cat("Limiting consideration to ", modelLimit, " piecewise", sep="");#
		if (model == "bd") {#
			cat(" birth-death models")#
		} else if (model == "mixed") {#
			cat(" mixed models")#
		} else if (model == "yule") {#
			cat(" pure-birth (Yule) models");#
		} else {#
			cat(" diversification models")#
		}#
		cat(".\n\n");#
	}#
	#
	return(modelLimit);#
}#
#
#
## Fitted curve from random b-d simulations#
## Value corresponds to 95th percentile of AICc(split) - AICc(no-split) for no-split simulations#
## x-shifted power function#
getThreshold <- function (treeSize, fixThreshold, stop)#
{#
	a = -3.5941052380332650E+01;#
	b =  6.7372587299747000E+00;#
	c = -1.0061508340754866E-01;#
	Offset =  2.7516678664333408E+01;#
	threshold <- a * (treeSize-b)^c + Offset;#
	if (threshold < 0 || is.nan(threshold)) threshold <- 0;#
	#
	if (!is.null(fixThreshold))#
	{#
		if (is.nan(fixThreshold) || class(fixThreshold) != "numeric" || fixThreshold < 0)#
		{#
			cat("Provided threshold value of '", fixThreshold, "' is invalid.\n", sep="")#
			cat("Will proceed with value determined from simulations.\n")#
			cat("Appropriate AICc threshold for tree of ", treeSize, " tips is: ", threshold, ".\n", sep="");#
			return(threshold);#
		} else {#
			cat("Using provided threshold value of ", fixThreshold, ".\n", sep="")#
			cat("From simulations, appropriate AICc threshold for tree of ", treeSize, " tips would be: ", threshold, ".\n", sep="");#
			return(fixThreshold);#
		}#
	} else {#
		if (stop == "threshold") {#
			cat("Using AIC-threshold as analysis-terminating criterion.\n");#
			cat("Appropriate threshold for tree of ", treeSize, " tips is: ", threshold, ".\n\n", sep="");#
		}#
		return(threshold);#
	}#
}#
#
#
## The makeCacheMedusa function is like the first half of the original splitEdgeMatrix().#
## It works through and reorders the edges, then works out start and end times of these#
## based on the phylogeny's branching times.#
###
## In addition, every node's descendants are also calculated.  The element 'desc' is a list.#
## $desc[i] contains the indices within $edge, $t.start, etc., of all descendants of node 'i'#
## (in ape node numbering format).#
makeCacheMedusa <- function (phy, richness, all.nodes, shiftCut, mc, numCores, verbose=TRUE)#
{#
	n.tips <- length(phy$tip.label);#
	n.int <- nrow(phy$edge) - n.tips;#
	#
## Ape numbers the tips first#
	i.int <- seq_len(n.int);#
	interior <- phy$edge[,2] %in% phy$edge[,1];#
	bt <- branching.times(phy);#
	#
# Consider only internal edges first#
	edges.int <- phy$edge[interior,];#
	colnames(edges.int) <- c("anc", "dec");#
	#
	t.0 <- bt[match(edges.int[,1], (n.tips+1):max(edges.int))];#
	t.1 <- c(t.0[i.int] - phy$edge.length[interior]);#
	#
	z.internal <- cbind(edges.int, t.0, t.1, t.len=t.0 - t.1,#
		n.0=rep(1, n.int), n.t=rep(NA, n.int));#
	#
# Now, pendant edges; #
	edges.pendant <- phy$edge[match(seq_len(n.tips), phy$edge[,2]),];#
	colnames(edges.pendant) <- c("anc", "dec");#
	#
	t.0 <- bt[match(edges.pendant[,1], (n.tips+1):max(edges.pendant))];#
	t.1 <- rep(0, n.tips);#
# cannot assume richness ordering necessarily matches that of tip labels#
	ext.richness <- richness$n.taxa[match(phy$tip.label, richness$taxon)];#
	#
	z.pendant <- cbind(edges.pendant, t.0, t.1, t.len=t.0 - t.1,#
		n.0=rep(1, n.tips), n.t=ext.richness);#
	#
	z <- rbind(z.internal, z.pendant);#
	z <- cbind(z,partition=rep(1, length(z[,1]))); # Stores piecewise model structure#
	rownames(z) <- NULL;#
	#
# Used for identifying descendant nodes below i.e. tracking breakpoints#
	all.edges <- as.matrix(z[,c("anc","dec")]);#
	desc.stem <- list();#
	desc.node <- list();#
	#
	if (verbose) cat("  Gathering descendant node information...");#
	if (mc)#
	{#
		if (shiftCut == "both" || shiftCut == "stem")#
		{#
			desc.stem <- mclapply(seq_len(max(all.edges)), descendantsCutAtStem.idx, all.edges=all.edges, mc.cores=numCores);#
		}#
		if (shiftCut == "both" || shiftCut == "node")#
		{#
			if (!is.null(desc.stem))#
			{#
				root <- min(z[,"anc"]);#
				desc.node <- mclapply(desc.stem, stripStem, mc.cores=numCores);#
				desc.node[root] <- desc.stem[root];#
			} else {#
				desc.node <- mclapply(seq_len(max(all.edges)), descendantsCutAtNode.idx, all.edges=all.edges, mc.cores=numCores);#
			}#
		}#
	} else {#
		if (shiftCut == "both" || shiftCut == "stem")#
		{#
			desc.stem <- lapply(seq_len(max(all.edges)), descendantsCutAtStem.idx, all.edges=all.edges);#
		}#
		if (shiftCut == "both" || shiftCut == "node")#
		{#
			if (!is.null(desc.stem))#
			{#
				root <- min(z[,"anc"]);#
				desc.node <- lapply(desc.stem, stripStem);#
				desc.node[root] <- desc.stem[root];#
			} else {#
				desc.node <- lapply(seq_len(max(all.edges)), descendantsCutAtNode.idx, all.edges=all.edges);#
			}#
		}#
	}#
	if (verbose) cat(" done.\n");#
	#
## Needed downstream; don't recalculate#
 ## Gives the number of tips associated with an internal node; determines whether a node is 'virgin' or not#
	num.tips <- list()#
	if (verbose) cat("  Gathering tip richness information...");#
	if (mc)#
	{#
		num.tips <- mclapply(all.nodes, getNumTips, phy=phy, totalTips=n.tips, mc.cores=numCores);#
	} else {#
		num.tips <- lapply(all.nodes, getNumTips, phy=phy, totalTips=n.tips);#
	}#
	if (verbose) cat(" done.\n");#
	#
	res <- list(z=z, desc.stem=desc.stem, desc.node=desc.node, num.tips=num.tips);#
	return(res);#
}#
#
#
## Get the number of tips descended from internal node 'node'.#
## Needed for determining whether nodes are virgin nodes.#
## Uses code from geiger functions 'node.sons' and 'node.leaves'.#
getNumTips <- function (node, phy, totalTips=NULL)#
{#
	if (is.null(totalTips)) totalTips <- length(phy$tip.label);#
	if (node <= totalTips) return(1);#
	#
	n <- 0;#
	d <- phy$edge[which(phy$edge[, 1] == node), 2];#
	for (j in d) {#
		if (j <= totalTips)#
			n <- n + 1#
		else n <- n + getNumTips(j, phy, totalTips)#
	}#
	return(n);#
}#
#
#
#
#
#
# *** MAYBE RECODE descendantsCutAtStem IN C++ AS IT IS SLOW FOR LARGE TREES ***#
#
## This generates the indices of all descendants of a node, using ape's edge matrix.#
## Deals with row numbers of the edge matrix rather than node numbers of the tree.#
descendantsCutAtStem <- function (node, all.edges)#
{#
	ans <- numeric();#
	ans <- node;#
	repeat {#
		node <- all.edges[all.edges[,1] %in% node,2];#
		if (length(node) > 0)#
		{#
			ans <- c(ans, node);#
		} else {break;}#
	}#
	return(ans);#
}#
#
#
## The function 'descendants' returns the indices of all descendants within the edge matrix.#
descendantsCutAtStem.idx <- function (node.list, all.edges)#
{#
	which(all.edges[,1] == node.list | all.edges[,2] %in% descendantsCutAtStem(node.list, all.edges));#
}#
#
#
# Remove stem node from previously calculated set of descendants; about a billion times faster than descendantsCutAtNode#
stripStem <- function (x)#
{#
	y <- unlist(x);#
	return(y[-1]);#
}#
#
#
## This generates the indices of all descendants of a node, using ape's edge matrix.#
## Deals with row numbers of the edge matrix rather than node numbers of the tree.#
descendantsCutAtNode <- function (node, all.edges)#
{#
	ans <- numeric();#
	repeat {#
		node <- all.edges[all.edges[,1] %in% node,2];#
		if (length(node) > 0)#
		{#
			ans <- c(ans, node);#
		} else {break;}#
	}#
	return(ans);#
}#
#
#
## The function 'descendants' returns the indices of all descendants within the edge matrix.#
descendantsCutAtNode.idx <- function (node.list, all.edges)#
{#
	which(all.edges[,1] == node.list | all.edges[,2] %in% descendantsCutAtNode(node.list, all.edges));#
}#
#
#
## via Jon Eastman#
check.multicore<-function () #
{#
    tmp = rownames(installed.packages());#
    if ("multicore" %in% tmp)#
    {#
        require(multicore);#
        return(TRUE);#
    } else {#
        return(FALSE);#
    }#
}#
#
#
## Check that provided arguments are valid#
checkValidArguments <- function (phy, richness, model, modelLimit, stop, shiftCut, criterion, stepBack,#
	preserveModelFlavour, epsilon, r, b, d, fixThreshold, initialR, initialE,#
	verbose, mc, numCores)#
{#
	if (class(phy) != "phylo" && class(phy) != "multiPhylo") {cat("\n\nWARNING: tree is not of class \"phylo\". Stopping.\n"); stop;}#
	#
## String arguments#
	model=match.arg(model, choices=c("mixed", "bd", "yule"));#
	stop=match.arg(stop, choices=c("threshold","modelLimit"));#
	shiftCut=match.arg(shiftCut, choices=c("both", "stem", "node"));#
	criterion=match.arg(criterion, choices=c("aicc", "aic"));#
	#
## Boolean arguments#
	if (class(stepBack) != "logical") {cat("\n\nWARNING: argument \"stepBack\"is not of class \"logical\". Stopping.\n"); stop;}#
	if (class(preserveModelFlavour) != "logical") {cat("\n\nWARNING: argument \"preserveModelFlavour\"is not of class \"logical\". Stopping.\n"); stop;}#
	if (class(verbose) != "logical") {cat("\n\nWARNING: argument \"verbose\"is not of class \"logical\". Stopping.\n"); stop;}#
	if (class(mc) != "logical") {cat("\n\nWARNING: argument \"mc\" is not of class \"logical\". Stopping.\n"); stop;}#
	#
	if (mc)#
	{#
		if (!check.multicore())#
		{#
			cat("\"mc\" argument provided, but package \"multicore\" is not installed. Stopping.\n"); stop;#
		}#
	}#
	#
## Numeric arguments#
	if (class(modelLimit) != "numeric" && class(modelLimit) != "NULL") {cat("\n\nWARNING: argument \"modelLimit\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(epsilon) != "numeric" && class(epsilon) != "NULL") {cat("\n\nWARNING: argument \"epsilon\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(r) != "numeric" && class(r) != "NULL") {cat("\n\nWARNING: argument \"r\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(b) != "numeric" && class(b) != "NULL") {cat("\n\nWARNING: argument \"b\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(d) != "numeric" && class(d) != "NULL") {cat("\n\nWARNING: argument \"d\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(fixThreshold) != "numeric" && class(fixThreshold) != "NULL") {cat("\n\nWARNING: argument \"fixThreshold\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(initialR) != "numeric" && class(initialR) != "NULL") {cat("\n\nWARNING: argument \"initialR\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(initialE) != "numeric" && class(initialE) != "NULL") {cat("\n\nWARNING: argument \"initialE\"is not valid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
	if (class(numCores) != "numeric" && class(numCores) != "NULL") {cat("\n\nWARNING: argument \"numCores\"is invalid. Expecting 'NULL' or numeric. Stopping.\n"); stop;}#
}
			cat("\"mc\" argument provided, but package \"multicore\" is not installed. Stopping.\n"); stop;
			stop("\"mc\" argument provided, but package \"multicore\" is not installed. Stopping.\n");
?attach
?Sys.info()
Sys.info()["sysname"]
Sys.info()
system("id")
Sys.getenv
Sys.getenv()
?Sys.getenv
Sys.getenv()["R_GUI_APP_VERSION"]
?is.na
Sys.info()["sysname"]
load("/Users/josephwb/Projects/R_working/turboMEDUSA/DATA/tmp.rda")
require(MEDUSA)
phy <- tmp$phy
richness <- tmp$richness
MEDUSA(phy, richness=NULL) -> foo
MEDUSA(phy, richness=NULL, mc=T) -> foo
